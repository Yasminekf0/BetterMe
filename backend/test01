
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model OAuthAccount
 * 
 */
export type OAuthAccount = $Result.DefaultSelection<Prisma.$OAuthAccountPayload>
/**
 * Model LoginConfig
 * 
 */
export type LoginConfig = $Result.DefaultSelection<Prisma.$LoginConfigPayload>
/**
 * Model Scenario
 * 
 */
export type Scenario = $Result.DefaultSelection<Prisma.$ScenarioPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Feedback
 * 
 */
export type Feedback = $Result.DefaultSelection<Prisma.$FeedbackPayload>
/**
 * Model FollowUpEmail
 * 
 */
export type FollowUpEmail = $Result.DefaultSelection<Prisma.$FollowUpEmailPayload>
/**
 * Model AIModel
 * 
 */
export type AIModel = $Result.DefaultSelection<Prisma.$AIModelPayload>
/**
 * Model SystemSetting
 * 
 */
export type SystemSetting = $Result.DefaultSelection<Prisma.$SystemSettingPayload>
/**
 * Model BuyerPersonaTemplate
 * 
 */
export type BuyerPersonaTemplate = $Result.DefaultSelection<Prisma.$BuyerPersonaTemplatePayload>
/**
 * Model OperationLog
 * 
 */
export type OperationLog = $Result.DefaultSelection<Prisma.$OperationLogPayload>
/**
 * Model Media
 * 
 */
export type Media = $Result.DefaultSelection<Prisma.$MediaPayload>
/**
 * Model StorageConfig
 * 
 */
export type StorageConfig = $Result.DefaultSelection<Prisma.$StorageConfigPayload>
/**
 * Model Plugin
 * 
 */
export type Plugin = $Result.DefaultSelection<Prisma.$PluginPayload>
/**
 * Model PluginInstallation
 * 
 */
export type PluginInstallation = $Result.DefaultSelection<Prisma.$PluginInstallationPayload>
/**
 * Model ArticleCategory
 * 
 */
export type ArticleCategory = $Result.DefaultSelection<Prisma.$ArticleCategoryPayload>
/**
 * Model Article
 * 
 */
export type Article = $Result.DefaultSelection<Prisma.$ArticlePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model UserNotification
 * 
 */
export type UserNotification = $Result.DefaultSelection<Prisma.$UserNotificationPayload>
/**
 * Model PaymentConfig
 * 
 */
export type PaymentConfig = $Result.DefaultSelection<Prisma.$PaymentConfigPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model MembershipPlan
 * 
 */
export type MembershipPlan = $Result.DefaultSelection<Prisma.$MembershipPlanPayload>
/**
 * Model PointsConfig
 * 
 */
export type PointsConfig = $Result.DefaultSelection<Prisma.$PointsConfigPayload>
/**
 * Model PointRecord
 * 
 */
export type PointRecord = $Result.DefaultSelection<Prisma.$PointRecordPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model UserRoleAssignment
 * 
 */
export type UserRoleAssignment = $Result.DefaultSelection<Prisma.$UserRoleAssignmentPayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model Language
 * 
 */
export type Language = $Result.DefaultSelection<Prisma.$LanguagePayload>
/**
 * Model Translation
 * 
 */
export type Translation = $Result.DefaultSelection<Prisma.$TranslationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  USER: 'USER',
  TRAINER: 'TRAINER',
  ADMIN: 'ADMIN',
  SUPER_ADMIN: 'SUPER_ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const OAuthProvider: {
  WECHAT: 'WECHAT',
  DINGTALK: 'DINGTALK',
  FEISHU: 'FEISHU',
  GOOGLE: 'GOOGLE',
  GITHUB: 'GITHUB'
};

export type OAuthProvider = (typeof OAuthProvider)[keyof typeof OAuthProvider]


export const Difficulty: {
  EASY: 'EASY',
  MEDIUM: 'MEDIUM',
  HARD: 'HARD'
};

export type Difficulty = (typeof Difficulty)[keyof typeof Difficulty]


export const SessionStatus: {
  ACTIVE: 'ACTIVE',
  COMPLETED: 'COMPLETED',
  ABANDONED: 'ABANDONED'
};

export type SessionStatus = (typeof SessionStatus)[keyof typeof SessionStatus]


export const MessageRole: {
  USER: 'USER',
  AI: 'AI',
  SYSTEM: 'SYSTEM'
};

export type MessageRole = (typeof MessageRole)[keyof typeof MessageRole]


export const StorageType: {
  LOCAL: 'LOCAL',
  ALIYUN_OSS: 'ALIYUN_OSS',
  AWS_S3: 'AWS_S3'
};

export type StorageType = (typeof StorageType)[keyof typeof StorageType]


export const PluginCategory: {
  AI_TOOLS: 'AI_TOOLS',
  ANALYTICS: 'ANALYTICS',
  COMMUNICATION: 'COMMUNICATION',
  PRODUCTIVITY: 'PRODUCTIVITY',
  INTEGRATION: 'INTEGRATION',
  MARKETING: 'MARKETING',
  CONTENT: 'CONTENT',
  OTHER: 'OTHER'
};

export type PluginCategory = (typeof PluginCategory)[keyof typeof PluginCategory]


export const ArticleStatus: {
  DRAFT: 'DRAFT',
  PUBLISHED: 'PUBLISHED',
  ARCHIVED: 'ARCHIVED'
};

export type ArticleStatus = (typeof ArticleStatus)[keyof typeof ArticleStatus]


export const NotificationType: {
  SYSTEM: 'SYSTEM',
  ANNOUNCEMENT: 'ANNOUNCEMENT',
  PROMOTION: 'PROMOTION',
  REMINDER: 'REMINDER',
  UPDATE: 'UPDATE'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const NotificationTarget: {
  ALL: 'ALL',
  SPECIFIC: 'SPECIFIC',
  ROLE: 'ROLE'
};

export type NotificationTarget = (typeof NotificationTarget)[keyof typeof NotificationTarget]


export const PaymentProvider: {
  WECHAT: 'WECHAT',
  ALIPAY: 'ALIPAY',
  PAYPAL: 'PAYPAL',
  STRIPE: 'STRIPE',
  EPAY: 'EPAY'
};

export type PaymentProvider = (typeof PaymentProvider)[keyof typeof PaymentProvider]


export const OrderType: {
  MEMBERSHIP: 'MEMBERSHIP',
  POINTS: 'POINTS',
  PLUGIN: 'PLUGIN',
  OTHER: 'OTHER'
};

export type OrderType = (typeof OrderType)[keyof typeof OrderType]


export const OrderStatus: {
  PENDING: 'PENDING',
  PAID: 'PAID',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  REFUNDED: 'REFUNDED',
  EXPIRED: 'EXPIRED'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const PointType: {
  EARN: 'EARN',
  SPEND: 'SPEND',
  REFUND: 'REFUND',
  ADJUST: 'ADJUST',
  EXPIRE: 'EXPIRE'
};

export type PointType = (typeof PointType)[keyof typeof PointType]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type OAuthProvider = $Enums.OAuthProvider

export const OAuthProvider: typeof $Enums.OAuthProvider

export type Difficulty = $Enums.Difficulty

export const Difficulty: typeof $Enums.Difficulty

export type SessionStatus = $Enums.SessionStatus

export const SessionStatus: typeof $Enums.SessionStatus

export type MessageRole = $Enums.MessageRole

export const MessageRole: typeof $Enums.MessageRole

export type StorageType = $Enums.StorageType

export const StorageType: typeof $Enums.StorageType

export type PluginCategory = $Enums.PluginCategory

export const PluginCategory: typeof $Enums.PluginCategory

export type ArticleStatus = $Enums.ArticleStatus

export const ArticleStatus: typeof $Enums.ArticleStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type NotificationTarget = $Enums.NotificationTarget

export const NotificationTarget: typeof $Enums.NotificationTarget

export type PaymentProvider = $Enums.PaymentProvider

export const PaymentProvider: typeof $Enums.PaymentProvider

export type OrderType = $Enums.OrderType

export const OrderType: typeof $Enums.OrderType

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type PointType = $Enums.PointType

export const PointType: typeof $Enums.PointType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.oAuthAccount`: Exposes CRUD operations for the **OAuthAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OAuthAccounts
    * const oAuthAccounts = await prisma.oAuthAccount.findMany()
    * ```
    */
  get oAuthAccount(): Prisma.OAuthAccountDelegate<ExtArgs>;

  /**
   * `prisma.loginConfig`: Exposes CRUD operations for the **LoginConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LoginConfigs
    * const loginConfigs = await prisma.loginConfig.findMany()
    * ```
    */
  get loginConfig(): Prisma.LoginConfigDelegate<ExtArgs>;

  /**
   * `prisma.scenario`: Exposes CRUD operations for the **Scenario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Scenarios
    * const scenarios = await prisma.scenario.findMany()
    * ```
    */
  get scenario(): Prisma.ScenarioDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs>;

  /**
   * `prisma.feedback`: Exposes CRUD operations for the **Feedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Feedbacks
    * const feedbacks = await prisma.feedback.findMany()
    * ```
    */
  get feedback(): Prisma.FeedbackDelegate<ExtArgs>;

  /**
   * `prisma.followUpEmail`: Exposes CRUD operations for the **FollowUpEmail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FollowUpEmails
    * const followUpEmails = await prisma.followUpEmail.findMany()
    * ```
    */
  get followUpEmail(): Prisma.FollowUpEmailDelegate<ExtArgs>;

  /**
   * `prisma.aIModel`: Exposes CRUD operations for the **AIModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIModels
    * const aIModels = await prisma.aIModel.findMany()
    * ```
    */
  get aIModel(): Prisma.AIModelDelegate<ExtArgs>;

  /**
   * `prisma.systemSetting`: Exposes CRUD operations for the **SystemSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemSettings
    * const systemSettings = await prisma.systemSetting.findMany()
    * ```
    */
  get systemSetting(): Prisma.SystemSettingDelegate<ExtArgs>;

  /**
   * `prisma.buyerPersonaTemplate`: Exposes CRUD operations for the **BuyerPersonaTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BuyerPersonaTemplates
    * const buyerPersonaTemplates = await prisma.buyerPersonaTemplate.findMany()
    * ```
    */
  get buyerPersonaTemplate(): Prisma.BuyerPersonaTemplateDelegate<ExtArgs>;

  /**
   * `prisma.operationLog`: Exposes CRUD operations for the **OperationLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OperationLogs
    * const operationLogs = await prisma.operationLog.findMany()
    * ```
    */
  get operationLog(): Prisma.OperationLogDelegate<ExtArgs>;

  /**
   * `prisma.media`: Exposes CRUD operations for the **Media** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Media
    * const media = await prisma.media.findMany()
    * ```
    */
  get media(): Prisma.MediaDelegate<ExtArgs>;

  /**
   * `prisma.storageConfig`: Exposes CRUD operations for the **StorageConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StorageConfigs
    * const storageConfigs = await prisma.storageConfig.findMany()
    * ```
    */
  get storageConfig(): Prisma.StorageConfigDelegate<ExtArgs>;

  /**
   * `prisma.plugin`: Exposes CRUD operations for the **Plugin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plugins
    * const plugins = await prisma.plugin.findMany()
    * ```
    */
  get plugin(): Prisma.PluginDelegate<ExtArgs>;

  /**
   * `prisma.pluginInstallation`: Exposes CRUD operations for the **PluginInstallation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PluginInstallations
    * const pluginInstallations = await prisma.pluginInstallation.findMany()
    * ```
    */
  get pluginInstallation(): Prisma.PluginInstallationDelegate<ExtArgs>;

  /**
   * `prisma.articleCategory`: Exposes CRUD operations for the **ArticleCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ArticleCategories
    * const articleCategories = await prisma.articleCategory.findMany()
    * ```
    */
  get articleCategory(): Prisma.ArticleCategoryDelegate<ExtArgs>;

  /**
   * `prisma.article`: Exposes CRUD operations for the **Article** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Articles
    * const articles = await prisma.article.findMany()
    * ```
    */
  get article(): Prisma.ArticleDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.userNotification`: Exposes CRUD operations for the **UserNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserNotifications
    * const userNotifications = await prisma.userNotification.findMany()
    * ```
    */
  get userNotification(): Prisma.UserNotificationDelegate<ExtArgs>;

  /**
   * `prisma.paymentConfig`: Exposes CRUD operations for the **PaymentConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentConfigs
    * const paymentConfigs = await prisma.paymentConfig.findMany()
    * ```
    */
  get paymentConfig(): Prisma.PaymentConfigDelegate<ExtArgs>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs>;

  /**
   * `prisma.membershipPlan`: Exposes CRUD operations for the **MembershipPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MembershipPlans
    * const membershipPlans = await prisma.membershipPlan.findMany()
    * ```
    */
  get membershipPlan(): Prisma.MembershipPlanDelegate<ExtArgs>;

  /**
   * `prisma.pointsConfig`: Exposes CRUD operations for the **PointsConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PointsConfigs
    * const pointsConfigs = await prisma.pointsConfig.findMany()
    * ```
    */
  get pointsConfig(): Prisma.PointsConfigDelegate<ExtArgs>;

  /**
   * `prisma.pointRecord`: Exposes CRUD operations for the **PointRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PointRecords
    * const pointRecords = await prisma.pointRecord.findMany()
    * ```
    */
  get pointRecord(): Prisma.PointRecordDelegate<ExtArgs>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs>;

  /**
   * `prisma.userRoleAssignment`: Exposes CRUD operations for the **UserRoleAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoleAssignments
    * const userRoleAssignments = await prisma.userRoleAssignment.findMany()
    * ```
    */
  get userRoleAssignment(): Prisma.UserRoleAssignmentDelegate<ExtArgs>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs>;

  /**
   * `prisma.language`: Exposes CRUD operations for the **Language** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Languages
    * const languages = await prisma.language.findMany()
    * ```
    */
  get language(): Prisma.LanguageDelegate<ExtArgs>;

  /**
   * `prisma.translation`: Exposes CRUD operations for the **Translation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Translations
    * const translations = await prisma.translation.findMany()
    * ```
    */
  get translation(): Prisma.TranslationDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    OAuthAccount: 'OAuthAccount',
    LoginConfig: 'LoginConfig',
    Scenario: 'Scenario',
    Session: 'Session',
    Message: 'Message',
    Feedback: 'Feedback',
    FollowUpEmail: 'FollowUpEmail',
    AIModel: 'AIModel',
    SystemSetting: 'SystemSetting',
    BuyerPersonaTemplate: 'BuyerPersonaTemplate',
    OperationLog: 'OperationLog',
    Media: 'Media',
    StorageConfig: 'StorageConfig',
    Plugin: 'Plugin',
    PluginInstallation: 'PluginInstallation',
    ArticleCategory: 'ArticleCategory',
    Article: 'Article',
    Notification: 'Notification',
    UserNotification: 'UserNotification',
    PaymentConfig: 'PaymentConfig',
    Order: 'Order',
    MembershipPlan: 'MembershipPlan',
    PointsConfig: 'PointsConfig',
    PointRecord: 'PointRecord',
    Role: 'Role',
    UserRoleAssignment: 'UserRoleAssignment',
    Permission: 'Permission',
    Language: 'Language',
    Translation: 'Translation'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "oAuthAccount" | "loginConfig" | "scenario" | "session" | "message" | "feedback" | "followUpEmail" | "aIModel" | "systemSetting" | "buyerPersonaTemplate" | "operationLog" | "media" | "storageConfig" | "plugin" | "pluginInstallation" | "articleCategory" | "article" | "notification" | "userNotification" | "paymentConfig" | "order" | "membershipPlan" | "pointsConfig" | "pointRecord" | "role" | "userRoleAssignment" | "permission" | "language" | "translation"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      OAuthAccount: {
        payload: Prisma.$OAuthAccountPayload<ExtArgs>
        fields: Prisma.OAuthAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OAuthAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OAuthAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthAccountPayload>
          }
          findFirst: {
            args: Prisma.OAuthAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OAuthAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthAccountPayload>
          }
          findMany: {
            args: Prisma.OAuthAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthAccountPayload>[]
          }
          create: {
            args: Prisma.OAuthAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthAccountPayload>
          }
          createMany: {
            args: Prisma.OAuthAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OAuthAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthAccountPayload>
          }
          update: {
            args: Prisma.OAuthAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthAccountPayload>
          }
          deleteMany: {
            args: Prisma.OAuthAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OAuthAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OAuthAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OAuthAccountPayload>
          }
          aggregate: {
            args: Prisma.OAuthAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOAuthAccount>
          }
          groupBy: {
            args: Prisma.OAuthAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<OAuthAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.OAuthAccountCountArgs<ExtArgs>
            result: $Utils.Optional<OAuthAccountCountAggregateOutputType> | number
          }
        }
      }
      LoginConfig: {
        payload: Prisma.$LoginConfigPayload<ExtArgs>
        fields: Prisma.LoginConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoginConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoginConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginConfigPayload>
          }
          findFirst: {
            args: Prisma.LoginConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoginConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginConfigPayload>
          }
          findMany: {
            args: Prisma.LoginConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginConfigPayload>[]
          }
          create: {
            args: Prisma.LoginConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginConfigPayload>
          }
          createMany: {
            args: Prisma.LoginConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LoginConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginConfigPayload>
          }
          update: {
            args: Prisma.LoginConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginConfigPayload>
          }
          deleteMany: {
            args: Prisma.LoginConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoginConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LoginConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginConfigPayload>
          }
          aggregate: {
            args: Prisma.LoginConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoginConfig>
          }
          groupBy: {
            args: Prisma.LoginConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoginConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoginConfigCountArgs<ExtArgs>
            result: $Utils.Optional<LoginConfigCountAggregateOutputType> | number
          }
        }
      }
      Scenario: {
        payload: Prisma.$ScenarioPayload<ExtArgs>
        fields: Prisma.ScenarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScenarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScenarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>
          }
          findFirst: {
            args: Prisma.ScenarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScenarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>
          }
          findMany: {
            args: Prisma.ScenarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>[]
          }
          create: {
            args: Prisma.ScenarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>
          }
          createMany: {
            args: Prisma.ScenarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ScenarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>
          }
          update: {
            args: Prisma.ScenarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>
          }
          deleteMany: {
            args: Prisma.ScenarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScenarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ScenarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>
          }
          aggregate: {
            args: Prisma.ScenarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScenario>
          }
          groupBy: {
            args: Prisma.ScenarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScenarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScenarioCountArgs<ExtArgs>
            result: $Utils.Optional<ScenarioCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Feedback: {
        payload: Prisma.$FeedbackPayload<ExtArgs>
        fields: Prisma.FeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          findFirst: {
            args: Prisma.FeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          findMany: {
            args: Prisma.FeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
          }
          create: {
            args: Prisma.FeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          createMany: {
            args: Prisma.FeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          update: {
            args: Prisma.FeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          deleteMany: {
            args: Prisma.FeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          aggregate: {
            args: Prisma.FeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeedback>
          }
          groupBy: {
            args: Prisma.FeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<FeedbackCountAggregateOutputType> | number
          }
        }
      }
      FollowUpEmail: {
        payload: Prisma.$FollowUpEmailPayload<ExtArgs>
        fields: Prisma.FollowUpEmailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FollowUpEmailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpEmailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FollowUpEmailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpEmailPayload>
          }
          findFirst: {
            args: Prisma.FollowUpEmailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpEmailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FollowUpEmailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpEmailPayload>
          }
          findMany: {
            args: Prisma.FollowUpEmailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpEmailPayload>[]
          }
          create: {
            args: Prisma.FollowUpEmailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpEmailPayload>
          }
          createMany: {
            args: Prisma.FollowUpEmailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FollowUpEmailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpEmailPayload>
          }
          update: {
            args: Prisma.FollowUpEmailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpEmailPayload>
          }
          deleteMany: {
            args: Prisma.FollowUpEmailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FollowUpEmailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FollowUpEmailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpEmailPayload>
          }
          aggregate: {
            args: Prisma.FollowUpEmailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFollowUpEmail>
          }
          groupBy: {
            args: Prisma.FollowUpEmailGroupByArgs<ExtArgs>
            result: $Utils.Optional<FollowUpEmailGroupByOutputType>[]
          }
          count: {
            args: Prisma.FollowUpEmailCountArgs<ExtArgs>
            result: $Utils.Optional<FollowUpEmailCountAggregateOutputType> | number
          }
        }
      }
      AIModel: {
        payload: Prisma.$AIModelPayload<ExtArgs>
        fields: Prisma.AIModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIModelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIModelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModelPayload>
          }
          findFirst: {
            args: Prisma.AIModelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIModelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModelPayload>
          }
          findMany: {
            args: Prisma.AIModelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModelPayload>[]
          }
          create: {
            args: Prisma.AIModelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModelPayload>
          }
          createMany: {
            args: Prisma.AIModelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AIModelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModelPayload>
          }
          update: {
            args: Prisma.AIModelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModelPayload>
          }
          deleteMany: {
            args: Prisma.AIModelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIModelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AIModelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModelPayload>
          }
          aggregate: {
            args: Prisma.AIModelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIModel>
          }
          groupBy: {
            args: Prisma.AIModelGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIModelGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIModelCountArgs<ExtArgs>
            result: $Utils.Optional<AIModelCountAggregateOutputType> | number
          }
        }
      }
      SystemSetting: {
        payload: Prisma.$SystemSettingPayload<ExtArgs>
        fields: Prisma.SystemSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          findFirst: {
            args: Prisma.SystemSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          findMany: {
            args: Prisma.SystemSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          create: {
            args: Prisma.SystemSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          createMany: {
            args: Prisma.SystemSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SystemSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          update: {
            args: Prisma.SystemSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          deleteMany: {
            args: Prisma.SystemSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          aggregate: {
            args: Prisma.SystemSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemSetting>
          }
          groupBy: {
            args: Prisma.SystemSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemSettingCountArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingCountAggregateOutputType> | number
          }
        }
      }
      BuyerPersonaTemplate: {
        payload: Prisma.$BuyerPersonaTemplatePayload<ExtArgs>
        fields: Prisma.BuyerPersonaTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BuyerPersonaTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuyerPersonaTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BuyerPersonaTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuyerPersonaTemplatePayload>
          }
          findFirst: {
            args: Prisma.BuyerPersonaTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuyerPersonaTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BuyerPersonaTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuyerPersonaTemplatePayload>
          }
          findMany: {
            args: Prisma.BuyerPersonaTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuyerPersonaTemplatePayload>[]
          }
          create: {
            args: Prisma.BuyerPersonaTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuyerPersonaTemplatePayload>
          }
          createMany: {
            args: Prisma.BuyerPersonaTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BuyerPersonaTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuyerPersonaTemplatePayload>
          }
          update: {
            args: Prisma.BuyerPersonaTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuyerPersonaTemplatePayload>
          }
          deleteMany: {
            args: Prisma.BuyerPersonaTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BuyerPersonaTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BuyerPersonaTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuyerPersonaTemplatePayload>
          }
          aggregate: {
            args: Prisma.BuyerPersonaTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBuyerPersonaTemplate>
          }
          groupBy: {
            args: Prisma.BuyerPersonaTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<BuyerPersonaTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.BuyerPersonaTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<BuyerPersonaTemplateCountAggregateOutputType> | number
          }
        }
      }
      OperationLog: {
        payload: Prisma.$OperationLogPayload<ExtArgs>
        fields: Prisma.OperationLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OperationLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OperationLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationLogPayload>
          }
          findFirst: {
            args: Prisma.OperationLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OperationLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationLogPayload>
          }
          findMany: {
            args: Prisma.OperationLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationLogPayload>[]
          }
          create: {
            args: Prisma.OperationLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationLogPayload>
          }
          createMany: {
            args: Prisma.OperationLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OperationLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationLogPayload>
          }
          update: {
            args: Prisma.OperationLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationLogPayload>
          }
          deleteMany: {
            args: Prisma.OperationLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OperationLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OperationLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationLogPayload>
          }
          aggregate: {
            args: Prisma.OperationLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOperationLog>
          }
          groupBy: {
            args: Prisma.OperationLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<OperationLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.OperationLogCountArgs<ExtArgs>
            result: $Utils.Optional<OperationLogCountAggregateOutputType> | number
          }
        }
      }
      Media: {
        payload: Prisma.$MediaPayload<ExtArgs>
        fields: Prisma.MediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findFirst: {
            args: Prisma.MediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findMany: {
            args: Prisma.MediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          create: {
            args: Prisma.MediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          createMany: {
            args: Prisma.MediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          update: {
            args: Prisma.MediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          deleteMany: {
            args: Prisma.MediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          aggregate: {
            args: Prisma.MediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedia>
          }
          groupBy: {
            args: Prisma.MediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaCountArgs<ExtArgs>
            result: $Utils.Optional<MediaCountAggregateOutputType> | number
          }
        }
      }
      StorageConfig: {
        payload: Prisma.$StorageConfigPayload<ExtArgs>
        fields: Prisma.StorageConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StorageConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StorageConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageConfigPayload>
          }
          findFirst: {
            args: Prisma.StorageConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StorageConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageConfigPayload>
          }
          findMany: {
            args: Prisma.StorageConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageConfigPayload>[]
          }
          create: {
            args: Prisma.StorageConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageConfigPayload>
          }
          createMany: {
            args: Prisma.StorageConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StorageConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageConfigPayload>
          }
          update: {
            args: Prisma.StorageConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageConfigPayload>
          }
          deleteMany: {
            args: Prisma.StorageConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StorageConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StorageConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageConfigPayload>
          }
          aggregate: {
            args: Prisma.StorageConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStorageConfig>
          }
          groupBy: {
            args: Prisma.StorageConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<StorageConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.StorageConfigCountArgs<ExtArgs>
            result: $Utils.Optional<StorageConfigCountAggregateOutputType> | number
          }
        }
      }
      Plugin: {
        payload: Prisma.$PluginPayload<ExtArgs>
        fields: Prisma.PluginFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PluginFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PluginFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPayload>
          }
          findFirst: {
            args: Prisma.PluginFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PluginFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPayload>
          }
          findMany: {
            args: Prisma.PluginFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPayload>[]
          }
          create: {
            args: Prisma.PluginCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPayload>
          }
          createMany: {
            args: Prisma.PluginCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PluginDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPayload>
          }
          update: {
            args: Prisma.PluginUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPayload>
          }
          deleteMany: {
            args: Prisma.PluginDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PluginUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PluginUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPayload>
          }
          aggregate: {
            args: Prisma.PluginAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlugin>
          }
          groupBy: {
            args: Prisma.PluginGroupByArgs<ExtArgs>
            result: $Utils.Optional<PluginGroupByOutputType>[]
          }
          count: {
            args: Prisma.PluginCountArgs<ExtArgs>
            result: $Utils.Optional<PluginCountAggregateOutputType> | number
          }
        }
      }
      PluginInstallation: {
        payload: Prisma.$PluginInstallationPayload<ExtArgs>
        fields: Prisma.PluginInstallationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PluginInstallationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginInstallationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PluginInstallationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginInstallationPayload>
          }
          findFirst: {
            args: Prisma.PluginInstallationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginInstallationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PluginInstallationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginInstallationPayload>
          }
          findMany: {
            args: Prisma.PluginInstallationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginInstallationPayload>[]
          }
          create: {
            args: Prisma.PluginInstallationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginInstallationPayload>
          }
          createMany: {
            args: Prisma.PluginInstallationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PluginInstallationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginInstallationPayload>
          }
          update: {
            args: Prisma.PluginInstallationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginInstallationPayload>
          }
          deleteMany: {
            args: Prisma.PluginInstallationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PluginInstallationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PluginInstallationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginInstallationPayload>
          }
          aggregate: {
            args: Prisma.PluginInstallationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePluginInstallation>
          }
          groupBy: {
            args: Prisma.PluginInstallationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PluginInstallationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PluginInstallationCountArgs<ExtArgs>
            result: $Utils.Optional<PluginInstallationCountAggregateOutputType> | number
          }
        }
      }
      ArticleCategory: {
        payload: Prisma.$ArticleCategoryPayload<ExtArgs>
        fields: Prisma.ArticleCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArticleCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArticleCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleCategoryPayload>
          }
          findFirst: {
            args: Prisma.ArticleCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArticleCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleCategoryPayload>
          }
          findMany: {
            args: Prisma.ArticleCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleCategoryPayload>[]
          }
          create: {
            args: Prisma.ArticleCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleCategoryPayload>
          }
          createMany: {
            args: Prisma.ArticleCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ArticleCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleCategoryPayload>
          }
          update: {
            args: Prisma.ArticleCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ArticleCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArticleCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ArticleCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleCategoryPayload>
          }
          aggregate: {
            args: Prisma.ArticleCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArticleCategory>
          }
          groupBy: {
            args: Prisma.ArticleCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArticleCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArticleCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ArticleCategoryCountAggregateOutputType> | number
          }
        }
      }
      Article: {
        payload: Prisma.$ArticlePayload<ExtArgs>
        fields: Prisma.ArticleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArticleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArticleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          findFirst: {
            args: Prisma.ArticleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArticleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          findMany: {
            args: Prisma.ArticleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>[]
          }
          create: {
            args: Prisma.ArticleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          createMany: {
            args: Prisma.ArticleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ArticleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          update: {
            args: Prisma.ArticleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          deleteMany: {
            args: Prisma.ArticleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArticleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ArticleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          aggregate: {
            args: Prisma.ArticleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArticle>
          }
          groupBy: {
            args: Prisma.ArticleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArticleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArticleCountArgs<ExtArgs>
            result: $Utils.Optional<ArticleCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      UserNotification: {
        payload: Prisma.$UserNotificationPayload<ExtArgs>
        fields: Prisma.UserNotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserNotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserNotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationPayload>
          }
          findFirst: {
            args: Prisma.UserNotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserNotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationPayload>
          }
          findMany: {
            args: Prisma.UserNotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationPayload>[]
          }
          create: {
            args: Prisma.UserNotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationPayload>
          }
          createMany: {
            args: Prisma.UserNotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserNotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationPayload>
          }
          update: {
            args: Prisma.UserNotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationPayload>
          }
          deleteMany: {
            args: Prisma.UserNotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserNotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserNotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationPayload>
          }
          aggregate: {
            args: Prisma.UserNotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserNotification>
          }
          groupBy: {
            args: Prisma.UserNotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserNotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserNotificationCountArgs<ExtArgs>
            result: $Utils.Optional<UserNotificationCountAggregateOutputType> | number
          }
        }
      }
      PaymentConfig: {
        payload: Prisma.$PaymentConfigPayload<ExtArgs>
        fields: Prisma.PaymentConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentConfigPayload>
          }
          findFirst: {
            args: Prisma.PaymentConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentConfigPayload>
          }
          findMany: {
            args: Prisma.PaymentConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentConfigPayload>[]
          }
          create: {
            args: Prisma.PaymentConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentConfigPayload>
          }
          createMany: {
            args: Prisma.PaymentConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PaymentConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentConfigPayload>
          }
          update: {
            args: Prisma.PaymentConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentConfigPayload>
          }
          deleteMany: {
            args: Prisma.PaymentConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentConfigPayload>
          }
          aggregate: {
            args: Prisma.PaymentConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentConfig>
          }
          groupBy: {
            args: Prisma.PaymentConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentConfigCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentConfigCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      MembershipPlan: {
        payload: Prisma.$MembershipPlanPayload<ExtArgs>
        fields: Prisma.MembershipPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MembershipPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MembershipPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPlanPayload>
          }
          findFirst: {
            args: Prisma.MembershipPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MembershipPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPlanPayload>
          }
          findMany: {
            args: Prisma.MembershipPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPlanPayload>[]
          }
          create: {
            args: Prisma.MembershipPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPlanPayload>
          }
          createMany: {
            args: Prisma.MembershipPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MembershipPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPlanPayload>
          }
          update: {
            args: Prisma.MembershipPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPlanPayload>
          }
          deleteMany: {
            args: Prisma.MembershipPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MembershipPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MembershipPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPlanPayload>
          }
          aggregate: {
            args: Prisma.MembershipPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMembershipPlan>
          }
          groupBy: {
            args: Prisma.MembershipPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<MembershipPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.MembershipPlanCountArgs<ExtArgs>
            result: $Utils.Optional<MembershipPlanCountAggregateOutputType> | number
          }
        }
      }
      PointsConfig: {
        payload: Prisma.$PointsConfigPayload<ExtArgs>
        fields: Prisma.PointsConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PointsConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PointsConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsConfigPayload>
          }
          findFirst: {
            args: Prisma.PointsConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PointsConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsConfigPayload>
          }
          findMany: {
            args: Prisma.PointsConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsConfigPayload>[]
          }
          create: {
            args: Prisma.PointsConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsConfigPayload>
          }
          createMany: {
            args: Prisma.PointsConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PointsConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsConfigPayload>
          }
          update: {
            args: Prisma.PointsConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsConfigPayload>
          }
          deleteMany: {
            args: Prisma.PointsConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PointsConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PointsConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointsConfigPayload>
          }
          aggregate: {
            args: Prisma.PointsConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePointsConfig>
          }
          groupBy: {
            args: Prisma.PointsConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<PointsConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.PointsConfigCountArgs<ExtArgs>
            result: $Utils.Optional<PointsConfigCountAggregateOutputType> | number
          }
        }
      }
      PointRecord: {
        payload: Prisma.$PointRecordPayload<ExtArgs>
        fields: Prisma.PointRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PointRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PointRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointRecordPayload>
          }
          findFirst: {
            args: Prisma.PointRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PointRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointRecordPayload>
          }
          findMany: {
            args: Prisma.PointRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointRecordPayload>[]
          }
          create: {
            args: Prisma.PointRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointRecordPayload>
          }
          createMany: {
            args: Prisma.PointRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PointRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointRecordPayload>
          }
          update: {
            args: Prisma.PointRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointRecordPayload>
          }
          deleteMany: {
            args: Prisma.PointRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PointRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PointRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointRecordPayload>
          }
          aggregate: {
            args: Prisma.PointRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePointRecord>
          }
          groupBy: {
            args: Prisma.PointRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<PointRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.PointRecordCountArgs<ExtArgs>
            result: $Utils.Optional<PointRecordCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      UserRoleAssignment: {
        payload: Prisma.$UserRoleAssignmentPayload<ExtArgs>
        fields: Prisma.UserRoleAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoleAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoleAssignmentPayload>
          }
          findFirst: {
            args: Prisma.UserRoleAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoleAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoleAssignmentPayload>
          }
          findMany: {
            args: Prisma.UserRoleAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoleAssignmentPayload>[]
          }
          create: {
            args: Prisma.UserRoleAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoleAssignmentPayload>
          }
          createMany: {
            args: Prisma.UserRoleAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserRoleAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoleAssignmentPayload>
          }
          update: {
            args: Prisma.UserRoleAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoleAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.UserRoleAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserRoleAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRoleAssignmentPayload>
          }
          aggregate: {
            args: Prisma.UserRoleAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRoleAssignment>
          }
          groupBy: {
            args: Prisma.UserRoleAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRoleAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoleAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<UserRoleAssignmentCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      Language: {
        payload: Prisma.$LanguagePayload<ExtArgs>
        fields: Prisma.LanguageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LanguageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LanguageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          findFirst: {
            args: Prisma.LanguageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LanguageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          findMany: {
            args: Prisma.LanguageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          create: {
            args: Prisma.LanguageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          createMany: {
            args: Prisma.LanguageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LanguageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          update: {
            args: Prisma.LanguageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          deleteMany: {
            args: Prisma.LanguageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LanguageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LanguageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          aggregate: {
            args: Prisma.LanguageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLanguage>
          }
          groupBy: {
            args: Prisma.LanguageGroupByArgs<ExtArgs>
            result: $Utils.Optional<LanguageGroupByOutputType>[]
          }
          count: {
            args: Prisma.LanguageCountArgs<ExtArgs>
            result: $Utils.Optional<LanguageCountAggregateOutputType> | number
          }
        }
      }
      Translation: {
        payload: Prisma.$TranslationPayload<ExtArgs>
        fields: Prisma.TranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload>
          }
          findFirst: {
            args: Prisma.TranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload>
          }
          findMany: {
            args: Prisma.TranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload>[]
          }
          create: {
            args: Prisma.TranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload>
          }
          createMany: {
            args: Prisma.TranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload>
          }
          update: {
            args: Prisma.TranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload>
          }
          deleteMany: {
            args: Prisma.TranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload>
          }
          aggregate: {
            args: Prisma.TranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTranslation>
          }
          groupBy: {
            args: Prisma.TranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<TranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.TranslationCountArgs<ExtArgs>
            result: $Utils.Optional<TranslationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
    scenarios: number
    emails: number
    personaTemplates: number
    operationLogs: number
    oauthAccounts: number
    orders: number
    pointRecords: number
    notifications: number
    articles: number
    media: number
    roleAssignments: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    scenarios?: boolean | UserCountOutputTypeCountScenariosArgs
    emails?: boolean | UserCountOutputTypeCountEmailsArgs
    personaTemplates?: boolean | UserCountOutputTypeCountPersonaTemplatesArgs
    operationLogs?: boolean | UserCountOutputTypeCountOperationLogsArgs
    oauthAccounts?: boolean | UserCountOutputTypeCountOauthAccountsArgs
    orders?: boolean | UserCountOutputTypeCountOrdersArgs
    pointRecords?: boolean | UserCountOutputTypeCountPointRecordsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    articles?: boolean | UserCountOutputTypeCountArticlesArgs
    media?: boolean | UserCountOutputTypeCountMediaArgs
    roleAssignments?: boolean | UserCountOutputTypeCountRoleAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountScenariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScenarioWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowUpEmailWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPersonaTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuyerPersonaTemplateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOperationLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperationLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOauthAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OAuthAccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPointRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PointRecordWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserNotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountArticlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArticleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRoleAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleAssignmentWhereInput
  }


  /**
   * Count Type ScenarioCountOutputType
   */

  export type ScenarioCountOutputType = {
    sessions: number
  }

  export type ScenarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | ScenarioCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * ScenarioCountOutputType without action
   */
  export type ScenarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScenarioCountOutputType
     */
    select?: ScenarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ScenarioCountOutputType without action
   */
  export type ScenarioCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }


  /**
   * Count Type SessionCountOutputType
   */

  export type SessionCountOutputType = {
    messages: number
  }

  export type SessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | SessionCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionCountOutputType
     */
    select?: SessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type PluginCountOutputType
   */

  export type PluginCountOutputType = {
    installations: number
  }

  export type PluginCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    installations?: boolean | PluginCountOutputTypeCountInstallationsArgs
  }

  // Custom InputTypes
  /**
   * PluginCountOutputType without action
   */
  export type PluginCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginCountOutputType
     */
    select?: PluginCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PluginCountOutputType without action
   */
  export type PluginCountOutputTypeCountInstallationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PluginInstallationWhereInput
  }


  /**
   * Count Type ArticleCategoryCountOutputType
   */

  export type ArticleCategoryCountOutputType = {
    children: number
    articles: number
  }

  export type ArticleCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | ArticleCategoryCountOutputTypeCountChildrenArgs
    articles?: boolean | ArticleCategoryCountOutputTypeCountArticlesArgs
  }

  // Custom InputTypes
  /**
   * ArticleCategoryCountOutputType without action
   */
  export type ArticleCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleCategoryCountOutputType
     */
    select?: ArticleCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ArticleCategoryCountOutputType without action
   */
  export type ArticleCategoryCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArticleCategoryWhereInput
  }

  /**
   * ArticleCategoryCountOutputType without action
   */
  export type ArticleCategoryCountOutputTypeCountArticlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArticleWhereInput
  }


  /**
   * Count Type NotificationCountOutputType
   */

  export type NotificationCountOutputType = {
    userNotifications: number
  }

  export type NotificationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userNotifications?: boolean | NotificationCountOutputTypeCountUserNotificationsArgs
  }

  // Custom InputTypes
  /**
   * NotificationCountOutputType without action
   */
  export type NotificationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationCountOutputType
     */
    select?: NotificationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NotificationCountOutputType without action
   */
  export type NotificationCountOutputTypeCountUserNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserNotificationWhereInput
  }


  /**
   * Count Type MembershipPlanCountOutputType
   */

  export type MembershipPlanCountOutputType = {
    users: number
  }

  export type MembershipPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | MembershipPlanCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * MembershipPlanCountOutputType without action
   */
  export type MembershipPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlanCountOutputType
     */
    select?: MembershipPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MembershipPlanCountOutputType without action
   */
  export type MembershipPlanCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    userAssignments: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userAssignments?: boolean | RoleCountOutputTypeCountUserAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUserAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleAssignmentWhereInput
  }


  /**
   * Count Type LanguageCountOutputType
   */

  export type LanguageCountOutputType = {
    translations: number
  }

  export type LanguageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translations?: boolean | LanguageCountOutputTypeCountTranslationsArgs
  }

  // Custom InputTypes
  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageCountOutputType
     */
    select?: LanguageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TranslationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    points: number | null
  }

  export type UserSumAggregateOutputType = {
    points: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    avatar: string | null
    phone: string | null
    role: $Enums.UserRole | null
    department: string | null
    isActive: boolean | null
    language: string | null
    membershipId: string | null
    membershipExpireAt: Date | null
    points: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    avatar: string | null
    phone: string | null
    role: $Enums.UserRole | null
    department: string | null
    isActive: boolean | null
    language: string | null
    membershipId: string | null
    membershipExpireAt: Date | null
    points: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    avatar: number
    phone: number
    role: number
    department: number
    isActive: number
    language: number
    membershipId: number
    membershipExpireAt: number
    points: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    points?: true
  }

  export type UserSumAggregateInputType = {
    points?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    avatar?: true
    phone?: true
    role?: true
    department?: true
    isActive?: true
    language?: true
    membershipId?: true
    membershipExpireAt?: true
    points?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    avatar?: true
    phone?: true
    role?: true
    department?: true
    isActive?: true
    language?: true
    membershipId?: true
    membershipExpireAt?: true
    points?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    avatar?: true
    phone?: true
    role?: true
    department?: true
    isActive?: true
    language?: true
    membershipId?: true
    membershipExpireAt?: true
    points?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string | null
    password: string | null
    name: string
    avatar: string | null
    phone: string | null
    role: $Enums.UserRole
    department: string | null
    isActive: boolean
    language: string
    membershipId: string | null
    membershipExpireAt: Date | null
    points: number
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    avatar?: boolean
    phone?: boolean
    role?: boolean
    department?: boolean
    isActive?: boolean
    language?: boolean
    membershipId?: boolean
    membershipExpireAt?: boolean
    points?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    membership?: boolean | User$membershipArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    scenarios?: boolean | User$scenariosArgs<ExtArgs>
    emails?: boolean | User$emailsArgs<ExtArgs>
    personaTemplates?: boolean | User$personaTemplatesArgs<ExtArgs>
    operationLogs?: boolean | User$operationLogsArgs<ExtArgs>
    oauthAccounts?: boolean | User$oauthAccountsArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    pointRecords?: boolean | User$pointRecordsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    articles?: boolean | User$articlesArgs<ExtArgs>
    media?: boolean | User$mediaArgs<ExtArgs>
    roleAssignments?: boolean | User$roleAssignmentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>


  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    avatar?: boolean
    phone?: boolean
    role?: boolean
    department?: boolean
    isActive?: boolean
    language?: boolean
    membershipId?: boolean
    membershipExpireAt?: boolean
    points?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    membership?: boolean | User$membershipArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    scenarios?: boolean | User$scenariosArgs<ExtArgs>
    emails?: boolean | User$emailsArgs<ExtArgs>
    personaTemplates?: boolean | User$personaTemplatesArgs<ExtArgs>
    operationLogs?: boolean | User$operationLogsArgs<ExtArgs>
    oauthAccounts?: boolean | User$oauthAccountsArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    pointRecords?: boolean | User$pointRecordsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    articles?: boolean | User$articlesArgs<ExtArgs>
    media?: boolean | User$mediaArgs<ExtArgs>
    roleAssignments?: boolean | User$roleAssignmentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      membership: Prisma.$MembershipPlanPayload<ExtArgs> | null
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      scenarios: Prisma.$ScenarioPayload<ExtArgs>[]
      emails: Prisma.$FollowUpEmailPayload<ExtArgs>[]
      personaTemplates: Prisma.$BuyerPersonaTemplatePayload<ExtArgs>[]
      operationLogs: Prisma.$OperationLogPayload<ExtArgs>[]
      oauthAccounts: Prisma.$OAuthAccountPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      pointRecords: Prisma.$PointRecordPayload<ExtArgs>[]
      notifications: Prisma.$UserNotificationPayload<ExtArgs>[]
      articles: Prisma.$ArticlePayload<ExtArgs>[]
      media: Prisma.$MediaPayload<ExtArgs>[]
      roleAssignments: Prisma.$UserRoleAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string | null
      password: string | null
      name: string
      avatar: string | null
      phone: string | null
      role: $Enums.UserRole
      department: string | null
      isActive: boolean
      language: string
      membershipId: string | null
      membershipExpireAt: Date | null
      points: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    membership<T extends User$membershipArgs<ExtArgs> = {}>(args?: Subset<T, User$membershipArgs<ExtArgs>>): Prisma__MembershipPlanClient<$Result.GetResult<Prisma.$MembershipPlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    scenarios<T extends User$scenariosArgs<ExtArgs> = {}>(args?: Subset<T, User$scenariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findMany"> | Null>
    emails<T extends User$emailsArgs<ExtArgs> = {}>(args?: Subset<T, User$emailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowUpEmailPayload<ExtArgs>, T, "findMany"> | Null>
    personaTemplates<T extends User$personaTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, User$personaTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuyerPersonaTemplatePayload<ExtArgs>, T, "findMany"> | Null>
    operationLogs<T extends User$operationLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$operationLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationLogPayload<ExtArgs>, T, "findMany"> | Null>
    oauthAccounts<T extends User$oauthAccountsArgs<ExtArgs> = {}>(args?: Subset<T, User$oauthAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OAuthAccountPayload<ExtArgs>, T, "findMany"> | Null>
    orders<T extends User$ordersArgs<ExtArgs> = {}>(args?: Subset<T, User$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany"> | Null>
    pointRecords<T extends User$pointRecordsArgs<ExtArgs> = {}>(args?: Subset<T, User$pointRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointRecordPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserNotificationPayload<ExtArgs>, T, "findMany"> | Null>
    articles<T extends User$articlesArgs<ExtArgs> = {}>(args?: Subset<T, User$articlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "findMany"> | Null>
    media<T extends User$mediaArgs<ExtArgs> = {}>(args?: Subset<T, User$mediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany"> | Null>
    roleAssignments<T extends User$roleAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$roleAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRoleAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly department: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly language: FieldRef<"User", 'String'>
    readonly membershipId: FieldRef<"User", 'String'>
    readonly membershipExpireAt: FieldRef<"User", 'DateTime'>
    readonly points: FieldRef<"User", 'Int'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.membership
   */
  export type User$membershipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlan
     */
    select?: MembershipPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipPlanInclude<ExtArgs> | null
    where?: MembershipPlanWhereInput
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.scenarios
   */
  export type User$scenariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    where?: ScenarioWhereInput
    orderBy?: ScenarioOrderByWithRelationInput | ScenarioOrderByWithRelationInput[]
    cursor?: ScenarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScenarioScalarFieldEnum | ScenarioScalarFieldEnum[]
  }

  /**
   * User.emails
   */
  export type User$emailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUpEmail
     */
    select?: FollowUpEmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpEmailInclude<ExtArgs> | null
    where?: FollowUpEmailWhereInput
    orderBy?: FollowUpEmailOrderByWithRelationInput | FollowUpEmailOrderByWithRelationInput[]
    cursor?: FollowUpEmailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowUpEmailScalarFieldEnum | FollowUpEmailScalarFieldEnum[]
  }

  /**
   * User.personaTemplates
   */
  export type User$personaTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuyerPersonaTemplate
     */
    select?: BuyerPersonaTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuyerPersonaTemplateInclude<ExtArgs> | null
    where?: BuyerPersonaTemplateWhereInput
    orderBy?: BuyerPersonaTemplateOrderByWithRelationInput | BuyerPersonaTemplateOrderByWithRelationInput[]
    cursor?: BuyerPersonaTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuyerPersonaTemplateScalarFieldEnum | BuyerPersonaTemplateScalarFieldEnum[]
  }

  /**
   * User.operationLogs
   */
  export type User$operationLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationLog
     */
    select?: OperationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationLogInclude<ExtArgs> | null
    where?: OperationLogWhereInput
    orderBy?: OperationLogOrderByWithRelationInput | OperationLogOrderByWithRelationInput[]
    cursor?: OperationLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OperationLogScalarFieldEnum | OperationLogScalarFieldEnum[]
  }

  /**
   * User.oauthAccounts
   */
  export type User$oauthAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAccount
     */
    select?: OAuthAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAccountInclude<ExtArgs> | null
    where?: OAuthAccountWhereInput
    orderBy?: OAuthAccountOrderByWithRelationInput | OAuthAccountOrderByWithRelationInput[]
    cursor?: OAuthAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OAuthAccountScalarFieldEnum | OAuthAccountScalarFieldEnum[]
  }

  /**
   * User.orders
   */
  export type User$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.pointRecords
   */
  export type User$pointRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointRecord
     */
    select?: PointRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointRecordInclude<ExtArgs> | null
    where?: PointRecordWhereInput
    orderBy?: PointRecordOrderByWithRelationInput | PointRecordOrderByWithRelationInput[]
    cursor?: PointRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PointRecordScalarFieldEnum | PointRecordScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotification
     */
    select?: UserNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationInclude<ExtArgs> | null
    where?: UserNotificationWhereInput
    orderBy?: UserNotificationOrderByWithRelationInput | UserNotificationOrderByWithRelationInput[]
    cursor?: UserNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserNotificationScalarFieldEnum | UserNotificationScalarFieldEnum[]
  }

  /**
   * User.articles
   */
  export type User$articlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    where?: ArticleWhereInput
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    cursor?: ArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }

  /**
   * User.media
   */
  export type User$mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    cursor?: MediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * User.roleAssignments
   */
  export type User$roleAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleAssignment
     */
    select?: UserRoleAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleAssignmentInclude<ExtArgs> | null
    where?: UserRoleAssignmentWhereInput
    orderBy?: UserRoleAssignmentOrderByWithRelationInput | UserRoleAssignmentOrderByWithRelationInput[]
    cursor?: UserRoleAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleAssignmentScalarFieldEnum | UserRoleAssignmentScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model OAuthAccount
   */

  export type AggregateOAuthAccount = {
    _count: OAuthAccountCountAggregateOutputType | null
    _min: OAuthAccountMinAggregateOutputType | null
    _max: OAuthAccountMaxAggregateOutputType | null
  }

  export type OAuthAccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    provider: $Enums.OAuthProvider | null
    providerId: string | null
    accessToken: string | null
    refreshToken: string | null
    tokenExpireAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OAuthAccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    provider: $Enums.OAuthProvider | null
    providerId: string | null
    accessToken: string | null
    refreshToken: string | null
    tokenExpireAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OAuthAccountCountAggregateOutputType = {
    id: number
    userId: number
    provider: number
    providerId: number
    accessToken: number
    refreshToken: number
    tokenExpireAt: number
    profile: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OAuthAccountMinAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    tokenExpireAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OAuthAccountMaxAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    tokenExpireAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OAuthAccountCountAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    tokenExpireAt?: true
    profile?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OAuthAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OAuthAccount to aggregate.
     */
    where?: OAuthAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthAccounts to fetch.
     */
    orderBy?: OAuthAccountOrderByWithRelationInput | OAuthAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OAuthAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OAuthAccounts
    **/
    _count?: true | OAuthAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OAuthAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OAuthAccountMaxAggregateInputType
  }

  export type GetOAuthAccountAggregateType<T extends OAuthAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateOAuthAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOAuthAccount[P]>
      : GetScalarType<T[P], AggregateOAuthAccount[P]>
  }




  export type OAuthAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OAuthAccountWhereInput
    orderBy?: OAuthAccountOrderByWithAggregationInput | OAuthAccountOrderByWithAggregationInput[]
    by: OAuthAccountScalarFieldEnum[] | OAuthAccountScalarFieldEnum
    having?: OAuthAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OAuthAccountCountAggregateInputType | true
    _min?: OAuthAccountMinAggregateInputType
    _max?: OAuthAccountMaxAggregateInputType
  }

  export type OAuthAccountGroupByOutputType = {
    id: string
    userId: string
    provider: $Enums.OAuthProvider
    providerId: string
    accessToken: string | null
    refreshToken: string | null
    tokenExpireAt: Date | null
    profile: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: OAuthAccountCountAggregateOutputType | null
    _min: OAuthAccountMinAggregateOutputType | null
    _max: OAuthAccountMaxAggregateOutputType | null
  }

  type GetOAuthAccountGroupByPayload<T extends OAuthAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OAuthAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OAuthAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OAuthAccountGroupByOutputType[P]>
            : GetScalarType<T[P], OAuthAccountGroupByOutputType[P]>
        }
      >
    >


  export type OAuthAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    tokenExpireAt?: boolean
    profile?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oAuthAccount"]>


  export type OAuthAccountSelectScalar = {
    id?: boolean
    userId?: boolean
    provider?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    tokenExpireAt?: boolean
    profile?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OAuthAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OAuthAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OAuthAccount"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      provider: $Enums.OAuthProvider
      providerId: string
      accessToken: string | null
      refreshToken: string | null
      tokenExpireAt: Date | null
      profile: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["oAuthAccount"]>
    composites: {}
  }

  type OAuthAccountGetPayload<S extends boolean | null | undefined | OAuthAccountDefaultArgs> = $Result.GetResult<Prisma.$OAuthAccountPayload, S>

  type OAuthAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OAuthAccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OAuthAccountCountAggregateInputType | true
    }

  export interface OAuthAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OAuthAccount'], meta: { name: 'OAuthAccount' } }
    /**
     * Find zero or one OAuthAccount that matches the filter.
     * @param {OAuthAccountFindUniqueArgs} args - Arguments to find a OAuthAccount
     * @example
     * // Get one OAuthAccount
     * const oAuthAccount = await prisma.oAuthAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OAuthAccountFindUniqueArgs>(args: SelectSubset<T, OAuthAccountFindUniqueArgs<ExtArgs>>): Prisma__OAuthAccountClient<$Result.GetResult<Prisma.$OAuthAccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OAuthAccount that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OAuthAccountFindUniqueOrThrowArgs} args - Arguments to find a OAuthAccount
     * @example
     * // Get one OAuthAccount
     * const oAuthAccount = await prisma.oAuthAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OAuthAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, OAuthAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OAuthAccountClient<$Result.GetResult<Prisma.$OAuthAccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OAuthAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAccountFindFirstArgs} args - Arguments to find a OAuthAccount
     * @example
     * // Get one OAuthAccount
     * const oAuthAccount = await prisma.oAuthAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OAuthAccountFindFirstArgs>(args?: SelectSubset<T, OAuthAccountFindFirstArgs<ExtArgs>>): Prisma__OAuthAccountClient<$Result.GetResult<Prisma.$OAuthAccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OAuthAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAccountFindFirstOrThrowArgs} args - Arguments to find a OAuthAccount
     * @example
     * // Get one OAuthAccount
     * const oAuthAccount = await prisma.oAuthAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OAuthAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, OAuthAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__OAuthAccountClient<$Result.GetResult<Prisma.$OAuthAccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OAuthAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OAuthAccounts
     * const oAuthAccounts = await prisma.oAuthAccount.findMany()
     * 
     * // Get first 10 OAuthAccounts
     * const oAuthAccounts = await prisma.oAuthAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oAuthAccountWithIdOnly = await prisma.oAuthAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OAuthAccountFindManyArgs>(args?: SelectSubset<T, OAuthAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OAuthAccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OAuthAccount.
     * @param {OAuthAccountCreateArgs} args - Arguments to create a OAuthAccount.
     * @example
     * // Create one OAuthAccount
     * const OAuthAccount = await prisma.oAuthAccount.create({
     *   data: {
     *     // ... data to create a OAuthAccount
     *   }
     * })
     * 
     */
    create<T extends OAuthAccountCreateArgs>(args: SelectSubset<T, OAuthAccountCreateArgs<ExtArgs>>): Prisma__OAuthAccountClient<$Result.GetResult<Prisma.$OAuthAccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OAuthAccounts.
     * @param {OAuthAccountCreateManyArgs} args - Arguments to create many OAuthAccounts.
     * @example
     * // Create many OAuthAccounts
     * const oAuthAccount = await prisma.oAuthAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OAuthAccountCreateManyArgs>(args?: SelectSubset<T, OAuthAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OAuthAccount.
     * @param {OAuthAccountDeleteArgs} args - Arguments to delete one OAuthAccount.
     * @example
     * // Delete one OAuthAccount
     * const OAuthAccount = await prisma.oAuthAccount.delete({
     *   where: {
     *     // ... filter to delete one OAuthAccount
     *   }
     * })
     * 
     */
    delete<T extends OAuthAccountDeleteArgs>(args: SelectSubset<T, OAuthAccountDeleteArgs<ExtArgs>>): Prisma__OAuthAccountClient<$Result.GetResult<Prisma.$OAuthAccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OAuthAccount.
     * @param {OAuthAccountUpdateArgs} args - Arguments to update one OAuthAccount.
     * @example
     * // Update one OAuthAccount
     * const oAuthAccount = await prisma.oAuthAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OAuthAccountUpdateArgs>(args: SelectSubset<T, OAuthAccountUpdateArgs<ExtArgs>>): Prisma__OAuthAccountClient<$Result.GetResult<Prisma.$OAuthAccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OAuthAccounts.
     * @param {OAuthAccountDeleteManyArgs} args - Arguments to filter OAuthAccounts to delete.
     * @example
     * // Delete a few OAuthAccounts
     * const { count } = await prisma.oAuthAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OAuthAccountDeleteManyArgs>(args?: SelectSubset<T, OAuthAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OAuthAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OAuthAccounts
     * const oAuthAccount = await prisma.oAuthAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OAuthAccountUpdateManyArgs>(args: SelectSubset<T, OAuthAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OAuthAccount.
     * @param {OAuthAccountUpsertArgs} args - Arguments to update or create a OAuthAccount.
     * @example
     * // Update or create a OAuthAccount
     * const oAuthAccount = await prisma.oAuthAccount.upsert({
     *   create: {
     *     // ... data to create a OAuthAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OAuthAccount we want to update
     *   }
     * })
     */
    upsert<T extends OAuthAccountUpsertArgs>(args: SelectSubset<T, OAuthAccountUpsertArgs<ExtArgs>>): Prisma__OAuthAccountClient<$Result.GetResult<Prisma.$OAuthAccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OAuthAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAccountCountArgs} args - Arguments to filter OAuthAccounts to count.
     * @example
     * // Count the number of OAuthAccounts
     * const count = await prisma.oAuthAccount.count({
     *   where: {
     *     // ... the filter for the OAuthAccounts we want to count
     *   }
     * })
    **/
    count<T extends OAuthAccountCountArgs>(
      args?: Subset<T, OAuthAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OAuthAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OAuthAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OAuthAccountAggregateArgs>(args: Subset<T, OAuthAccountAggregateArgs>): Prisma.PrismaPromise<GetOAuthAccountAggregateType<T>>

    /**
     * Group by OAuthAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OAuthAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OAuthAccountGroupByArgs['orderBy'] }
        : { orderBy?: OAuthAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OAuthAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOAuthAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OAuthAccount model
   */
  readonly fields: OAuthAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OAuthAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OAuthAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OAuthAccount model
   */ 
  interface OAuthAccountFieldRefs {
    readonly id: FieldRef<"OAuthAccount", 'String'>
    readonly userId: FieldRef<"OAuthAccount", 'String'>
    readonly provider: FieldRef<"OAuthAccount", 'OAuthProvider'>
    readonly providerId: FieldRef<"OAuthAccount", 'String'>
    readonly accessToken: FieldRef<"OAuthAccount", 'String'>
    readonly refreshToken: FieldRef<"OAuthAccount", 'String'>
    readonly tokenExpireAt: FieldRef<"OAuthAccount", 'DateTime'>
    readonly profile: FieldRef<"OAuthAccount", 'Json'>
    readonly createdAt: FieldRef<"OAuthAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"OAuthAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OAuthAccount findUnique
   */
  export type OAuthAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAccount
     */
    select?: OAuthAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAccountInclude<ExtArgs> | null
    /**
     * Filter, which OAuthAccount to fetch.
     */
    where: OAuthAccountWhereUniqueInput
  }

  /**
   * OAuthAccount findUniqueOrThrow
   */
  export type OAuthAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAccount
     */
    select?: OAuthAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAccountInclude<ExtArgs> | null
    /**
     * Filter, which OAuthAccount to fetch.
     */
    where: OAuthAccountWhereUniqueInput
  }

  /**
   * OAuthAccount findFirst
   */
  export type OAuthAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAccount
     */
    select?: OAuthAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAccountInclude<ExtArgs> | null
    /**
     * Filter, which OAuthAccount to fetch.
     */
    where?: OAuthAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthAccounts to fetch.
     */
    orderBy?: OAuthAccountOrderByWithRelationInput | OAuthAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OAuthAccounts.
     */
    cursor?: OAuthAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OAuthAccounts.
     */
    distinct?: OAuthAccountScalarFieldEnum | OAuthAccountScalarFieldEnum[]
  }

  /**
   * OAuthAccount findFirstOrThrow
   */
  export type OAuthAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAccount
     */
    select?: OAuthAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAccountInclude<ExtArgs> | null
    /**
     * Filter, which OAuthAccount to fetch.
     */
    where?: OAuthAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthAccounts to fetch.
     */
    orderBy?: OAuthAccountOrderByWithRelationInput | OAuthAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OAuthAccounts.
     */
    cursor?: OAuthAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OAuthAccounts.
     */
    distinct?: OAuthAccountScalarFieldEnum | OAuthAccountScalarFieldEnum[]
  }

  /**
   * OAuthAccount findMany
   */
  export type OAuthAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAccount
     */
    select?: OAuthAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAccountInclude<ExtArgs> | null
    /**
     * Filter, which OAuthAccounts to fetch.
     */
    where?: OAuthAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthAccounts to fetch.
     */
    orderBy?: OAuthAccountOrderByWithRelationInput | OAuthAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OAuthAccounts.
     */
    cursor?: OAuthAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthAccounts.
     */
    skip?: number
    distinct?: OAuthAccountScalarFieldEnum | OAuthAccountScalarFieldEnum[]
  }

  /**
   * OAuthAccount create
   */
  export type OAuthAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAccount
     */
    select?: OAuthAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a OAuthAccount.
     */
    data: XOR<OAuthAccountCreateInput, OAuthAccountUncheckedCreateInput>
  }

  /**
   * OAuthAccount createMany
   */
  export type OAuthAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OAuthAccounts.
     */
    data: OAuthAccountCreateManyInput | OAuthAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OAuthAccount update
   */
  export type OAuthAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAccount
     */
    select?: OAuthAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a OAuthAccount.
     */
    data: XOR<OAuthAccountUpdateInput, OAuthAccountUncheckedUpdateInput>
    /**
     * Choose, which OAuthAccount to update.
     */
    where: OAuthAccountWhereUniqueInput
  }

  /**
   * OAuthAccount updateMany
   */
  export type OAuthAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OAuthAccounts.
     */
    data: XOR<OAuthAccountUpdateManyMutationInput, OAuthAccountUncheckedUpdateManyInput>
    /**
     * Filter which OAuthAccounts to update
     */
    where?: OAuthAccountWhereInput
  }

  /**
   * OAuthAccount upsert
   */
  export type OAuthAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAccount
     */
    select?: OAuthAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the OAuthAccount to update in case it exists.
     */
    where: OAuthAccountWhereUniqueInput
    /**
     * In case the OAuthAccount found by the `where` argument doesn't exist, create a new OAuthAccount with this data.
     */
    create: XOR<OAuthAccountCreateInput, OAuthAccountUncheckedCreateInput>
    /**
     * In case the OAuthAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OAuthAccountUpdateInput, OAuthAccountUncheckedUpdateInput>
  }

  /**
   * OAuthAccount delete
   */
  export type OAuthAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAccount
     */
    select?: OAuthAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAccountInclude<ExtArgs> | null
    /**
     * Filter which OAuthAccount to delete.
     */
    where: OAuthAccountWhereUniqueInput
  }

  /**
   * OAuthAccount deleteMany
   */
  export type OAuthAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OAuthAccounts to delete
     */
    where?: OAuthAccountWhereInput
  }

  /**
   * OAuthAccount without action
   */
  export type OAuthAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAccount
     */
    select?: OAuthAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OAuthAccountInclude<ExtArgs> | null
  }


  /**
   * Model LoginConfig
   */

  export type AggregateLoginConfig = {
    _count: LoginConfigCountAggregateOutputType | null
    _avg: LoginConfigAvgAggregateOutputType | null
    _sum: LoginConfigSumAggregateOutputType | null
    _min: LoginConfigMinAggregateOutputType | null
    _max: LoginConfigMaxAggregateOutputType | null
  }

  export type LoginConfigAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type LoginConfigSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type LoginConfigMinAggregateOutputType = {
    id: string | null
    provider: $Enums.OAuthProvider | null
    name: string | null
    isEnabled: boolean | null
    appId: string | null
    appSecret: string | null
    redirectUri: string | null
    scope: string | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoginConfigMaxAggregateOutputType = {
    id: string | null
    provider: $Enums.OAuthProvider | null
    name: string | null
    isEnabled: boolean | null
    appId: string | null
    appSecret: string | null
    redirectUri: string | null
    scope: string | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoginConfigCountAggregateOutputType = {
    id: number
    provider: number
    name: number
    isEnabled: number
    appId: number
    appSecret: number
    redirectUri: number
    scope: number
    config: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LoginConfigAvgAggregateInputType = {
    sortOrder?: true
  }

  export type LoginConfigSumAggregateInputType = {
    sortOrder?: true
  }

  export type LoginConfigMinAggregateInputType = {
    id?: true
    provider?: true
    name?: true
    isEnabled?: true
    appId?: true
    appSecret?: true
    redirectUri?: true
    scope?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoginConfigMaxAggregateInputType = {
    id?: true
    provider?: true
    name?: true
    isEnabled?: true
    appId?: true
    appSecret?: true
    redirectUri?: true
    scope?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoginConfigCountAggregateInputType = {
    id?: true
    provider?: true
    name?: true
    isEnabled?: true
    appId?: true
    appSecret?: true
    redirectUri?: true
    scope?: true
    config?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LoginConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoginConfig to aggregate.
     */
    where?: LoginConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoginConfigs to fetch.
     */
    orderBy?: LoginConfigOrderByWithRelationInput | LoginConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoginConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoginConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoginConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LoginConfigs
    **/
    _count?: true | LoginConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoginConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoginConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoginConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoginConfigMaxAggregateInputType
  }

  export type GetLoginConfigAggregateType<T extends LoginConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateLoginConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoginConfig[P]>
      : GetScalarType<T[P], AggregateLoginConfig[P]>
  }




  export type LoginConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoginConfigWhereInput
    orderBy?: LoginConfigOrderByWithAggregationInput | LoginConfigOrderByWithAggregationInput[]
    by: LoginConfigScalarFieldEnum[] | LoginConfigScalarFieldEnum
    having?: LoginConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoginConfigCountAggregateInputType | true
    _avg?: LoginConfigAvgAggregateInputType
    _sum?: LoginConfigSumAggregateInputType
    _min?: LoginConfigMinAggregateInputType
    _max?: LoginConfigMaxAggregateInputType
  }

  export type LoginConfigGroupByOutputType = {
    id: string
    provider: $Enums.OAuthProvider
    name: string
    isEnabled: boolean
    appId: string | null
    appSecret: string | null
    redirectUri: string | null
    scope: string | null
    config: JsonValue | null
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: LoginConfigCountAggregateOutputType | null
    _avg: LoginConfigAvgAggregateOutputType | null
    _sum: LoginConfigSumAggregateOutputType | null
    _min: LoginConfigMinAggregateOutputType | null
    _max: LoginConfigMaxAggregateOutputType | null
  }

  type GetLoginConfigGroupByPayload<T extends LoginConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoginConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoginConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoginConfigGroupByOutputType[P]>
            : GetScalarType<T[P], LoginConfigGroupByOutputType[P]>
        }
      >
    >


  export type LoginConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    name?: boolean
    isEnabled?: boolean
    appId?: boolean
    appSecret?: boolean
    redirectUri?: boolean
    scope?: boolean
    config?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["loginConfig"]>


  export type LoginConfigSelectScalar = {
    id?: boolean
    provider?: boolean
    name?: boolean
    isEnabled?: boolean
    appId?: boolean
    appSecret?: boolean
    redirectUri?: boolean
    scope?: boolean
    config?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $LoginConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LoginConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      provider: $Enums.OAuthProvider
      name: string
      isEnabled: boolean
      appId: string | null
      appSecret: string | null
      redirectUri: string | null
      scope: string | null
      config: Prisma.JsonValue | null
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["loginConfig"]>
    composites: {}
  }

  type LoginConfigGetPayload<S extends boolean | null | undefined | LoginConfigDefaultArgs> = $Result.GetResult<Prisma.$LoginConfigPayload, S>

  type LoginConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LoginConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LoginConfigCountAggregateInputType | true
    }

  export interface LoginConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LoginConfig'], meta: { name: 'LoginConfig' } }
    /**
     * Find zero or one LoginConfig that matches the filter.
     * @param {LoginConfigFindUniqueArgs} args - Arguments to find a LoginConfig
     * @example
     * // Get one LoginConfig
     * const loginConfig = await prisma.loginConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoginConfigFindUniqueArgs>(args: SelectSubset<T, LoginConfigFindUniqueArgs<ExtArgs>>): Prisma__LoginConfigClient<$Result.GetResult<Prisma.$LoginConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LoginConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LoginConfigFindUniqueOrThrowArgs} args - Arguments to find a LoginConfig
     * @example
     * // Get one LoginConfig
     * const loginConfig = await prisma.loginConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoginConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, LoginConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoginConfigClient<$Result.GetResult<Prisma.$LoginConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LoginConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginConfigFindFirstArgs} args - Arguments to find a LoginConfig
     * @example
     * // Get one LoginConfig
     * const loginConfig = await prisma.loginConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoginConfigFindFirstArgs>(args?: SelectSubset<T, LoginConfigFindFirstArgs<ExtArgs>>): Prisma__LoginConfigClient<$Result.GetResult<Prisma.$LoginConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LoginConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginConfigFindFirstOrThrowArgs} args - Arguments to find a LoginConfig
     * @example
     * // Get one LoginConfig
     * const loginConfig = await prisma.loginConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoginConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, LoginConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoginConfigClient<$Result.GetResult<Prisma.$LoginConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LoginConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LoginConfigs
     * const loginConfigs = await prisma.loginConfig.findMany()
     * 
     * // Get first 10 LoginConfigs
     * const loginConfigs = await prisma.loginConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loginConfigWithIdOnly = await prisma.loginConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LoginConfigFindManyArgs>(args?: SelectSubset<T, LoginConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoginConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LoginConfig.
     * @param {LoginConfigCreateArgs} args - Arguments to create a LoginConfig.
     * @example
     * // Create one LoginConfig
     * const LoginConfig = await prisma.loginConfig.create({
     *   data: {
     *     // ... data to create a LoginConfig
     *   }
     * })
     * 
     */
    create<T extends LoginConfigCreateArgs>(args: SelectSubset<T, LoginConfigCreateArgs<ExtArgs>>): Prisma__LoginConfigClient<$Result.GetResult<Prisma.$LoginConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LoginConfigs.
     * @param {LoginConfigCreateManyArgs} args - Arguments to create many LoginConfigs.
     * @example
     * // Create many LoginConfigs
     * const loginConfig = await prisma.loginConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoginConfigCreateManyArgs>(args?: SelectSubset<T, LoginConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LoginConfig.
     * @param {LoginConfigDeleteArgs} args - Arguments to delete one LoginConfig.
     * @example
     * // Delete one LoginConfig
     * const LoginConfig = await prisma.loginConfig.delete({
     *   where: {
     *     // ... filter to delete one LoginConfig
     *   }
     * })
     * 
     */
    delete<T extends LoginConfigDeleteArgs>(args: SelectSubset<T, LoginConfigDeleteArgs<ExtArgs>>): Prisma__LoginConfigClient<$Result.GetResult<Prisma.$LoginConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LoginConfig.
     * @param {LoginConfigUpdateArgs} args - Arguments to update one LoginConfig.
     * @example
     * // Update one LoginConfig
     * const loginConfig = await prisma.loginConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoginConfigUpdateArgs>(args: SelectSubset<T, LoginConfigUpdateArgs<ExtArgs>>): Prisma__LoginConfigClient<$Result.GetResult<Prisma.$LoginConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LoginConfigs.
     * @param {LoginConfigDeleteManyArgs} args - Arguments to filter LoginConfigs to delete.
     * @example
     * // Delete a few LoginConfigs
     * const { count } = await prisma.loginConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoginConfigDeleteManyArgs>(args?: SelectSubset<T, LoginConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoginConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LoginConfigs
     * const loginConfig = await prisma.loginConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoginConfigUpdateManyArgs>(args: SelectSubset<T, LoginConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LoginConfig.
     * @param {LoginConfigUpsertArgs} args - Arguments to update or create a LoginConfig.
     * @example
     * // Update or create a LoginConfig
     * const loginConfig = await prisma.loginConfig.upsert({
     *   create: {
     *     // ... data to create a LoginConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LoginConfig we want to update
     *   }
     * })
     */
    upsert<T extends LoginConfigUpsertArgs>(args: SelectSubset<T, LoginConfigUpsertArgs<ExtArgs>>): Prisma__LoginConfigClient<$Result.GetResult<Prisma.$LoginConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LoginConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginConfigCountArgs} args - Arguments to filter LoginConfigs to count.
     * @example
     * // Count the number of LoginConfigs
     * const count = await prisma.loginConfig.count({
     *   where: {
     *     // ... the filter for the LoginConfigs we want to count
     *   }
     * })
    **/
    count<T extends LoginConfigCountArgs>(
      args?: Subset<T, LoginConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoginConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LoginConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoginConfigAggregateArgs>(args: Subset<T, LoginConfigAggregateArgs>): Prisma.PrismaPromise<GetLoginConfigAggregateType<T>>

    /**
     * Group by LoginConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoginConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoginConfigGroupByArgs['orderBy'] }
        : { orderBy?: LoginConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoginConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoginConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LoginConfig model
   */
  readonly fields: LoginConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LoginConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoginConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LoginConfig model
   */ 
  interface LoginConfigFieldRefs {
    readonly id: FieldRef<"LoginConfig", 'String'>
    readonly provider: FieldRef<"LoginConfig", 'OAuthProvider'>
    readonly name: FieldRef<"LoginConfig", 'String'>
    readonly isEnabled: FieldRef<"LoginConfig", 'Boolean'>
    readonly appId: FieldRef<"LoginConfig", 'String'>
    readonly appSecret: FieldRef<"LoginConfig", 'String'>
    readonly redirectUri: FieldRef<"LoginConfig", 'String'>
    readonly scope: FieldRef<"LoginConfig", 'String'>
    readonly config: FieldRef<"LoginConfig", 'Json'>
    readonly sortOrder: FieldRef<"LoginConfig", 'Int'>
    readonly createdAt: FieldRef<"LoginConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"LoginConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LoginConfig findUnique
   */
  export type LoginConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginConfig
     */
    select?: LoginConfigSelect<ExtArgs> | null
    /**
     * Filter, which LoginConfig to fetch.
     */
    where: LoginConfigWhereUniqueInput
  }

  /**
   * LoginConfig findUniqueOrThrow
   */
  export type LoginConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginConfig
     */
    select?: LoginConfigSelect<ExtArgs> | null
    /**
     * Filter, which LoginConfig to fetch.
     */
    where: LoginConfigWhereUniqueInput
  }

  /**
   * LoginConfig findFirst
   */
  export type LoginConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginConfig
     */
    select?: LoginConfigSelect<ExtArgs> | null
    /**
     * Filter, which LoginConfig to fetch.
     */
    where?: LoginConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoginConfigs to fetch.
     */
    orderBy?: LoginConfigOrderByWithRelationInput | LoginConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoginConfigs.
     */
    cursor?: LoginConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoginConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoginConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoginConfigs.
     */
    distinct?: LoginConfigScalarFieldEnum | LoginConfigScalarFieldEnum[]
  }

  /**
   * LoginConfig findFirstOrThrow
   */
  export type LoginConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginConfig
     */
    select?: LoginConfigSelect<ExtArgs> | null
    /**
     * Filter, which LoginConfig to fetch.
     */
    where?: LoginConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoginConfigs to fetch.
     */
    orderBy?: LoginConfigOrderByWithRelationInput | LoginConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoginConfigs.
     */
    cursor?: LoginConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoginConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoginConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoginConfigs.
     */
    distinct?: LoginConfigScalarFieldEnum | LoginConfigScalarFieldEnum[]
  }

  /**
   * LoginConfig findMany
   */
  export type LoginConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginConfig
     */
    select?: LoginConfigSelect<ExtArgs> | null
    /**
     * Filter, which LoginConfigs to fetch.
     */
    where?: LoginConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoginConfigs to fetch.
     */
    orderBy?: LoginConfigOrderByWithRelationInput | LoginConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LoginConfigs.
     */
    cursor?: LoginConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoginConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoginConfigs.
     */
    skip?: number
    distinct?: LoginConfigScalarFieldEnum | LoginConfigScalarFieldEnum[]
  }

  /**
   * LoginConfig create
   */
  export type LoginConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginConfig
     */
    select?: LoginConfigSelect<ExtArgs> | null
    /**
     * The data needed to create a LoginConfig.
     */
    data: XOR<LoginConfigCreateInput, LoginConfigUncheckedCreateInput>
  }

  /**
   * LoginConfig createMany
   */
  export type LoginConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LoginConfigs.
     */
    data: LoginConfigCreateManyInput | LoginConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LoginConfig update
   */
  export type LoginConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginConfig
     */
    select?: LoginConfigSelect<ExtArgs> | null
    /**
     * The data needed to update a LoginConfig.
     */
    data: XOR<LoginConfigUpdateInput, LoginConfigUncheckedUpdateInput>
    /**
     * Choose, which LoginConfig to update.
     */
    where: LoginConfigWhereUniqueInput
  }

  /**
   * LoginConfig updateMany
   */
  export type LoginConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LoginConfigs.
     */
    data: XOR<LoginConfigUpdateManyMutationInput, LoginConfigUncheckedUpdateManyInput>
    /**
     * Filter which LoginConfigs to update
     */
    where?: LoginConfigWhereInput
  }

  /**
   * LoginConfig upsert
   */
  export type LoginConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginConfig
     */
    select?: LoginConfigSelect<ExtArgs> | null
    /**
     * The filter to search for the LoginConfig to update in case it exists.
     */
    where: LoginConfigWhereUniqueInput
    /**
     * In case the LoginConfig found by the `where` argument doesn't exist, create a new LoginConfig with this data.
     */
    create: XOR<LoginConfigCreateInput, LoginConfigUncheckedCreateInput>
    /**
     * In case the LoginConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoginConfigUpdateInput, LoginConfigUncheckedUpdateInput>
  }

  /**
   * LoginConfig delete
   */
  export type LoginConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginConfig
     */
    select?: LoginConfigSelect<ExtArgs> | null
    /**
     * Filter which LoginConfig to delete.
     */
    where: LoginConfigWhereUniqueInput
  }

  /**
   * LoginConfig deleteMany
   */
  export type LoginConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoginConfigs to delete
     */
    where?: LoginConfigWhereInput
  }

  /**
   * LoginConfig without action
   */
  export type LoginConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginConfig
     */
    select?: LoginConfigSelect<ExtArgs> | null
  }


  /**
   * Model Scenario
   */

  export type AggregateScenario = {
    _count: ScenarioCountAggregateOutputType | null
    _avg: ScenarioAvgAggregateOutputType | null
    _sum: ScenarioSumAggregateOutputType | null
    _min: ScenarioMinAggregateOutputType | null
    _max: ScenarioMaxAggregateOutputType | null
  }

  export type ScenarioAvgAggregateOutputType = {
    estimatedDuration: number | null
    practiceCount: number | null
    averageScore: number | null
    maxTurns: number | null
  }

  export type ScenarioSumAggregateOutputType = {
    estimatedDuration: number | null
    practiceCount: number | null
    averageScore: number | null
    maxTurns: number | null
  }

  export type ScenarioMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    category: string | null
    difficulty: $Enums.Difficulty | null
    estimatedDuration: number | null
    isActive: boolean | null
    practiceCount: number | null
    averageScore: number | null
    maxTurns: number | null
    openingPrompt: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScenarioMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    category: string | null
    difficulty: $Enums.Difficulty | null
    estimatedDuration: number | null
    isActive: boolean | null
    practiceCount: number | null
    averageScore: number | null
    maxTurns: number | null
    openingPrompt: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScenarioCountAggregateOutputType = {
    id: number
    title: number
    description: number
    category: number
    difficulty: number
    estimatedDuration: number
    isActive: number
    practiceCount: number
    averageScore: number
    buyerPersona: number
    objections: number
    idealResponses: number
    maxTurns: number
    scoringWeights: number
    openingPrompt: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ScenarioAvgAggregateInputType = {
    estimatedDuration?: true
    practiceCount?: true
    averageScore?: true
    maxTurns?: true
  }

  export type ScenarioSumAggregateInputType = {
    estimatedDuration?: true
    practiceCount?: true
    averageScore?: true
    maxTurns?: true
  }

  export type ScenarioMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    difficulty?: true
    estimatedDuration?: true
    isActive?: true
    practiceCount?: true
    averageScore?: true
    maxTurns?: true
    openingPrompt?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScenarioMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    difficulty?: true
    estimatedDuration?: true
    isActive?: true
    practiceCount?: true
    averageScore?: true
    maxTurns?: true
    openingPrompt?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScenarioCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    difficulty?: true
    estimatedDuration?: true
    isActive?: true
    practiceCount?: true
    averageScore?: true
    buyerPersona?: true
    objections?: true
    idealResponses?: true
    maxTurns?: true
    scoringWeights?: true
    openingPrompt?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ScenarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Scenario to aggregate.
     */
    where?: ScenarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scenarios to fetch.
     */
    orderBy?: ScenarioOrderByWithRelationInput | ScenarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScenarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scenarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scenarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Scenarios
    **/
    _count?: true | ScenarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScenarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScenarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScenarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScenarioMaxAggregateInputType
  }

  export type GetScenarioAggregateType<T extends ScenarioAggregateArgs> = {
        [P in keyof T & keyof AggregateScenario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScenario[P]>
      : GetScalarType<T[P], AggregateScenario[P]>
  }




  export type ScenarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScenarioWhereInput
    orderBy?: ScenarioOrderByWithAggregationInput | ScenarioOrderByWithAggregationInput[]
    by: ScenarioScalarFieldEnum[] | ScenarioScalarFieldEnum
    having?: ScenarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScenarioCountAggregateInputType | true
    _avg?: ScenarioAvgAggregateInputType
    _sum?: ScenarioSumAggregateInputType
    _min?: ScenarioMinAggregateInputType
    _max?: ScenarioMaxAggregateInputType
  }

  export type ScenarioGroupByOutputType = {
    id: string
    title: string
    description: string
    category: string
    difficulty: $Enums.Difficulty
    estimatedDuration: number
    isActive: boolean
    practiceCount: number
    averageScore: number
    buyerPersona: JsonValue
    objections: JsonValue
    idealResponses: JsonValue
    maxTurns: number
    scoringWeights: JsonValue | null
    openingPrompt: string | null
    createdById: string
    createdAt: Date
    updatedAt: Date
    _count: ScenarioCountAggregateOutputType | null
    _avg: ScenarioAvgAggregateOutputType | null
    _sum: ScenarioSumAggregateOutputType | null
    _min: ScenarioMinAggregateOutputType | null
    _max: ScenarioMaxAggregateOutputType | null
  }

  type GetScenarioGroupByPayload<T extends ScenarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScenarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScenarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScenarioGroupByOutputType[P]>
            : GetScalarType<T[P], ScenarioGroupByOutputType[P]>
        }
      >
    >


  export type ScenarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    difficulty?: boolean
    estimatedDuration?: boolean
    isActive?: boolean
    practiceCount?: boolean
    averageScore?: boolean
    buyerPersona?: boolean
    objections?: boolean
    idealResponses?: boolean
    maxTurns?: boolean
    scoringWeights?: boolean
    openingPrompt?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    sessions?: boolean | Scenario$sessionsArgs<ExtArgs>
    _count?: boolean | ScenarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scenario"]>


  export type ScenarioSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    difficulty?: boolean
    estimatedDuration?: boolean
    isActive?: boolean
    practiceCount?: boolean
    averageScore?: boolean
    buyerPersona?: boolean
    objections?: boolean
    idealResponses?: boolean
    maxTurns?: boolean
    scoringWeights?: boolean
    openingPrompt?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ScenarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    sessions?: boolean | Scenario$sessionsArgs<ExtArgs>
    _count?: boolean | ScenarioCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ScenarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Scenario"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      sessions: Prisma.$SessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      category: string
      difficulty: $Enums.Difficulty
      estimatedDuration: number
      isActive: boolean
      practiceCount: number
      averageScore: number
      buyerPersona: Prisma.JsonValue
      objections: Prisma.JsonValue
      idealResponses: Prisma.JsonValue
      maxTurns: number
      scoringWeights: Prisma.JsonValue | null
      openingPrompt: string | null
      createdById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["scenario"]>
    composites: {}
  }

  type ScenarioGetPayload<S extends boolean | null | undefined | ScenarioDefaultArgs> = $Result.GetResult<Prisma.$ScenarioPayload, S>

  type ScenarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ScenarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ScenarioCountAggregateInputType | true
    }

  export interface ScenarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Scenario'], meta: { name: 'Scenario' } }
    /**
     * Find zero or one Scenario that matches the filter.
     * @param {ScenarioFindUniqueArgs} args - Arguments to find a Scenario
     * @example
     * // Get one Scenario
     * const scenario = await prisma.scenario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScenarioFindUniqueArgs>(args: SelectSubset<T, ScenarioFindUniqueArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Scenario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ScenarioFindUniqueOrThrowArgs} args - Arguments to find a Scenario
     * @example
     * // Get one Scenario
     * const scenario = await prisma.scenario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScenarioFindUniqueOrThrowArgs>(args: SelectSubset<T, ScenarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Scenario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioFindFirstArgs} args - Arguments to find a Scenario
     * @example
     * // Get one Scenario
     * const scenario = await prisma.scenario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScenarioFindFirstArgs>(args?: SelectSubset<T, ScenarioFindFirstArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Scenario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioFindFirstOrThrowArgs} args - Arguments to find a Scenario
     * @example
     * // Get one Scenario
     * const scenario = await prisma.scenario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScenarioFindFirstOrThrowArgs>(args?: SelectSubset<T, ScenarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Scenarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Scenarios
     * const scenarios = await prisma.scenario.findMany()
     * 
     * // Get first 10 Scenarios
     * const scenarios = await prisma.scenario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scenarioWithIdOnly = await prisma.scenario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScenarioFindManyArgs>(args?: SelectSubset<T, ScenarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Scenario.
     * @param {ScenarioCreateArgs} args - Arguments to create a Scenario.
     * @example
     * // Create one Scenario
     * const Scenario = await prisma.scenario.create({
     *   data: {
     *     // ... data to create a Scenario
     *   }
     * })
     * 
     */
    create<T extends ScenarioCreateArgs>(args: SelectSubset<T, ScenarioCreateArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Scenarios.
     * @param {ScenarioCreateManyArgs} args - Arguments to create many Scenarios.
     * @example
     * // Create many Scenarios
     * const scenario = await prisma.scenario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScenarioCreateManyArgs>(args?: SelectSubset<T, ScenarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Scenario.
     * @param {ScenarioDeleteArgs} args - Arguments to delete one Scenario.
     * @example
     * // Delete one Scenario
     * const Scenario = await prisma.scenario.delete({
     *   where: {
     *     // ... filter to delete one Scenario
     *   }
     * })
     * 
     */
    delete<T extends ScenarioDeleteArgs>(args: SelectSubset<T, ScenarioDeleteArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Scenario.
     * @param {ScenarioUpdateArgs} args - Arguments to update one Scenario.
     * @example
     * // Update one Scenario
     * const scenario = await prisma.scenario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScenarioUpdateArgs>(args: SelectSubset<T, ScenarioUpdateArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Scenarios.
     * @param {ScenarioDeleteManyArgs} args - Arguments to filter Scenarios to delete.
     * @example
     * // Delete a few Scenarios
     * const { count } = await prisma.scenario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScenarioDeleteManyArgs>(args?: SelectSubset<T, ScenarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Scenarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Scenarios
     * const scenario = await prisma.scenario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScenarioUpdateManyArgs>(args: SelectSubset<T, ScenarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Scenario.
     * @param {ScenarioUpsertArgs} args - Arguments to update or create a Scenario.
     * @example
     * // Update or create a Scenario
     * const scenario = await prisma.scenario.upsert({
     *   create: {
     *     // ... data to create a Scenario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Scenario we want to update
     *   }
     * })
     */
    upsert<T extends ScenarioUpsertArgs>(args: SelectSubset<T, ScenarioUpsertArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Scenarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioCountArgs} args - Arguments to filter Scenarios to count.
     * @example
     * // Count the number of Scenarios
     * const count = await prisma.scenario.count({
     *   where: {
     *     // ... the filter for the Scenarios we want to count
     *   }
     * })
    **/
    count<T extends ScenarioCountArgs>(
      args?: Subset<T, ScenarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScenarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Scenario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScenarioAggregateArgs>(args: Subset<T, ScenarioAggregateArgs>): Prisma.PrismaPromise<GetScenarioAggregateType<T>>

    /**
     * Group by Scenario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScenarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScenarioGroupByArgs['orderBy'] }
        : { orderBy?: ScenarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScenarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScenarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Scenario model
   */
  readonly fields: ScenarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Scenario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScenarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sessions<T extends Scenario$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Scenario$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Scenario model
   */ 
  interface ScenarioFieldRefs {
    readonly id: FieldRef<"Scenario", 'String'>
    readonly title: FieldRef<"Scenario", 'String'>
    readonly description: FieldRef<"Scenario", 'String'>
    readonly category: FieldRef<"Scenario", 'String'>
    readonly difficulty: FieldRef<"Scenario", 'Difficulty'>
    readonly estimatedDuration: FieldRef<"Scenario", 'Int'>
    readonly isActive: FieldRef<"Scenario", 'Boolean'>
    readonly practiceCount: FieldRef<"Scenario", 'Int'>
    readonly averageScore: FieldRef<"Scenario", 'Float'>
    readonly buyerPersona: FieldRef<"Scenario", 'Json'>
    readonly objections: FieldRef<"Scenario", 'Json'>
    readonly idealResponses: FieldRef<"Scenario", 'Json'>
    readonly maxTurns: FieldRef<"Scenario", 'Int'>
    readonly scoringWeights: FieldRef<"Scenario", 'Json'>
    readonly openingPrompt: FieldRef<"Scenario", 'String'>
    readonly createdById: FieldRef<"Scenario", 'String'>
    readonly createdAt: FieldRef<"Scenario", 'DateTime'>
    readonly updatedAt: FieldRef<"Scenario", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Scenario findUnique
   */
  export type ScenarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * Filter, which Scenario to fetch.
     */
    where: ScenarioWhereUniqueInput
  }

  /**
   * Scenario findUniqueOrThrow
   */
  export type ScenarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * Filter, which Scenario to fetch.
     */
    where: ScenarioWhereUniqueInput
  }

  /**
   * Scenario findFirst
   */
  export type ScenarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * Filter, which Scenario to fetch.
     */
    where?: ScenarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scenarios to fetch.
     */
    orderBy?: ScenarioOrderByWithRelationInput | ScenarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Scenarios.
     */
    cursor?: ScenarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scenarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scenarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Scenarios.
     */
    distinct?: ScenarioScalarFieldEnum | ScenarioScalarFieldEnum[]
  }

  /**
   * Scenario findFirstOrThrow
   */
  export type ScenarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * Filter, which Scenario to fetch.
     */
    where?: ScenarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scenarios to fetch.
     */
    orderBy?: ScenarioOrderByWithRelationInput | ScenarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Scenarios.
     */
    cursor?: ScenarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scenarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scenarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Scenarios.
     */
    distinct?: ScenarioScalarFieldEnum | ScenarioScalarFieldEnum[]
  }

  /**
   * Scenario findMany
   */
  export type ScenarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * Filter, which Scenarios to fetch.
     */
    where?: ScenarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scenarios to fetch.
     */
    orderBy?: ScenarioOrderByWithRelationInput | ScenarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Scenarios.
     */
    cursor?: ScenarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scenarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scenarios.
     */
    skip?: number
    distinct?: ScenarioScalarFieldEnum | ScenarioScalarFieldEnum[]
  }

  /**
   * Scenario create
   */
  export type ScenarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Scenario.
     */
    data: XOR<ScenarioCreateInput, ScenarioUncheckedCreateInput>
  }

  /**
   * Scenario createMany
   */
  export type ScenarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Scenarios.
     */
    data: ScenarioCreateManyInput | ScenarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Scenario update
   */
  export type ScenarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Scenario.
     */
    data: XOR<ScenarioUpdateInput, ScenarioUncheckedUpdateInput>
    /**
     * Choose, which Scenario to update.
     */
    where: ScenarioWhereUniqueInput
  }

  /**
   * Scenario updateMany
   */
  export type ScenarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Scenarios.
     */
    data: XOR<ScenarioUpdateManyMutationInput, ScenarioUncheckedUpdateManyInput>
    /**
     * Filter which Scenarios to update
     */
    where?: ScenarioWhereInput
  }

  /**
   * Scenario upsert
   */
  export type ScenarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Scenario to update in case it exists.
     */
    where: ScenarioWhereUniqueInput
    /**
     * In case the Scenario found by the `where` argument doesn't exist, create a new Scenario with this data.
     */
    create: XOR<ScenarioCreateInput, ScenarioUncheckedCreateInput>
    /**
     * In case the Scenario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScenarioUpdateInput, ScenarioUncheckedUpdateInput>
  }

  /**
   * Scenario delete
   */
  export type ScenarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * Filter which Scenario to delete.
     */
    where: ScenarioWhereUniqueInput
  }

  /**
   * Scenario deleteMany
   */
  export type ScenarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Scenarios to delete
     */
    where?: ScenarioWhereInput
  }

  /**
   * Scenario.sessions
   */
  export type Scenario$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Scenario without action
   */
  export type ScenarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    scenarioId: string | null
    status: $Enums.SessionStatus | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    scenarioId: string | null
    status: $Enums.SessionStatus | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    scenarioId: number
    status: number
    startedAt: number
    completedAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    scenarioId?: true
    status?: true
    startedAt?: true
    completedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    scenarioId?: true
    status?: true
    startedAt?: true
    completedAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    scenarioId?: true
    status?: true
    startedAt?: true
    completedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    scenarioId: string
    status: $Enums.SessionStatus
    startedAt: Date
    completedAt: Date | null
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    scenarioId?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    scenario?: boolean | ScenarioDefaultArgs<ExtArgs>
    messages?: boolean | Session$messagesArgs<ExtArgs>
    feedback?: boolean | Session$feedbackArgs<ExtArgs>
    email?: boolean | Session$emailArgs<ExtArgs>
    _count?: boolean | SessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>


  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    scenarioId?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    scenario?: boolean | ScenarioDefaultArgs<ExtArgs>
    messages?: boolean | Session$messagesArgs<ExtArgs>
    feedback?: boolean | Session$feedbackArgs<ExtArgs>
    email?: boolean | Session$emailArgs<ExtArgs>
    _count?: boolean | SessionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      scenario: Prisma.$ScenarioPayload<ExtArgs>
      messages: Prisma.$MessagePayload<ExtArgs>[]
      feedback: Prisma.$FeedbackPayload<ExtArgs> | null
      email: Prisma.$FollowUpEmailPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      scenarioId: string
      status: $Enums.SessionStatus
      startedAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    scenario<T extends ScenarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ScenarioDefaultArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    messages<T extends Session$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Session$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    feedback<T extends Session$feedbackArgs<ExtArgs> = {}>(args?: Subset<T, Session$feedbackArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    email<T extends Session$emailArgs<ExtArgs> = {}>(args?: Subset<T, Session$emailArgs<ExtArgs>>): Prisma__FollowUpEmailClient<$Result.GetResult<Prisma.$FollowUpEmailPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly scenarioId: FieldRef<"Session", 'String'>
    readonly status: FieldRef<"Session", 'SessionStatus'>
    readonly startedAt: FieldRef<"Session", 'DateTime'>
    readonly completedAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session.messages
   */
  export type Session$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Session.feedback
   */
  export type Session$feedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    where?: FeedbackWhereInput
  }

  /**
   * Session.email
   */
  export type Session$emailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUpEmail
     */
    select?: FollowUpEmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpEmailInclude<ExtArgs> | null
    where?: FollowUpEmailWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    role: $Enums.MessageRole | null
    content: string | null
    timestamp: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    role: $Enums.MessageRole | null
    content: string | null
    timestamp: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    sessionId: number
    role: number
    content: number
    timestamp: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    sessionId?: true
    role?: true
    content?: true
    timestamp?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    sessionId?: true
    role?: true
    content?: true
    timestamp?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    sessionId?: true
    role?: true
    content?: true
    timestamp?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    sessionId: string
    role: $Enums.MessageRole
    content: string
    timestamp: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    role?: boolean
    content?: boolean
    timestamp?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>


  export type MessageSelectScalar = {
    id?: boolean
    sessionId?: boolean
    role?: boolean
    content?: boolean
    timestamp?: boolean
  }

  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      session: Prisma.$SessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      role: $Enums.MessageRole
      content: string
      timestamp: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends SessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SessionDefaultArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly sessionId: FieldRef<"Message", 'String'>
    readonly role: FieldRef<"Message", 'MessageRole'>
    readonly content: FieldRef<"Message", 'String'>
    readonly timestamp: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model Feedback
   */

  export type AggregateFeedback = {
    _count: FeedbackCountAggregateOutputType | null
    _avg: FeedbackAvgAggregateOutputType | null
    _sum: FeedbackSumAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  export type FeedbackAvgAggregateOutputType = {
    overallScore: number | null
  }

  export type FeedbackSumAggregateOutputType = {
    overallScore: number | null
  }

  export type FeedbackMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    overallScore: number | null
    summary: string | null
    createdAt: Date | null
  }

  export type FeedbackMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    overallScore: number | null
    summary: string | null
    createdAt: Date | null
  }

  export type FeedbackCountAggregateOutputType = {
    id: number
    sessionId: number
    overallScore: number
    dimensions: number
    summary: number
    recommendations: number
    createdAt: number
    _all: number
  }


  export type FeedbackAvgAggregateInputType = {
    overallScore?: true
  }

  export type FeedbackSumAggregateInputType = {
    overallScore?: true
  }

  export type FeedbackMinAggregateInputType = {
    id?: true
    sessionId?: true
    overallScore?: true
    summary?: true
    createdAt?: true
  }

  export type FeedbackMaxAggregateInputType = {
    id?: true
    sessionId?: true
    overallScore?: true
    summary?: true
    createdAt?: true
  }

  export type FeedbackCountAggregateInputType = {
    id?: true
    sessionId?: true
    overallScore?: true
    dimensions?: true
    summary?: true
    recommendations?: true
    createdAt?: true
    _all?: true
  }

  export type FeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedback to aggregate.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Feedbacks
    **/
    _count?: true | FeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedbackMaxAggregateInputType
  }

  export type GetFeedbackAggregateType<T extends FeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedback[P]>
      : GetScalarType<T[P], AggregateFeedback[P]>
  }




  export type FeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithAggregationInput | FeedbackOrderByWithAggregationInput[]
    by: FeedbackScalarFieldEnum[] | FeedbackScalarFieldEnum
    having?: FeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedbackCountAggregateInputType | true
    _avg?: FeedbackAvgAggregateInputType
    _sum?: FeedbackSumAggregateInputType
    _min?: FeedbackMinAggregateInputType
    _max?: FeedbackMaxAggregateInputType
  }

  export type FeedbackGroupByOutputType = {
    id: string
    sessionId: string
    overallScore: number
    dimensions: JsonValue
    summary: string
    recommendations: JsonValue
    createdAt: Date
    _count: FeedbackCountAggregateOutputType | null
    _avg: FeedbackAvgAggregateOutputType | null
    _sum: FeedbackSumAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  type GetFeedbackGroupByPayload<T extends FeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
        }
      >
    >


  export type FeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    overallScore?: boolean
    dimensions?: boolean
    summary?: boolean
    recommendations?: boolean
    createdAt?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedback"]>


  export type FeedbackSelectScalar = {
    id?: boolean
    sessionId?: boolean
    overallScore?: boolean
    dimensions?: boolean
    summary?: boolean
    recommendations?: boolean
    createdAt?: boolean
  }

  export type FeedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }

  export type $FeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Feedback"
    objects: {
      session: Prisma.$SessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      overallScore: number
      dimensions: Prisma.JsonValue
      summary: string
      recommendations: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["feedback"]>
    composites: {}
  }

  type FeedbackGetPayload<S extends boolean | null | undefined | FeedbackDefaultArgs> = $Result.GetResult<Prisma.$FeedbackPayload, S>

  type FeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FeedbackFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FeedbackCountAggregateInputType | true
    }

  export interface FeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Feedback'], meta: { name: 'Feedback' } }
    /**
     * Find zero or one Feedback that matches the filter.
     * @param {FeedbackFindUniqueArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeedbackFindUniqueArgs>(args: SelectSubset<T, FeedbackFindUniqueArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Feedback that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FeedbackFindUniqueOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, FeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Feedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeedbackFindFirstArgs>(args?: SelectSubset<T, FeedbackFindFirstArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Feedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, FeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Feedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Feedbacks
     * const feedbacks = await prisma.feedback.findMany()
     * 
     * // Get first 10 Feedbacks
     * const feedbacks = await prisma.feedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedbackWithIdOnly = await prisma.feedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeedbackFindManyArgs>(args?: SelectSubset<T, FeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Feedback.
     * @param {FeedbackCreateArgs} args - Arguments to create a Feedback.
     * @example
     * // Create one Feedback
     * const Feedback = await prisma.feedback.create({
     *   data: {
     *     // ... data to create a Feedback
     *   }
     * })
     * 
     */
    create<T extends FeedbackCreateArgs>(args: SelectSubset<T, FeedbackCreateArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Feedbacks.
     * @param {FeedbackCreateManyArgs} args - Arguments to create many Feedbacks.
     * @example
     * // Create many Feedbacks
     * const feedback = await prisma.feedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeedbackCreateManyArgs>(args?: SelectSubset<T, FeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Feedback.
     * @param {FeedbackDeleteArgs} args - Arguments to delete one Feedback.
     * @example
     * // Delete one Feedback
     * const Feedback = await prisma.feedback.delete({
     *   where: {
     *     // ... filter to delete one Feedback
     *   }
     * })
     * 
     */
    delete<T extends FeedbackDeleteArgs>(args: SelectSubset<T, FeedbackDeleteArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Feedback.
     * @param {FeedbackUpdateArgs} args - Arguments to update one Feedback.
     * @example
     * // Update one Feedback
     * const feedback = await prisma.feedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeedbackUpdateArgs>(args: SelectSubset<T, FeedbackUpdateArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Feedbacks.
     * @param {FeedbackDeleteManyArgs} args - Arguments to filter Feedbacks to delete.
     * @example
     * // Delete a few Feedbacks
     * const { count } = await prisma.feedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeedbackDeleteManyArgs>(args?: SelectSubset<T, FeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Feedbacks
     * const feedback = await prisma.feedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeedbackUpdateManyArgs>(args: SelectSubset<T, FeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Feedback.
     * @param {FeedbackUpsertArgs} args - Arguments to update or create a Feedback.
     * @example
     * // Update or create a Feedback
     * const feedback = await prisma.feedback.upsert({
     *   create: {
     *     // ... data to create a Feedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feedback we want to update
     *   }
     * })
     */
    upsert<T extends FeedbackUpsertArgs>(args: SelectSubset<T, FeedbackUpsertArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackCountArgs} args - Arguments to filter Feedbacks to count.
     * @example
     * // Count the number of Feedbacks
     * const count = await prisma.feedback.count({
     *   where: {
     *     // ... the filter for the Feedbacks we want to count
     *   }
     * })
    **/
    count<T extends FeedbackCountArgs>(
      args?: Subset<T, FeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedbackAggregateArgs>(args: Subset<T, FeedbackAggregateArgs>): Prisma.PrismaPromise<GetFeedbackAggregateType<T>>

    /**
     * Group by Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedbackGroupByArgs['orderBy'] }
        : { orderBy?: FeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Feedback model
   */
  readonly fields: FeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Feedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends SessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SessionDefaultArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Feedback model
   */ 
  interface FeedbackFieldRefs {
    readonly id: FieldRef<"Feedback", 'String'>
    readonly sessionId: FieldRef<"Feedback", 'String'>
    readonly overallScore: FieldRef<"Feedback", 'Int'>
    readonly dimensions: FieldRef<"Feedback", 'Json'>
    readonly summary: FieldRef<"Feedback", 'String'>
    readonly recommendations: FieldRef<"Feedback", 'Json'>
    readonly createdAt: FieldRef<"Feedback", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Feedback findUnique
   */
  export type FeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback findUniqueOrThrow
   */
  export type FeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback findFirst
   */
  export type FeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback findFirstOrThrow
   */
  export type FeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback findMany
   */
  export type FeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedbacks to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback create
   */
  export type FeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a Feedback.
     */
    data: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
  }

  /**
   * Feedback createMany
   */
  export type FeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Feedbacks.
     */
    data: FeedbackCreateManyInput | FeedbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Feedback update
   */
  export type FeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a Feedback.
     */
    data: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
    /**
     * Choose, which Feedback to update.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback updateMany
   */
  export type FeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Feedbacks.
     */
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyInput>
    /**
     * Filter which Feedbacks to update
     */
    where?: FeedbackWhereInput
  }

  /**
   * Feedback upsert
   */
  export type FeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the Feedback to update in case it exists.
     */
    where: FeedbackWhereUniqueInput
    /**
     * In case the Feedback found by the `where` argument doesn't exist, create a new Feedback with this data.
     */
    create: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
    /**
     * In case the Feedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
  }

  /**
   * Feedback delete
   */
  export type FeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter which Feedback to delete.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback deleteMany
   */
  export type FeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedbacks to delete
     */
    where?: FeedbackWhereInput
  }

  /**
   * Feedback without action
   */
  export type FeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
  }


  /**
   * Model FollowUpEmail
   */

  export type AggregateFollowUpEmail = {
    _count: FollowUpEmailCountAggregateOutputType | null
    _min: FollowUpEmailMinAggregateOutputType | null
    _max: FollowUpEmailMaxAggregateOutputType | null
  }

  export type FollowUpEmailMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    userId: string | null
    toAddress: string | null
    subject: string | null
    body: string | null
    isEdited: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FollowUpEmailMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    userId: string | null
    toAddress: string | null
    subject: string | null
    body: string | null
    isEdited: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FollowUpEmailCountAggregateOutputType = {
    id: number
    sessionId: number
    userId: number
    toAddress: number
    subject: number
    body: number
    isEdited: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FollowUpEmailMinAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    toAddress?: true
    subject?: true
    body?: true
    isEdited?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FollowUpEmailMaxAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    toAddress?: true
    subject?: true
    body?: true
    isEdited?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FollowUpEmailCountAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    toAddress?: true
    subject?: true
    body?: true
    isEdited?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FollowUpEmailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FollowUpEmail to aggregate.
     */
    where?: FollowUpEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FollowUpEmails to fetch.
     */
    orderBy?: FollowUpEmailOrderByWithRelationInput | FollowUpEmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FollowUpEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FollowUpEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FollowUpEmails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FollowUpEmails
    **/
    _count?: true | FollowUpEmailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FollowUpEmailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FollowUpEmailMaxAggregateInputType
  }

  export type GetFollowUpEmailAggregateType<T extends FollowUpEmailAggregateArgs> = {
        [P in keyof T & keyof AggregateFollowUpEmail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFollowUpEmail[P]>
      : GetScalarType<T[P], AggregateFollowUpEmail[P]>
  }




  export type FollowUpEmailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowUpEmailWhereInput
    orderBy?: FollowUpEmailOrderByWithAggregationInput | FollowUpEmailOrderByWithAggregationInput[]
    by: FollowUpEmailScalarFieldEnum[] | FollowUpEmailScalarFieldEnum
    having?: FollowUpEmailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FollowUpEmailCountAggregateInputType | true
    _min?: FollowUpEmailMinAggregateInputType
    _max?: FollowUpEmailMaxAggregateInputType
  }

  export type FollowUpEmailGroupByOutputType = {
    id: string
    sessionId: string
    userId: string
    toAddress: string | null
    subject: string
    body: string
    isEdited: boolean
    createdAt: Date
    updatedAt: Date
    _count: FollowUpEmailCountAggregateOutputType | null
    _min: FollowUpEmailMinAggregateOutputType | null
    _max: FollowUpEmailMaxAggregateOutputType | null
  }

  type GetFollowUpEmailGroupByPayload<T extends FollowUpEmailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FollowUpEmailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FollowUpEmailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FollowUpEmailGroupByOutputType[P]>
            : GetScalarType<T[P], FollowUpEmailGroupByOutputType[P]>
        }
      >
    >


  export type FollowUpEmailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    toAddress?: boolean
    subject?: boolean
    body?: boolean
    isEdited?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["followUpEmail"]>


  export type FollowUpEmailSelectScalar = {
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    toAddress?: boolean
    subject?: boolean
    body?: boolean
    isEdited?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FollowUpEmailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FollowUpEmailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FollowUpEmail"
    objects: {
      session: Prisma.$SessionPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      userId: string
      toAddress: string | null
      subject: string
      body: string
      isEdited: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["followUpEmail"]>
    composites: {}
  }

  type FollowUpEmailGetPayload<S extends boolean | null | undefined | FollowUpEmailDefaultArgs> = $Result.GetResult<Prisma.$FollowUpEmailPayload, S>

  type FollowUpEmailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FollowUpEmailFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FollowUpEmailCountAggregateInputType | true
    }

  export interface FollowUpEmailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FollowUpEmail'], meta: { name: 'FollowUpEmail' } }
    /**
     * Find zero or one FollowUpEmail that matches the filter.
     * @param {FollowUpEmailFindUniqueArgs} args - Arguments to find a FollowUpEmail
     * @example
     * // Get one FollowUpEmail
     * const followUpEmail = await prisma.followUpEmail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FollowUpEmailFindUniqueArgs>(args: SelectSubset<T, FollowUpEmailFindUniqueArgs<ExtArgs>>): Prisma__FollowUpEmailClient<$Result.GetResult<Prisma.$FollowUpEmailPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FollowUpEmail that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FollowUpEmailFindUniqueOrThrowArgs} args - Arguments to find a FollowUpEmail
     * @example
     * // Get one FollowUpEmail
     * const followUpEmail = await prisma.followUpEmail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FollowUpEmailFindUniqueOrThrowArgs>(args: SelectSubset<T, FollowUpEmailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FollowUpEmailClient<$Result.GetResult<Prisma.$FollowUpEmailPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FollowUpEmail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpEmailFindFirstArgs} args - Arguments to find a FollowUpEmail
     * @example
     * // Get one FollowUpEmail
     * const followUpEmail = await prisma.followUpEmail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FollowUpEmailFindFirstArgs>(args?: SelectSubset<T, FollowUpEmailFindFirstArgs<ExtArgs>>): Prisma__FollowUpEmailClient<$Result.GetResult<Prisma.$FollowUpEmailPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FollowUpEmail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpEmailFindFirstOrThrowArgs} args - Arguments to find a FollowUpEmail
     * @example
     * // Get one FollowUpEmail
     * const followUpEmail = await prisma.followUpEmail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FollowUpEmailFindFirstOrThrowArgs>(args?: SelectSubset<T, FollowUpEmailFindFirstOrThrowArgs<ExtArgs>>): Prisma__FollowUpEmailClient<$Result.GetResult<Prisma.$FollowUpEmailPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FollowUpEmails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpEmailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FollowUpEmails
     * const followUpEmails = await prisma.followUpEmail.findMany()
     * 
     * // Get first 10 FollowUpEmails
     * const followUpEmails = await prisma.followUpEmail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const followUpEmailWithIdOnly = await prisma.followUpEmail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FollowUpEmailFindManyArgs>(args?: SelectSubset<T, FollowUpEmailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowUpEmailPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FollowUpEmail.
     * @param {FollowUpEmailCreateArgs} args - Arguments to create a FollowUpEmail.
     * @example
     * // Create one FollowUpEmail
     * const FollowUpEmail = await prisma.followUpEmail.create({
     *   data: {
     *     // ... data to create a FollowUpEmail
     *   }
     * })
     * 
     */
    create<T extends FollowUpEmailCreateArgs>(args: SelectSubset<T, FollowUpEmailCreateArgs<ExtArgs>>): Prisma__FollowUpEmailClient<$Result.GetResult<Prisma.$FollowUpEmailPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FollowUpEmails.
     * @param {FollowUpEmailCreateManyArgs} args - Arguments to create many FollowUpEmails.
     * @example
     * // Create many FollowUpEmails
     * const followUpEmail = await prisma.followUpEmail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FollowUpEmailCreateManyArgs>(args?: SelectSubset<T, FollowUpEmailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FollowUpEmail.
     * @param {FollowUpEmailDeleteArgs} args - Arguments to delete one FollowUpEmail.
     * @example
     * // Delete one FollowUpEmail
     * const FollowUpEmail = await prisma.followUpEmail.delete({
     *   where: {
     *     // ... filter to delete one FollowUpEmail
     *   }
     * })
     * 
     */
    delete<T extends FollowUpEmailDeleteArgs>(args: SelectSubset<T, FollowUpEmailDeleteArgs<ExtArgs>>): Prisma__FollowUpEmailClient<$Result.GetResult<Prisma.$FollowUpEmailPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FollowUpEmail.
     * @param {FollowUpEmailUpdateArgs} args - Arguments to update one FollowUpEmail.
     * @example
     * // Update one FollowUpEmail
     * const followUpEmail = await prisma.followUpEmail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FollowUpEmailUpdateArgs>(args: SelectSubset<T, FollowUpEmailUpdateArgs<ExtArgs>>): Prisma__FollowUpEmailClient<$Result.GetResult<Prisma.$FollowUpEmailPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FollowUpEmails.
     * @param {FollowUpEmailDeleteManyArgs} args - Arguments to filter FollowUpEmails to delete.
     * @example
     * // Delete a few FollowUpEmails
     * const { count } = await prisma.followUpEmail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FollowUpEmailDeleteManyArgs>(args?: SelectSubset<T, FollowUpEmailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FollowUpEmails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpEmailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FollowUpEmails
     * const followUpEmail = await prisma.followUpEmail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FollowUpEmailUpdateManyArgs>(args: SelectSubset<T, FollowUpEmailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FollowUpEmail.
     * @param {FollowUpEmailUpsertArgs} args - Arguments to update or create a FollowUpEmail.
     * @example
     * // Update or create a FollowUpEmail
     * const followUpEmail = await prisma.followUpEmail.upsert({
     *   create: {
     *     // ... data to create a FollowUpEmail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FollowUpEmail we want to update
     *   }
     * })
     */
    upsert<T extends FollowUpEmailUpsertArgs>(args: SelectSubset<T, FollowUpEmailUpsertArgs<ExtArgs>>): Prisma__FollowUpEmailClient<$Result.GetResult<Prisma.$FollowUpEmailPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FollowUpEmails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpEmailCountArgs} args - Arguments to filter FollowUpEmails to count.
     * @example
     * // Count the number of FollowUpEmails
     * const count = await prisma.followUpEmail.count({
     *   where: {
     *     // ... the filter for the FollowUpEmails we want to count
     *   }
     * })
    **/
    count<T extends FollowUpEmailCountArgs>(
      args?: Subset<T, FollowUpEmailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FollowUpEmailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FollowUpEmail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpEmailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FollowUpEmailAggregateArgs>(args: Subset<T, FollowUpEmailAggregateArgs>): Prisma.PrismaPromise<GetFollowUpEmailAggregateType<T>>

    /**
     * Group by FollowUpEmail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpEmailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FollowUpEmailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FollowUpEmailGroupByArgs['orderBy'] }
        : { orderBy?: FollowUpEmailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FollowUpEmailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFollowUpEmailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FollowUpEmail model
   */
  readonly fields: FollowUpEmailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FollowUpEmail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FollowUpEmailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends SessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SessionDefaultArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FollowUpEmail model
   */ 
  interface FollowUpEmailFieldRefs {
    readonly id: FieldRef<"FollowUpEmail", 'String'>
    readonly sessionId: FieldRef<"FollowUpEmail", 'String'>
    readonly userId: FieldRef<"FollowUpEmail", 'String'>
    readonly toAddress: FieldRef<"FollowUpEmail", 'String'>
    readonly subject: FieldRef<"FollowUpEmail", 'String'>
    readonly body: FieldRef<"FollowUpEmail", 'String'>
    readonly isEdited: FieldRef<"FollowUpEmail", 'Boolean'>
    readonly createdAt: FieldRef<"FollowUpEmail", 'DateTime'>
    readonly updatedAt: FieldRef<"FollowUpEmail", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FollowUpEmail findUnique
   */
  export type FollowUpEmailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUpEmail
     */
    select?: FollowUpEmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpEmailInclude<ExtArgs> | null
    /**
     * Filter, which FollowUpEmail to fetch.
     */
    where: FollowUpEmailWhereUniqueInput
  }

  /**
   * FollowUpEmail findUniqueOrThrow
   */
  export type FollowUpEmailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUpEmail
     */
    select?: FollowUpEmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpEmailInclude<ExtArgs> | null
    /**
     * Filter, which FollowUpEmail to fetch.
     */
    where: FollowUpEmailWhereUniqueInput
  }

  /**
   * FollowUpEmail findFirst
   */
  export type FollowUpEmailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUpEmail
     */
    select?: FollowUpEmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpEmailInclude<ExtArgs> | null
    /**
     * Filter, which FollowUpEmail to fetch.
     */
    where?: FollowUpEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FollowUpEmails to fetch.
     */
    orderBy?: FollowUpEmailOrderByWithRelationInput | FollowUpEmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FollowUpEmails.
     */
    cursor?: FollowUpEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FollowUpEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FollowUpEmails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FollowUpEmails.
     */
    distinct?: FollowUpEmailScalarFieldEnum | FollowUpEmailScalarFieldEnum[]
  }

  /**
   * FollowUpEmail findFirstOrThrow
   */
  export type FollowUpEmailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUpEmail
     */
    select?: FollowUpEmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpEmailInclude<ExtArgs> | null
    /**
     * Filter, which FollowUpEmail to fetch.
     */
    where?: FollowUpEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FollowUpEmails to fetch.
     */
    orderBy?: FollowUpEmailOrderByWithRelationInput | FollowUpEmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FollowUpEmails.
     */
    cursor?: FollowUpEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FollowUpEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FollowUpEmails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FollowUpEmails.
     */
    distinct?: FollowUpEmailScalarFieldEnum | FollowUpEmailScalarFieldEnum[]
  }

  /**
   * FollowUpEmail findMany
   */
  export type FollowUpEmailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUpEmail
     */
    select?: FollowUpEmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpEmailInclude<ExtArgs> | null
    /**
     * Filter, which FollowUpEmails to fetch.
     */
    where?: FollowUpEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FollowUpEmails to fetch.
     */
    orderBy?: FollowUpEmailOrderByWithRelationInput | FollowUpEmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FollowUpEmails.
     */
    cursor?: FollowUpEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FollowUpEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FollowUpEmails.
     */
    skip?: number
    distinct?: FollowUpEmailScalarFieldEnum | FollowUpEmailScalarFieldEnum[]
  }

  /**
   * FollowUpEmail create
   */
  export type FollowUpEmailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUpEmail
     */
    select?: FollowUpEmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpEmailInclude<ExtArgs> | null
    /**
     * The data needed to create a FollowUpEmail.
     */
    data: XOR<FollowUpEmailCreateInput, FollowUpEmailUncheckedCreateInput>
  }

  /**
   * FollowUpEmail createMany
   */
  export type FollowUpEmailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FollowUpEmails.
     */
    data: FollowUpEmailCreateManyInput | FollowUpEmailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FollowUpEmail update
   */
  export type FollowUpEmailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUpEmail
     */
    select?: FollowUpEmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpEmailInclude<ExtArgs> | null
    /**
     * The data needed to update a FollowUpEmail.
     */
    data: XOR<FollowUpEmailUpdateInput, FollowUpEmailUncheckedUpdateInput>
    /**
     * Choose, which FollowUpEmail to update.
     */
    where: FollowUpEmailWhereUniqueInput
  }

  /**
   * FollowUpEmail updateMany
   */
  export type FollowUpEmailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FollowUpEmails.
     */
    data: XOR<FollowUpEmailUpdateManyMutationInput, FollowUpEmailUncheckedUpdateManyInput>
    /**
     * Filter which FollowUpEmails to update
     */
    where?: FollowUpEmailWhereInput
  }

  /**
   * FollowUpEmail upsert
   */
  export type FollowUpEmailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUpEmail
     */
    select?: FollowUpEmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpEmailInclude<ExtArgs> | null
    /**
     * The filter to search for the FollowUpEmail to update in case it exists.
     */
    where: FollowUpEmailWhereUniqueInput
    /**
     * In case the FollowUpEmail found by the `where` argument doesn't exist, create a new FollowUpEmail with this data.
     */
    create: XOR<FollowUpEmailCreateInput, FollowUpEmailUncheckedCreateInput>
    /**
     * In case the FollowUpEmail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FollowUpEmailUpdateInput, FollowUpEmailUncheckedUpdateInput>
  }

  /**
   * FollowUpEmail delete
   */
  export type FollowUpEmailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUpEmail
     */
    select?: FollowUpEmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpEmailInclude<ExtArgs> | null
    /**
     * Filter which FollowUpEmail to delete.
     */
    where: FollowUpEmailWhereUniqueInput
  }

  /**
   * FollowUpEmail deleteMany
   */
  export type FollowUpEmailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FollowUpEmails to delete
     */
    where?: FollowUpEmailWhereInput
  }

  /**
   * FollowUpEmail without action
   */
  export type FollowUpEmailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUpEmail
     */
    select?: FollowUpEmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpEmailInclude<ExtArgs> | null
  }


  /**
   * Model AIModel
   */

  export type AggregateAIModel = {
    _count: AIModelCountAggregateOutputType | null
    _min: AIModelMinAggregateOutputType | null
    _max: AIModelMaxAggregateOutputType | null
  }

  export type AIModelMinAggregateOutputType = {
    id: string | null
    modelId: string | null
    name: string | null
    provider: string | null
    description: string | null
    apiEndpoint: string | null
    apiKey: string | null
    isDefault: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIModelMaxAggregateOutputType = {
    id: string | null
    modelId: string | null
    name: string | null
    provider: string | null
    description: string | null
    apiEndpoint: string | null
    apiKey: string | null
    isDefault: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIModelCountAggregateOutputType = {
    id: number
    modelId: number
    name: number
    provider: number
    description: number
    apiEndpoint: number
    apiKey: number
    isDefault: number
    isActive: number
    config: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AIModelMinAggregateInputType = {
    id?: true
    modelId?: true
    name?: true
    provider?: true
    description?: true
    apiEndpoint?: true
    apiKey?: true
    isDefault?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIModelMaxAggregateInputType = {
    id?: true
    modelId?: true
    name?: true
    provider?: true
    description?: true
    apiEndpoint?: true
    apiKey?: true
    isDefault?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIModelCountAggregateInputType = {
    id?: true
    modelId?: true
    name?: true
    provider?: true
    description?: true
    apiEndpoint?: true
    apiKey?: true
    isDefault?: true
    isActive?: true
    config?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AIModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIModel to aggregate.
     */
    where?: AIModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIModels to fetch.
     */
    orderBy?: AIModelOrderByWithRelationInput | AIModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIModels
    **/
    _count?: true | AIModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIModelMaxAggregateInputType
  }

  export type GetAIModelAggregateType<T extends AIModelAggregateArgs> = {
        [P in keyof T & keyof AggregateAIModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIModel[P]>
      : GetScalarType<T[P], AggregateAIModel[P]>
  }




  export type AIModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIModelWhereInput
    orderBy?: AIModelOrderByWithAggregationInput | AIModelOrderByWithAggregationInput[]
    by: AIModelScalarFieldEnum[] | AIModelScalarFieldEnum
    having?: AIModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIModelCountAggregateInputType | true
    _min?: AIModelMinAggregateInputType
    _max?: AIModelMaxAggregateInputType
  }

  export type AIModelGroupByOutputType = {
    id: string
    modelId: string
    name: string
    provider: string
    description: string | null
    apiEndpoint: string | null
    apiKey: string | null
    isDefault: boolean
    isActive: boolean
    config: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: AIModelCountAggregateOutputType | null
    _min: AIModelMinAggregateOutputType | null
    _max: AIModelMaxAggregateOutputType | null
  }

  type GetAIModelGroupByPayload<T extends AIModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIModelGroupByOutputType[P]>
            : GetScalarType<T[P], AIModelGroupByOutputType[P]>
        }
      >
    >


  export type AIModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    modelId?: boolean
    name?: boolean
    provider?: boolean
    description?: boolean
    apiEndpoint?: boolean
    apiKey?: boolean
    isDefault?: boolean
    isActive?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aIModel"]>


  export type AIModelSelectScalar = {
    id?: boolean
    modelId?: boolean
    name?: boolean
    provider?: boolean
    description?: boolean
    apiEndpoint?: boolean
    apiKey?: boolean
    isDefault?: boolean
    isActive?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $AIModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIModel"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      modelId: string
      name: string
      provider: string
      description: string | null
      apiEndpoint: string | null
      apiKey: string | null
      isDefault: boolean
      isActive: boolean
      config: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aIModel"]>
    composites: {}
  }

  type AIModelGetPayload<S extends boolean | null | undefined | AIModelDefaultArgs> = $Result.GetResult<Prisma.$AIModelPayload, S>

  type AIModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AIModelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AIModelCountAggregateInputType | true
    }

  export interface AIModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIModel'], meta: { name: 'AIModel' } }
    /**
     * Find zero or one AIModel that matches the filter.
     * @param {AIModelFindUniqueArgs} args - Arguments to find a AIModel
     * @example
     * // Get one AIModel
     * const aIModel = await prisma.aIModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIModelFindUniqueArgs>(args: SelectSubset<T, AIModelFindUniqueArgs<ExtArgs>>): Prisma__AIModelClient<$Result.GetResult<Prisma.$AIModelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AIModel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AIModelFindUniqueOrThrowArgs} args - Arguments to find a AIModel
     * @example
     * // Get one AIModel
     * const aIModel = await prisma.aIModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIModelFindUniqueOrThrowArgs>(args: SelectSubset<T, AIModelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIModelClient<$Result.GetResult<Prisma.$AIModelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AIModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModelFindFirstArgs} args - Arguments to find a AIModel
     * @example
     * // Get one AIModel
     * const aIModel = await prisma.aIModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIModelFindFirstArgs>(args?: SelectSubset<T, AIModelFindFirstArgs<ExtArgs>>): Prisma__AIModelClient<$Result.GetResult<Prisma.$AIModelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AIModel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModelFindFirstOrThrowArgs} args - Arguments to find a AIModel
     * @example
     * // Get one AIModel
     * const aIModel = await prisma.aIModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIModelFindFirstOrThrowArgs>(args?: SelectSubset<T, AIModelFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIModelClient<$Result.GetResult<Prisma.$AIModelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AIModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIModels
     * const aIModels = await prisma.aIModel.findMany()
     * 
     * // Get first 10 AIModels
     * const aIModels = await prisma.aIModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIModelWithIdOnly = await prisma.aIModel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIModelFindManyArgs>(args?: SelectSubset<T, AIModelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIModelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AIModel.
     * @param {AIModelCreateArgs} args - Arguments to create a AIModel.
     * @example
     * // Create one AIModel
     * const AIModel = await prisma.aIModel.create({
     *   data: {
     *     // ... data to create a AIModel
     *   }
     * })
     * 
     */
    create<T extends AIModelCreateArgs>(args: SelectSubset<T, AIModelCreateArgs<ExtArgs>>): Prisma__AIModelClient<$Result.GetResult<Prisma.$AIModelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AIModels.
     * @param {AIModelCreateManyArgs} args - Arguments to create many AIModels.
     * @example
     * // Create many AIModels
     * const aIModel = await prisma.aIModel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIModelCreateManyArgs>(args?: SelectSubset<T, AIModelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AIModel.
     * @param {AIModelDeleteArgs} args - Arguments to delete one AIModel.
     * @example
     * // Delete one AIModel
     * const AIModel = await prisma.aIModel.delete({
     *   where: {
     *     // ... filter to delete one AIModel
     *   }
     * })
     * 
     */
    delete<T extends AIModelDeleteArgs>(args: SelectSubset<T, AIModelDeleteArgs<ExtArgs>>): Prisma__AIModelClient<$Result.GetResult<Prisma.$AIModelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AIModel.
     * @param {AIModelUpdateArgs} args - Arguments to update one AIModel.
     * @example
     * // Update one AIModel
     * const aIModel = await prisma.aIModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIModelUpdateArgs>(args: SelectSubset<T, AIModelUpdateArgs<ExtArgs>>): Prisma__AIModelClient<$Result.GetResult<Prisma.$AIModelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AIModels.
     * @param {AIModelDeleteManyArgs} args - Arguments to filter AIModels to delete.
     * @example
     * // Delete a few AIModels
     * const { count } = await prisma.aIModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIModelDeleteManyArgs>(args?: SelectSubset<T, AIModelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIModels
     * const aIModel = await prisma.aIModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIModelUpdateManyArgs>(args: SelectSubset<T, AIModelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AIModel.
     * @param {AIModelUpsertArgs} args - Arguments to update or create a AIModel.
     * @example
     * // Update or create a AIModel
     * const aIModel = await prisma.aIModel.upsert({
     *   create: {
     *     // ... data to create a AIModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIModel we want to update
     *   }
     * })
     */
    upsert<T extends AIModelUpsertArgs>(args: SelectSubset<T, AIModelUpsertArgs<ExtArgs>>): Prisma__AIModelClient<$Result.GetResult<Prisma.$AIModelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AIModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModelCountArgs} args - Arguments to filter AIModels to count.
     * @example
     * // Count the number of AIModels
     * const count = await prisma.aIModel.count({
     *   where: {
     *     // ... the filter for the AIModels we want to count
     *   }
     * })
    **/
    count<T extends AIModelCountArgs>(
      args?: Subset<T, AIModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIModelAggregateArgs>(args: Subset<T, AIModelAggregateArgs>): Prisma.PrismaPromise<GetAIModelAggregateType<T>>

    /**
     * Group by AIModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIModelGroupByArgs['orderBy'] }
        : { orderBy?: AIModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIModel model
   */
  readonly fields: AIModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIModel model
   */ 
  interface AIModelFieldRefs {
    readonly id: FieldRef<"AIModel", 'String'>
    readonly modelId: FieldRef<"AIModel", 'String'>
    readonly name: FieldRef<"AIModel", 'String'>
    readonly provider: FieldRef<"AIModel", 'String'>
    readonly description: FieldRef<"AIModel", 'String'>
    readonly apiEndpoint: FieldRef<"AIModel", 'String'>
    readonly apiKey: FieldRef<"AIModel", 'String'>
    readonly isDefault: FieldRef<"AIModel", 'Boolean'>
    readonly isActive: FieldRef<"AIModel", 'Boolean'>
    readonly config: FieldRef<"AIModel", 'Json'>
    readonly createdAt: FieldRef<"AIModel", 'DateTime'>
    readonly updatedAt: FieldRef<"AIModel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIModel findUnique
   */
  export type AIModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModel
     */
    select?: AIModelSelect<ExtArgs> | null
    /**
     * Filter, which AIModel to fetch.
     */
    where: AIModelWhereUniqueInput
  }

  /**
   * AIModel findUniqueOrThrow
   */
  export type AIModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModel
     */
    select?: AIModelSelect<ExtArgs> | null
    /**
     * Filter, which AIModel to fetch.
     */
    where: AIModelWhereUniqueInput
  }

  /**
   * AIModel findFirst
   */
  export type AIModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModel
     */
    select?: AIModelSelect<ExtArgs> | null
    /**
     * Filter, which AIModel to fetch.
     */
    where?: AIModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIModels to fetch.
     */
    orderBy?: AIModelOrderByWithRelationInput | AIModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIModels.
     */
    cursor?: AIModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIModels.
     */
    distinct?: AIModelScalarFieldEnum | AIModelScalarFieldEnum[]
  }

  /**
   * AIModel findFirstOrThrow
   */
  export type AIModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModel
     */
    select?: AIModelSelect<ExtArgs> | null
    /**
     * Filter, which AIModel to fetch.
     */
    where?: AIModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIModels to fetch.
     */
    orderBy?: AIModelOrderByWithRelationInput | AIModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIModels.
     */
    cursor?: AIModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIModels.
     */
    distinct?: AIModelScalarFieldEnum | AIModelScalarFieldEnum[]
  }

  /**
   * AIModel findMany
   */
  export type AIModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModel
     */
    select?: AIModelSelect<ExtArgs> | null
    /**
     * Filter, which AIModels to fetch.
     */
    where?: AIModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIModels to fetch.
     */
    orderBy?: AIModelOrderByWithRelationInput | AIModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIModels.
     */
    cursor?: AIModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIModels.
     */
    skip?: number
    distinct?: AIModelScalarFieldEnum | AIModelScalarFieldEnum[]
  }

  /**
   * AIModel create
   */
  export type AIModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModel
     */
    select?: AIModelSelect<ExtArgs> | null
    /**
     * The data needed to create a AIModel.
     */
    data: XOR<AIModelCreateInput, AIModelUncheckedCreateInput>
  }

  /**
   * AIModel createMany
   */
  export type AIModelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIModels.
     */
    data: AIModelCreateManyInput | AIModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIModel update
   */
  export type AIModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModel
     */
    select?: AIModelSelect<ExtArgs> | null
    /**
     * The data needed to update a AIModel.
     */
    data: XOR<AIModelUpdateInput, AIModelUncheckedUpdateInput>
    /**
     * Choose, which AIModel to update.
     */
    where: AIModelWhereUniqueInput
  }

  /**
   * AIModel updateMany
   */
  export type AIModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIModels.
     */
    data: XOR<AIModelUpdateManyMutationInput, AIModelUncheckedUpdateManyInput>
    /**
     * Filter which AIModels to update
     */
    where?: AIModelWhereInput
  }

  /**
   * AIModel upsert
   */
  export type AIModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModel
     */
    select?: AIModelSelect<ExtArgs> | null
    /**
     * The filter to search for the AIModel to update in case it exists.
     */
    where: AIModelWhereUniqueInput
    /**
     * In case the AIModel found by the `where` argument doesn't exist, create a new AIModel with this data.
     */
    create: XOR<AIModelCreateInput, AIModelUncheckedCreateInput>
    /**
     * In case the AIModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIModelUpdateInput, AIModelUncheckedUpdateInput>
  }

  /**
   * AIModel delete
   */
  export type AIModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModel
     */
    select?: AIModelSelect<ExtArgs> | null
    /**
     * Filter which AIModel to delete.
     */
    where: AIModelWhereUniqueInput
  }

  /**
   * AIModel deleteMany
   */
  export type AIModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIModels to delete
     */
    where?: AIModelWhereInput
  }

  /**
   * AIModel without action
   */
  export type AIModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModel
     */
    select?: AIModelSelect<ExtArgs> | null
  }


  /**
   * Model SystemSetting
   */

  export type AggregateSystemSetting = {
    _count: SystemSettingCountAggregateOutputType | null
    _min: SystemSettingMinAggregateOutputType | null
    _max: SystemSettingMaxAggregateOutputType | null
  }

  export type SystemSettingMinAggregateOutputType = {
    id: string | null
    key: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemSettingMaxAggregateOutputType = {
    id: string | null
    key: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemSettingCountAggregateOutputType = {
    id: number
    key: number
    value: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SystemSettingMinAggregateInputType = {
    id?: true
    key?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemSettingMaxAggregateInputType = {
    id?: true
    key?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemSettingCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSetting to aggregate.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemSettings
    **/
    _count?: true | SystemSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemSettingMaxAggregateInputType
  }

  export type GetSystemSettingAggregateType<T extends SystemSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemSetting[P]>
      : GetScalarType<T[P], AggregateSystemSetting[P]>
  }




  export type SystemSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemSettingWhereInput
    orderBy?: SystemSettingOrderByWithAggregationInput | SystemSettingOrderByWithAggregationInput[]
    by: SystemSettingScalarFieldEnum[] | SystemSettingScalarFieldEnum
    having?: SystemSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemSettingCountAggregateInputType | true
    _min?: SystemSettingMinAggregateInputType
    _max?: SystemSettingMaxAggregateInputType
  }

  export type SystemSettingGroupByOutputType = {
    id: string
    key: string
    value: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: SystemSettingCountAggregateOutputType | null
    _min: SystemSettingMinAggregateOutputType | null
    _max: SystemSettingMaxAggregateOutputType | null
  }

  type GetSystemSettingGroupByPayload<T extends SystemSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
            : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
        }
      >
    >


  export type SystemSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemSetting"]>


  export type SystemSettingSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $SystemSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemSetting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["systemSetting"]>
    composites: {}
  }

  type SystemSettingGetPayload<S extends boolean | null | undefined | SystemSettingDefaultArgs> = $Result.GetResult<Prisma.$SystemSettingPayload, S>

  type SystemSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SystemSettingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SystemSettingCountAggregateInputType | true
    }

  export interface SystemSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemSetting'], meta: { name: 'SystemSetting' } }
    /**
     * Find zero or one SystemSetting that matches the filter.
     * @param {SystemSettingFindUniqueArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemSettingFindUniqueArgs>(args: SelectSubset<T, SystemSettingFindUniqueArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SystemSetting that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SystemSettingFindUniqueOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SystemSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemSettingFindFirstArgs>(args?: SelectSubset<T, SystemSettingFindFirstArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SystemSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany()
     * 
     * // Get first 10 SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemSettingFindManyArgs>(args?: SelectSubset<T, SystemSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SystemSetting.
     * @param {SystemSettingCreateArgs} args - Arguments to create a SystemSetting.
     * @example
     * // Create one SystemSetting
     * const SystemSetting = await prisma.systemSetting.create({
     *   data: {
     *     // ... data to create a SystemSetting
     *   }
     * })
     * 
     */
    create<T extends SystemSettingCreateArgs>(args: SelectSubset<T, SystemSettingCreateArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SystemSettings.
     * @param {SystemSettingCreateManyArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSetting = await prisma.systemSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemSettingCreateManyArgs>(args?: SelectSubset<T, SystemSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SystemSetting.
     * @param {SystemSettingDeleteArgs} args - Arguments to delete one SystemSetting.
     * @example
     * // Delete one SystemSetting
     * const SystemSetting = await prisma.systemSetting.delete({
     *   where: {
     *     // ... filter to delete one SystemSetting
     *   }
     * })
     * 
     */
    delete<T extends SystemSettingDeleteArgs>(args: SelectSubset<T, SystemSettingDeleteArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SystemSetting.
     * @param {SystemSettingUpdateArgs} args - Arguments to update one SystemSetting.
     * @example
     * // Update one SystemSetting
     * const systemSetting = await prisma.systemSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemSettingUpdateArgs>(args: SelectSubset<T, SystemSettingUpdateArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SystemSettings.
     * @param {SystemSettingDeleteManyArgs} args - Arguments to filter SystemSettings to delete.
     * @example
     * // Delete a few SystemSettings
     * const { count } = await prisma.systemSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemSettingDeleteManyArgs>(args?: SelectSubset<T, SystemSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemSettings
     * const systemSetting = await prisma.systemSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemSettingUpdateManyArgs>(args: SelectSubset<T, SystemSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemSetting.
     * @param {SystemSettingUpsertArgs} args - Arguments to update or create a SystemSetting.
     * @example
     * // Update or create a SystemSetting
     * const systemSetting = await prisma.systemSetting.upsert({
     *   create: {
     *     // ... data to create a SystemSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemSetting we want to update
     *   }
     * })
     */
    upsert<T extends SystemSettingUpsertArgs>(args: SelectSubset<T, SystemSettingUpsertArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingCountArgs} args - Arguments to filter SystemSettings to count.
     * @example
     * // Count the number of SystemSettings
     * const count = await prisma.systemSetting.count({
     *   where: {
     *     // ... the filter for the SystemSettings we want to count
     *   }
     * })
    **/
    count<T extends SystemSettingCountArgs>(
      args?: Subset<T, SystemSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemSettingAggregateArgs>(args: Subset<T, SystemSettingAggregateArgs>): Prisma.PrismaPromise<GetSystemSettingAggregateType<T>>

    /**
     * Group by SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemSettingGroupByArgs['orderBy'] }
        : { orderBy?: SystemSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemSetting model
   */
  readonly fields: SystemSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemSetting model
   */ 
  interface SystemSettingFieldRefs {
    readonly id: FieldRef<"SystemSetting", 'String'>
    readonly key: FieldRef<"SystemSetting", 'String'>
    readonly value: FieldRef<"SystemSetting", 'Json'>
    readonly createdAt: FieldRef<"SystemSetting", 'DateTime'>
    readonly updatedAt: FieldRef<"SystemSetting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemSetting findUnique
   */
  export type SystemSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting findUniqueOrThrow
   */
  export type SystemSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting findFirst
   */
  export type SystemSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting findFirstOrThrow
   */
  export type SystemSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting findMany
   */
  export type SystemSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting create
   */
  export type SystemSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * The data needed to create a SystemSetting.
     */
    data: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>
  }

  /**
   * SystemSetting createMany
   */
  export type SystemSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingCreateManyInput | SystemSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSetting update
   */
  export type SystemSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * The data needed to update a SystemSetting.
     */
    data: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>
    /**
     * Choose, which SystemSetting to update.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting updateMany
   */
  export type SystemSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingUpdateManyMutationInput, SystemSettingUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingWhereInput
  }

  /**
   * SystemSetting upsert
   */
  export type SystemSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * The filter to search for the SystemSetting to update in case it exists.
     */
    where: SystemSettingWhereUniqueInput
    /**
     * In case the SystemSetting found by the `where` argument doesn't exist, create a new SystemSetting with this data.
     */
    create: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>
    /**
     * In case the SystemSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>
  }

  /**
   * SystemSetting delete
   */
  export type SystemSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Filter which SystemSetting to delete.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting deleteMany
   */
  export type SystemSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to delete
     */
    where?: SystemSettingWhereInput
  }

  /**
   * SystemSetting without action
   */
  export type SystemSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
  }


  /**
   * Model BuyerPersonaTemplate
   */

  export type AggregateBuyerPersonaTemplate = {
    _count: BuyerPersonaTemplateCountAggregateOutputType | null
    _min: BuyerPersonaTemplateMinAggregateOutputType | null
    _max: BuyerPersonaTemplateMaxAggregateOutputType | null
  }

  export type BuyerPersonaTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    role: string | null
    company: string | null
    background: string | null
    personality: string | null
    category: string | null
    isDefault: boolean | null
    isActive: boolean | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BuyerPersonaTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    role: string | null
    company: string | null
    background: string | null
    personality: string | null
    category: string | null
    isDefault: boolean | null
    isActive: boolean | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BuyerPersonaTemplateCountAggregateOutputType = {
    id: number
    name: number
    role: number
    company: number
    background: number
    concerns: number
    personality: number
    category: number
    isDefault: number
    isActive: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BuyerPersonaTemplateMinAggregateInputType = {
    id?: true
    name?: true
    role?: true
    company?: true
    background?: true
    personality?: true
    category?: true
    isDefault?: true
    isActive?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BuyerPersonaTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    role?: true
    company?: true
    background?: true
    personality?: true
    category?: true
    isDefault?: true
    isActive?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BuyerPersonaTemplateCountAggregateInputType = {
    id?: true
    name?: true
    role?: true
    company?: true
    background?: true
    concerns?: true
    personality?: true
    category?: true
    isDefault?: true
    isActive?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BuyerPersonaTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuyerPersonaTemplate to aggregate.
     */
    where?: BuyerPersonaTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuyerPersonaTemplates to fetch.
     */
    orderBy?: BuyerPersonaTemplateOrderByWithRelationInput | BuyerPersonaTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BuyerPersonaTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuyerPersonaTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuyerPersonaTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BuyerPersonaTemplates
    **/
    _count?: true | BuyerPersonaTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuyerPersonaTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuyerPersonaTemplateMaxAggregateInputType
  }

  export type GetBuyerPersonaTemplateAggregateType<T extends BuyerPersonaTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateBuyerPersonaTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuyerPersonaTemplate[P]>
      : GetScalarType<T[P], AggregateBuyerPersonaTemplate[P]>
  }




  export type BuyerPersonaTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuyerPersonaTemplateWhereInput
    orderBy?: BuyerPersonaTemplateOrderByWithAggregationInput | BuyerPersonaTemplateOrderByWithAggregationInput[]
    by: BuyerPersonaTemplateScalarFieldEnum[] | BuyerPersonaTemplateScalarFieldEnum
    having?: BuyerPersonaTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuyerPersonaTemplateCountAggregateInputType | true
    _min?: BuyerPersonaTemplateMinAggregateInputType
    _max?: BuyerPersonaTemplateMaxAggregateInputType
  }

  export type BuyerPersonaTemplateGroupByOutputType = {
    id: string
    name: string
    role: string
    company: string
    background: string
    concerns: JsonValue
    personality: string
    category: string
    isDefault: boolean
    isActive: boolean
    createdById: string | null
    createdAt: Date
    updatedAt: Date
    _count: BuyerPersonaTemplateCountAggregateOutputType | null
    _min: BuyerPersonaTemplateMinAggregateOutputType | null
    _max: BuyerPersonaTemplateMaxAggregateOutputType | null
  }

  type GetBuyerPersonaTemplateGroupByPayload<T extends BuyerPersonaTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuyerPersonaTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuyerPersonaTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuyerPersonaTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], BuyerPersonaTemplateGroupByOutputType[P]>
        }
      >
    >


  export type BuyerPersonaTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    company?: boolean
    background?: boolean
    concerns?: boolean
    personality?: boolean
    category?: boolean
    isDefault?: boolean
    isActive?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | BuyerPersonaTemplate$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["buyerPersonaTemplate"]>


  export type BuyerPersonaTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    role?: boolean
    company?: boolean
    background?: boolean
    concerns?: boolean
    personality?: boolean
    category?: boolean
    isDefault?: boolean
    isActive?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BuyerPersonaTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | BuyerPersonaTemplate$createdByArgs<ExtArgs>
  }

  export type $BuyerPersonaTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BuyerPersonaTemplate"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      role: string
      company: string
      background: string
      concerns: Prisma.JsonValue
      personality: string
      category: string
      isDefault: boolean
      isActive: boolean
      createdById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["buyerPersonaTemplate"]>
    composites: {}
  }

  type BuyerPersonaTemplateGetPayload<S extends boolean | null | undefined | BuyerPersonaTemplateDefaultArgs> = $Result.GetResult<Prisma.$BuyerPersonaTemplatePayload, S>

  type BuyerPersonaTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BuyerPersonaTemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BuyerPersonaTemplateCountAggregateInputType | true
    }

  export interface BuyerPersonaTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BuyerPersonaTemplate'], meta: { name: 'BuyerPersonaTemplate' } }
    /**
     * Find zero or one BuyerPersonaTemplate that matches the filter.
     * @param {BuyerPersonaTemplateFindUniqueArgs} args - Arguments to find a BuyerPersonaTemplate
     * @example
     * // Get one BuyerPersonaTemplate
     * const buyerPersonaTemplate = await prisma.buyerPersonaTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BuyerPersonaTemplateFindUniqueArgs>(args: SelectSubset<T, BuyerPersonaTemplateFindUniqueArgs<ExtArgs>>): Prisma__BuyerPersonaTemplateClient<$Result.GetResult<Prisma.$BuyerPersonaTemplatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BuyerPersonaTemplate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BuyerPersonaTemplateFindUniqueOrThrowArgs} args - Arguments to find a BuyerPersonaTemplate
     * @example
     * // Get one BuyerPersonaTemplate
     * const buyerPersonaTemplate = await prisma.buyerPersonaTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BuyerPersonaTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, BuyerPersonaTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BuyerPersonaTemplateClient<$Result.GetResult<Prisma.$BuyerPersonaTemplatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BuyerPersonaTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuyerPersonaTemplateFindFirstArgs} args - Arguments to find a BuyerPersonaTemplate
     * @example
     * // Get one BuyerPersonaTemplate
     * const buyerPersonaTemplate = await prisma.buyerPersonaTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BuyerPersonaTemplateFindFirstArgs>(args?: SelectSubset<T, BuyerPersonaTemplateFindFirstArgs<ExtArgs>>): Prisma__BuyerPersonaTemplateClient<$Result.GetResult<Prisma.$BuyerPersonaTemplatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BuyerPersonaTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuyerPersonaTemplateFindFirstOrThrowArgs} args - Arguments to find a BuyerPersonaTemplate
     * @example
     * // Get one BuyerPersonaTemplate
     * const buyerPersonaTemplate = await prisma.buyerPersonaTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BuyerPersonaTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, BuyerPersonaTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__BuyerPersonaTemplateClient<$Result.GetResult<Prisma.$BuyerPersonaTemplatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BuyerPersonaTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuyerPersonaTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BuyerPersonaTemplates
     * const buyerPersonaTemplates = await prisma.buyerPersonaTemplate.findMany()
     * 
     * // Get first 10 BuyerPersonaTemplates
     * const buyerPersonaTemplates = await prisma.buyerPersonaTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const buyerPersonaTemplateWithIdOnly = await prisma.buyerPersonaTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BuyerPersonaTemplateFindManyArgs>(args?: SelectSubset<T, BuyerPersonaTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuyerPersonaTemplatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BuyerPersonaTemplate.
     * @param {BuyerPersonaTemplateCreateArgs} args - Arguments to create a BuyerPersonaTemplate.
     * @example
     * // Create one BuyerPersonaTemplate
     * const BuyerPersonaTemplate = await prisma.buyerPersonaTemplate.create({
     *   data: {
     *     // ... data to create a BuyerPersonaTemplate
     *   }
     * })
     * 
     */
    create<T extends BuyerPersonaTemplateCreateArgs>(args: SelectSubset<T, BuyerPersonaTemplateCreateArgs<ExtArgs>>): Prisma__BuyerPersonaTemplateClient<$Result.GetResult<Prisma.$BuyerPersonaTemplatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BuyerPersonaTemplates.
     * @param {BuyerPersonaTemplateCreateManyArgs} args - Arguments to create many BuyerPersonaTemplates.
     * @example
     * // Create many BuyerPersonaTemplates
     * const buyerPersonaTemplate = await prisma.buyerPersonaTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BuyerPersonaTemplateCreateManyArgs>(args?: SelectSubset<T, BuyerPersonaTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BuyerPersonaTemplate.
     * @param {BuyerPersonaTemplateDeleteArgs} args - Arguments to delete one BuyerPersonaTemplate.
     * @example
     * // Delete one BuyerPersonaTemplate
     * const BuyerPersonaTemplate = await prisma.buyerPersonaTemplate.delete({
     *   where: {
     *     // ... filter to delete one BuyerPersonaTemplate
     *   }
     * })
     * 
     */
    delete<T extends BuyerPersonaTemplateDeleteArgs>(args: SelectSubset<T, BuyerPersonaTemplateDeleteArgs<ExtArgs>>): Prisma__BuyerPersonaTemplateClient<$Result.GetResult<Prisma.$BuyerPersonaTemplatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BuyerPersonaTemplate.
     * @param {BuyerPersonaTemplateUpdateArgs} args - Arguments to update one BuyerPersonaTemplate.
     * @example
     * // Update one BuyerPersonaTemplate
     * const buyerPersonaTemplate = await prisma.buyerPersonaTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BuyerPersonaTemplateUpdateArgs>(args: SelectSubset<T, BuyerPersonaTemplateUpdateArgs<ExtArgs>>): Prisma__BuyerPersonaTemplateClient<$Result.GetResult<Prisma.$BuyerPersonaTemplatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BuyerPersonaTemplates.
     * @param {BuyerPersonaTemplateDeleteManyArgs} args - Arguments to filter BuyerPersonaTemplates to delete.
     * @example
     * // Delete a few BuyerPersonaTemplates
     * const { count } = await prisma.buyerPersonaTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BuyerPersonaTemplateDeleteManyArgs>(args?: SelectSubset<T, BuyerPersonaTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BuyerPersonaTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuyerPersonaTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BuyerPersonaTemplates
     * const buyerPersonaTemplate = await prisma.buyerPersonaTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BuyerPersonaTemplateUpdateManyArgs>(args: SelectSubset<T, BuyerPersonaTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BuyerPersonaTemplate.
     * @param {BuyerPersonaTemplateUpsertArgs} args - Arguments to update or create a BuyerPersonaTemplate.
     * @example
     * // Update or create a BuyerPersonaTemplate
     * const buyerPersonaTemplate = await prisma.buyerPersonaTemplate.upsert({
     *   create: {
     *     // ... data to create a BuyerPersonaTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BuyerPersonaTemplate we want to update
     *   }
     * })
     */
    upsert<T extends BuyerPersonaTemplateUpsertArgs>(args: SelectSubset<T, BuyerPersonaTemplateUpsertArgs<ExtArgs>>): Prisma__BuyerPersonaTemplateClient<$Result.GetResult<Prisma.$BuyerPersonaTemplatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BuyerPersonaTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuyerPersonaTemplateCountArgs} args - Arguments to filter BuyerPersonaTemplates to count.
     * @example
     * // Count the number of BuyerPersonaTemplates
     * const count = await prisma.buyerPersonaTemplate.count({
     *   where: {
     *     // ... the filter for the BuyerPersonaTemplates we want to count
     *   }
     * })
    **/
    count<T extends BuyerPersonaTemplateCountArgs>(
      args?: Subset<T, BuyerPersonaTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuyerPersonaTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BuyerPersonaTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuyerPersonaTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuyerPersonaTemplateAggregateArgs>(args: Subset<T, BuyerPersonaTemplateAggregateArgs>): Prisma.PrismaPromise<GetBuyerPersonaTemplateAggregateType<T>>

    /**
     * Group by BuyerPersonaTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuyerPersonaTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuyerPersonaTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuyerPersonaTemplateGroupByArgs['orderBy'] }
        : { orderBy?: BuyerPersonaTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuyerPersonaTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuyerPersonaTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BuyerPersonaTemplate model
   */
  readonly fields: BuyerPersonaTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BuyerPersonaTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BuyerPersonaTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends BuyerPersonaTemplate$createdByArgs<ExtArgs> = {}>(args?: Subset<T, BuyerPersonaTemplate$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BuyerPersonaTemplate model
   */ 
  interface BuyerPersonaTemplateFieldRefs {
    readonly id: FieldRef<"BuyerPersonaTemplate", 'String'>
    readonly name: FieldRef<"BuyerPersonaTemplate", 'String'>
    readonly role: FieldRef<"BuyerPersonaTemplate", 'String'>
    readonly company: FieldRef<"BuyerPersonaTemplate", 'String'>
    readonly background: FieldRef<"BuyerPersonaTemplate", 'String'>
    readonly concerns: FieldRef<"BuyerPersonaTemplate", 'Json'>
    readonly personality: FieldRef<"BuyerPersonaTemplate", 'String'>
    readonly category: FieldRef<"BuyerPersonaTemplate", 'String'>
    readonly isDefault: FieldRef<"BuyerPersonaTemplate", 'Boolean'>
    readonly isActive: FieldRef<"BuyerPersonaTemplate", 'Boolean'>
    readonly createdById: FieldRef<"BuyerPersonaTemplate", 'String'>
    readonly createdAt: FieldRef<"BuyerPersonaTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"BuyerPersonaTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BuyerPersonaTemplate findUnique
   */
  export type BuyerPersonaTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuyerPersonaTemplate
     */
    select?: BuyerPersonaTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuyerPersonaTemplateInclude<ExtArgs> | null
    /**
     * Filter, which BuyerPersonaTemplate to fetch.
     */
    where: BuyerPersonaTemplateWhereUniqueInput
  }

  /**
   * BuyerPersonaTemplate findUniqueOrThrow
   */
  export type BuyerPersonaTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuyerPersonaTemplate
     */
    select?: BuyerPersonaTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuyerPersonaTemplateInclude<ExtArgs> | null
    /**
     * Filter, which BuyerPersonaTemplate to fetch.
     */
    where: BuyerPersonaTemplateWhereUniqueInput
  }

  /**
   * BuyerPersonaTemplate findFirst
   */
  export type BuyerPersonaTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuyerPersonaTemplate
     */
    select?: BuyerPersonaTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuyerPersonaTemplateInclude<ExtArgs> | null
    /**
     * Filter, which BuyerPersonaTemplate to fetch.
     */
    where?: BuyerPersonaTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuyerPersonaTemplates to fetch.
     */
    orderBy?: BuyerPersonaTemplateOrderByWithRelationInput | BuyerPersonaTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuyerPersonaTemplates.
     */
    cursor?: BuyerPersonaTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuyerPersonaTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuyerPersonaTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuyerPersonaTemplates.
     */
    distinct?: BuyerPersonaTemplateScalarFieldEnum | BuyerPersonaTemplateScalarFieldEnum[]
  }

  /**
   * BuyerPersonaTemplate findFirstOrThrow
   */
  export type BuyerPersonaTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuyerPersonaTemplate
     */
    select?: BuyerPersonaTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuyerPersonaTemplateInclude<ExtArgs> | null
    /**
     * Filter, which BuyerPersonaTemplate to fetch.
     */
    where?: BuyerPersonaTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuyerPersonaTemplates to fetch.
     */
    orderBy?: BuyerPersonaTemplateOrderByWithRelationInput | BuyerPersonaTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuyerPersonaTemplates.
     */
    cursor?: BuyerPersonaTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuyerPersonaTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuyerPersonaTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuyerPersonaTemplates.
     */
    distinct?: BuyerPersonaTemplateScalarFieldEnum | BuyerPersonaTemplateScalarFieldEnum[]
  }

  /**
   * BuyerPersonaTemplate findMany
   */
  export type BuyerPersonaTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuyerPersonaTemplate
     */
    select?: BuyerPersonaTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuyerPersonaTemplateInclude<ExtArgs> | null
    /**
     * Filter, which BuyerPersonaTemplates to fetch.
     */
    where?: BuyerPersonaTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuyerPersonaTemplates to fetch.
     */
    orderBy?: BuyerPersonaTemplateOrderByWithRelationInput | BuyerPersonaTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BuyerPersonaTemplates.
     */
    cursor?: BuyerPersonaTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuyerPersonaTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuyerPersonaTemplates.
     */
    skip?: number
    distinct?: BuyerPersonaTemplateScalarFieldEnum | BuyerPersonaTemplateScalarFieldEnum[]
  }

  /**
   * BuyerPersonaTemplate create
   */
  export type BuyerPersonaTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuyerPersonaTemplate
     */
    select?: BuyerPersonaTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuyerPersonaTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a BuyerPersonaTemplate.
     */
    data: XOR<BuyerPersonaTemplateCreateInput, BuyerPersonaTemplateUncheckedCreateInput>
  }

  /**
   * BuyerPersonaTemplate createMany
   */
  export type BuyerPersonaTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BuyerPersonaTemplates.
     */
    data: BuyerPersonaTemplateCreateManyInput | BuyerPersonaTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BuyerPersonaTemplate update
   */
  export type BuyerPersonaTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuyerPersonaTemplate
     */
    select?: BuyerPersonaTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuyerPersonaTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a BuyerPersonaTemplate.
     */
    data: XOR<BuyerPersonaTemplateUpdateInput, BuyerPersonaTemplateUncheckedUpdateInput>
    /**
     * Choose, which BuyerPersonaTemplate to update.
     */
    where: BuyerPersonaTemplateWhereUniqueInput
  }

  /**
   * BuyerPersonaTemplate updateMany
   */
  export type BuyerPersonaTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BuyerPersonaTemplates.
     */
    data: XOR<BuyerPersonaTemplateUpdateManyMutationInput, BuyerPersonaTemplateUncheckedUpdateManyInput>
    /**
     * Filter which BuyerPersonaTemplates to update
     */
    where?: BuyerPersonaTemplateWhereInput
  }

  /**
   * BuyerPersonaTemplate upsert
   */
  export type BuyerPersonaTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuyerPersonaTemplate
     */
    select?: BuyerPersonaTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuyerPersonaTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the BuyerPersonaTemplate to update in case it exists.
     */
    where: BuyerPersonaTemplateWhereUniqueInput
    /**
     * In case the BuyerPersonaTemplate found by the `where` argument doesn't exist, create a new BuyerPersonaTemplate with this data.
     */
    create: XOR<BuyerPersonaTemplateCreateInput, BuyerPersonaTemplateUncheckedCreateInput>
    /**
     * In case the BuyerPersonaTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BuyerPersonaTemplateUpdateInput, BuyerPersonaTemplateUncheckedUpdateInput>
  }

  /**
   * BuyerPersonaTemplate delete
   */
  export type BuyerPersonaTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuyerPersonaTemplate
     */
    select?: BuyerPersonaTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuyerPersonaTemplateInclude<ExtArgs> | null
    /**
     * Filter which BuyerPersonaTemplate to delete.
     */
    where: BuyerPersonaTemplateWhereUniqueInput
  }

  /**
   * BuyerPersonaTemplate deleteMany
   */
  export type BuyerPersonaTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuyerPersonaTemplates to delete
     */
    where?: BuyerPersonaTemplateWhereInput
  }

  /**
   * BuyerPersonaTemplate.createdBy
   */
  export type BuyerPersonaTemplate$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * BuyerPersonaTemplate without action
   */
  export type BuyerPersonaTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuyerPersonaTemplate
     */
    select?: BuyerPersonaTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuyerPersonaTemplateInclude<ExtArgs> | null
  }


  /**
   * Model OperationLog
   */

  export type AggregateOperationLog = {
    _count: OperationLogCountAggregateOutputType | null
    _min: OperationLogMinAggregateOutputType | null
    _max: OperationLogMaxAggregateOutputType | null
  }

  export type OperationLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    operationType: string | null
    targetType: string | null
    targetId: string | null
    description: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type OperationLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    operationType: string | null
    targetType: string | null
    targetId: string | null
    description: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type OperationLogCountAggregateOutputType = {
    id: number
    userId: number
    operationType: number
    targetType: number
    targetId: number
    description: number
    details: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type OperationLogMinAggregateInputType = {
    id?: true
    userId?: true
    operationType?: true
    targetType?: true
    targetId?: true
    description?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type OperationLogMaxAggregateInputType = {
    id?: true
    userId?: true
    operationType?: true
    targetType?: true
    targetId?: true
    description?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type OperationLogCountAggregateInputType = {
    id?: true
    userId?: true
    operationType?: true
    targetType?: true
    targetId?: true
    description?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type OperationLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperationLog to aggregate.
     */
    where?: OperationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationLogs to fetch.
     */
    orderBy?: OperationLogOrderByWithRelationInput | OperationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OperationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OperationLogs
    **/
    _count?: true | OperationLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperationLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperationLogMaxAggregateInputType
  }

  export type GetOperationLogAggregateType<T extends OperationLogAggregateArgs> = {
        [P in keyof T & keyof AggregateOperationLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperationLog[P]>
      : GetScalarType<T[P], AggregateOperationLog[P]>
  }




  export type OperationLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperationLogWhereInput
    orderBy?: OperationLogOrderByWithAggregationInput | OperationLogOrderByWithAggregationInput[]
    by: OperationLogScalarFieldEnum[] | OperationLogScalarFieldEnum
    having?: OperationLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperationLogCountAggregateInputType | true
    _min?: OperationLogMinAggregateInputType
    _max?: OperationLogMaxAggregateInputType
  }

  export type OperationLogGroupByOutputType = {
    id: string
    userId: string
    operationType: string
    targetType: string
    targetId: string | null
    description: string
    details: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: OperationLogCountAggregateOutputType | null
    _min: OperationLogMinAggregateOutputType | null
    _max: OperationLogMaxAggregateOutputType | null
  }

  type GetOperationLogGroupByPayload<T extends OperationLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OperationLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperationLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperationLogGroupByOutputType[P]>
            : GetScalarType<T[P], OperationLogGroupByOutputType[P]>
        }
      >
    >


  export type OperationLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    operationType?: boolean
    targetType?: boolean
    targetId?: boolean
    description?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operationLog"]>


  export type OperationLogSelectScalar = {
    id?: boolean
    userId?: boolean
    operationType?: boolean
    targetType?: boolean
    targetId?: boolean
    description?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type OperationLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OperationLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OperationLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      operationType: string
      targetType: string
      targetId: string | null
      description: string
      details: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["operationLog"]>
    composites: {}
  }

  type OperationLogGetPayload<S extends boolean | null | undefined | OperationLogDefaultArgs> = $Result.GetResult<Prisma.$OperationLogPayload, S>

  type OperationLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OperationLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OperationLogCountAggregateInputType | true
    }

  export interface OperationLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OperationLog'], meta: { name: 'OperationLog' } }
    /**
     * Find zero or one OperationLog that matches the filter.
     * @param {OperationLogFindUniqueArgs} args - Arguments to find a OperationLog
     * @example
     * // Get one OperationLog
     * const operationLog = await prisma.operationLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OperationLogFindUniqueArgs>(args: SelectSubset<T, OperationLogFindUniqueArgs<ExtArgs>>): Prisma__OperationLogClient<$Result.GetResult<Prisma.$OperationLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OperationLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OperationLogFindUniqueOrThrowArgs} args - Arguments to find a OperationLog
     * @example
     * // Get one OperationLog
     * const operationLog = await prisma.operationLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OperationLogFindUniqueOrThrowArgs>(args: SelectSubset<T, OperationLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OperationLogClient<$Result.GetResult<Prisma.$OperationLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OperationLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationLogFindFirstArgs} args - Arguments to find a OperationLog
     * @example
     * // Get one OperationLog
     * const operationLog = await prisma.operationLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OperationLogFindFirstArgs>(args?: SelectSubset<T, OperationLogFindFirstArgs<ExtArgs>>): Prisma__OperationLogClient<$Result.GetResult<Prisma.$OperationLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OperationLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationLogFindFirstOrThrowArgs} args - Arguments to find a OperationLog
     * @example
     * // Get one OperationLog
     * const operationLog = await prisma.operationLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OperationLogFindFirstOrThrowArgs>(args?: SelectSubset<T, OperationLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__OperationLogClient<$Result.GetResult<Prisma.$OperationLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OperationLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OperationLogs
     * const operationLogs = await prisma.operationLog.findMany()
     * 
     * // Get first 10 OperationLogs
     * const operationLogs = await prisma.operationLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operationLogWithIdOnly = await prisma.operationLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OperationLogFindManyArgs>(args?: SelectSubset<T, OperationLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OperationLog.
     * @param {OperationLogCreateArgs} args - Arguments to create a OperationLog.
     * @example
     * // Create one OperationLog
     * const OperationLog = await prisma.operationLog.create({
     *   data: {
     *     // ... data to create a OperationLog
     *   }
     * })
     * 
     */
    create<T extends OperationLogCreateArgs>(args: SelectSubset<T, OperationLogCreateArgs<ExtArgs>>): Prisma__OperationLogClient<$Result.GetResult<Prisma.$OperationLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OperationLogs.
     * @param {OperationLogCreateManyArgs} args - Arguments to create many OperationLogs.
     * @example
     * // Create many OperationLogs
     * const operationLog = await prisma.operationLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OperationLogCreateManyArgs>(args?: SelectSubset<T, OperationLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OperationLog.
     * @param {OperationLogDeleteArgs} args - Arguments to delete one OperationLog.
     * @example
     * // Delete one OperationLog
     * const OperationLog = await prisma.operationLog.delete({
     *   where: {
     *     // ... filter to delete one OperationLog
     *   }
     * })
     * 
     */
    delete<T extends OperationLogDeleteArgs>(args: SelectSubset<T, OperationLogDeleteArgs<ExtArgs>>): Prisma__OperationLogClient<$Result.GetResult<Prisma.$OperationLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OperationLog.
     * @param {OperationLogUpdateArgs} args - Arguments to update one OperationLog.
     * @example
     * // Update one OperationLog
     * const operationLog = await prisma.operationLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OperationLogUpdateArgs>(args: SelectSubset<T, OperationLogUpdateArgs<ExtArgs>>): Prisma__OperationLogClient<$Result.GetResult<Prisma.$OperationLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OperationLogs.
     * @param {OperationLogDeleteManyArgs} args - Arguments to filter OperationLogs to delete.
     * @example
     * // Delete a few OperationLogs
     * const { count } = await prisma.operationLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OperationLogDeleteManyArgs>(args?: SelectSubset<T, OperationLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OperationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OperationLogs
     * const operationLog = await prisma.operationLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OperationLogUpdateManyArgs>(args: SelectSubset<T, OperationLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OperationLog.
     * @param {OperationLogUpsertArgs} args - Arguments to update or create a OperationLog.
     * @example
     * // Update or create a OperationLog
     * const operationLog = await prisma.operationLog.upsert({
     *   create: {
     *     // ... data to create a OperationLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OperationLog we want to update
     *   }
     * })
     */
    upsert<T extends OperationLogUpsertArgs>(args: SelectSubset<T, OperationLogUpsertArgs<ExtArgs>>): Prisma__OperationLogClient<$Result.GetResult<Prisma.$OperationLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OperationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationLogCountArgs} args - Arguments to filter OperationLogs to count.
     * @example
     * // Count the number of OperationLogs
     * const count = await prisma.operationLog.count({
     *   where: {
     *     // ... the filter for the OperationLogs we want to count
     *   }
     * })
    **/
    count<T extends OperationLogCountArgs>(
      args?: Subset<T, OperationLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperationLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OperationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperationLogAggregateArgs>(args: Subset<T, OperationLogAggregateArgs>): Prisma.PrismaPromise<GetOperationLogAggregateType<T>>

    /**
     * Group by OperationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OperationLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OperationLogGroupByArgs['orderBy'] }
        : { orderBy?: OperationLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OperationLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperationLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OperationLog model
   */
  readonly fields: OperationLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OperationLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OperationLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OperationLog model
   */ 
  interface OperationLogFieldRefs {
    readonly id: FieldRef<"OperationLog", 'String'>
    readonly userId: FieldRef<"OperationLog", 'String'>
    readonly operationType: FieldRef<"OperationLog", 'String'>
    readonly targetType: FieldRef<"OperationLog", 'String'>
    readonly targetId: FieldRef<"OperationLog", 'String'>
    readonly description: FieldRef<"OperationLog", 'String'>
    readonly details: FieldRef<"OperationLog", 'Json'>
    readonly ipAddress: FieldRef<"OperationLog", 'String'>
    readonly userAgent: FieldRef<"OperationLog", 'String'>
    readonly createdAt: FieldRef<"OperationLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OperationLog findUnique
   */
  export type OperationLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationLog
     */
    select?: OperationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationLogInclude<ExtArgs> | null
    /**
     * Filter, which OperationLog to fetch.
     */
    where: OperationLogWhereUniqueInput
  }

  /**
   * OperationLog findUniqueOrThrow
   */
  export type OperationLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationLog
     */
    select?: OperationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationLogInclude<ExtArgs> | null
    /**
     * Filter, which OperationLog to fetch.
     */
    where: OperationLogWhereUniqueInput
  }

  /**
   * OperationLog findFirst
   */
  export type OperationLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationLog
     */
    select?: OperationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationLogInclude<ExtArgs> | null
    /**
     * Filter, which OperationLog to fetch.
     */
    where?: OperationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationLogs to fetch.
     */
    orderBy?: OperationLogOrderByWithRelationInput | OperationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperationLogs.
     */
    cursor?: OperationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperationLogs.
     */
    distinct?: OperationLogScalarFieldEnum | OperationLogScalarFieldEnum[]
  }

  /**
   * OperationLog findFirstOrThrow
   */
  export type OperationLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationLog
     */
    select?: OperationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationLogInclude<ExtArgs> | null
    /**
     * Filter, which OperationLog to fetch.
     */
    where?: OperationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationLogs to fetch.
     */
    orderBy?: OperationLogOrderByWithRelationInput | OperationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperationLogs.
     */
    cursor?: OperationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperationLogs.
     */
    distinct?: OperationLogScalarFieldEnum | OperationLogScalarFieldEnum[]
  }

  /**
   * OperationLog findMany
   */
  export type OperationLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationLog
     */
    select?: OperationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationLogInclude<ExtArgs> | null
    /**
     * Filter, which OperationLogs to fetch.
     */
    where?: OperationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationLogs to fetch.
     */
    orderBy?: OperationLogOrderByWithRelationInput | OperationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OperationLogs.
     */
    cursor?: OperationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationLogs.
     */
    skip?: number
    distinct?: OperationLogScalarFieldEnum | OperationLogScalarFieldEnum[]
  }

  /**
   * OperationLog create
   */
  export type OperationLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationLog
     */
    select?: OperationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationLogInclude<ExtArgs> | null
    /**
     * The data needed to create a OperationLog.
     */
    data: XOR<OperationLogCreateInput, OperationLogUncheckedCreateInput>
  }

  /**
   * OperationLog createMany
   */
  export type OperationLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OperationLogs.
     */
    data: OperationLogCreateManyInput | OperationLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OperationLog update
   */
  export type OperationLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationLog
     */
    select?: OperationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationLogInclude<ExtArgs> | null
    /**
     * The data needed to update a OperationLog.
     */
    data: XOR<OperationLogUpdateInput, OperationLogUncheckedUpdateInput>
    /**
     * Choose, which OperationLog to update.
     */
    where: OperationLogWhereUniqueInput
  }

  /**
   * OperationLog updateMany
   */
  export type OperationLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OperationLogs.
     */
    data: XOR<OperationLogUpdateManyMutationInput, OperationLogUncheckedUpdateManyInput>
    /**
     * Filter which OperationLogs to update
     */
    where?: OperationLogWhereInput
  }

  /**
   * OperationLog upsert
   */
  export type OperationLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationLog
     */
    select?: OperationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationLogInclude<ExtArgs> | null
    /**
     * The filter to search for the OperationLog to update in case it exists.
     */
    where: OperationLogWhereUniqueInput
    /**
     * In case the OperationLog found by the `where` argument doesn't exist, create a new OperationLog with this data.
     */
    create: XOR<OperationLogCreateInput, OperationLogUncheckedCreateInput>
    /**
     * In case the OperationLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OperationLogUpdateInput, OperationLogUncheckedUpdateInput>
  }

  /**
   * OperationLog delete
   */
  export type OperationLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationLog
     */
    select?: OperationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationLogInclude<ExtArgs> | null
    /**
     * Filter which OperationLog to delete.
     */
    where: OperationLogWhereUniqueInput
  }

  /**
   * OperationLog deleteMany
   */
  export type OperationLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperationLogs to delete
     */
    where?: OperationLogWhereInput
  }

  /**
   * OperationLog without action
   */
  export type OperationLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationLog
     */
    select?: OperationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationLogInclude<ExtArgs> | null
  }


  /**
   * Model Media
   */

  export type AggregateMedia = {
    _count: MediaCountAggregateOutputType | null
    _avg: MediaAvgAggregateOutputType | null
    _sum: MediaSumAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  export type MediaAvgAggregateOutputType = {
    size: number | null
    width: number | null
    height: number | null
  }

  export type MediaSumAggregateOutputType = {
    size: number | null
    width: number | null
    height: number | null
  }

  export type MediaMinAggregateOutputType = {
    id: string | null
    name: string | null
    originalName: string | null
    path: string | null
    url: string | null
    mimeType: string | null
    size: number | null
    width: number | null
    height: number | null
    storageType: $Enums.StorageType | null
    bucket: string | null
    uploadedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MediaMaxAggregateOutputType = {
    id: string | null
    name: string | null
    originalName: string | null
    path: string | null
    url: string | null
    mimeType: string | null
    size: number | null
    width: number | null
    height: number | null
    storageType: $Enums.StorageType | null
    bucket: string | null
    uploadedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MediaCountAggregateOutputType = {
    id: number
    name: number
    originalName: number
    path: number
    url: number
    mimeType: number
    size: number
    width: number
    height: number
    storageType: number
    bucket: number
    uploadedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MediaAvgAggregateInputType = {
    size?: true
    width?: true
    height?: true
  }

  export type MediaSumAggregateInputType = {
    size?: true
    width?: true
    height?: true
  }

  export type MediaMinAggregateInputType = {
    id?: true
    name?: true
    originalName?: true
    path?: true
    url?: true
    mimeType?: true
    size?: true
    width?: true
    height?: true
    storageType?: true
    bucket?: true
    uploadedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MediaMaxAggregateInputType = {
    id?: true
    name?: true
    originalName?: true
    path?: true
    url?: true
    mimeType?: true
    size?: true
    width?: true
    height?: true
    storageType?: true
    bucket?: true
    uploadedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MediaCountAggregateInputType = {
    id?: true
    name?: true
    originalName?: true
    path?: true
    url?: true
    mimeType?: true
    size?: true
    width?: true
    height?: true
    storageType?: true
    bucket?: true
    uploadedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to aggregate.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Media
    **/
    _count?: true | MediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MediaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MediaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaMaxAggregateInputType
  }

  export type GetMediaAggregateType<T extends MediaAggregateArgs> = {
        [P in keyof T & keyof AggregateMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedia[P]>
      : GetScalarType<T[P], AggregateMedia[P]>
  }




  export type MediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithAggregationInput | MediaOrderByWithAggregationInput[]
    by: MediaScalarFieldEnum[] | MediaScalarFieldEnum
    having?: MediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaCountAggregateInputType | true
    _avg?: MediaAvgAggregateInputType
    _sum?: MediaSumAggregateInputType
    _min?: MediaMinAggregateInputType
    _max?: MediaMaxAggregateInputType
  }

  export type MediaGroupByOutputType = {
    id: string
    name: string
    originalName: string
    path: string
    url: string
    mimeType: string
    size: number
    width: number | null
    height: number | null
    storageType: $Enums.StorageType
    bucket: string | null
    uploadedById: string
    createdAt: Date
    updatedAt: Date
    _count: MediaCountAggregateOutputType | null
    _avg: MediaAvgAggregateOutputType | null
    _sum: MediaSumAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  type GetMediaGroupByPayload<T extends MediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaGroupByOutputType[P]>
            : GetScalarType<T[P], MediaGroupByOutputType[P]>
        }
      >
    >


  export type MediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    originalName?: boolean
    path?: boolean
    url?: boolean
    mimeType?: boolean
    size?: boolean
    width?: boolean
    height?: boolean
    storageType?: boolean
    bucket?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>


  export type MediaSelectScalar = {
    id?: boolean
    name?: boolean
    originalName?: boolean
    path?: boolean
    url?: boolean
    mimeType?: boolean
    size?: boolean
    width?: boolean
    height?: boolean
    storageType?: boolean
    bucket?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Media"
    objects: {
      uploadedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      originalName: string
      path: string
      url: string
      mimeType: string
      size: number
      width: number | null
      height: number | null
      storageType: $Enums.StorageType
      bucket: string | null
      uploadedById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["media"]>
    composites: {}
  }

  type MediaGetPayload<S extends boolean | null | undefined | MediaDefaultArgs> = $Result.GetResult<Prisma.$MediaPayload, S>

  type MediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MediaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MediaCountAggregateInputType | true
    }

  export interface MediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Media'], meta: { name: 'Media' } }
    /**
     * Find zero or one Media that matches the filter.
     * @param {MediaFindUniqueArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaFindUniqueArgs>(args: SelectSubset<T, MediaFindUniqueArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Media that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MediaFindUniqueOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaFindFirstArgs>(args?: SelectSubset<T, MediaFindFirstArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Media that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Media
     * const media = await prisma.media.findMany()
     * 
     * // Get first 10 Media
     * const media = await prisma.media.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaWithIdOnly = await prisma.media.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaFindManyArgs>(args?: SelectSubset<T, MediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Media.
     * @param {MediaCreateArgs} args - Arguments to create a Media.
     * @example
     * // Create one Media
     * const Media = await prisma.media.create({
     *   data: {
     *     // ... data to create a Media
     *   }
     * })
     * 
     */
    create<T extends MediaCreateArgs>(args: SelectSubset<T, MediaCreateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Media.
     * @param {MediaCreateManyArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaCreateManyArgs>(args?: SelectSubset<T, MediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Media.
     * @param {MediaDeleteArgs} args - Arguments to delete one Media.
     * @example
     * // Delete one Media
     * const Media = await prisma.media.delete({
     *   where: {
     *     // ... filter to delete one Media
     *   }
     * })
     * 
     */
    delete<T extends MediaDeleteArgs>(args: SelectSubset<T, MediaDeleteArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Media.
     * @param {MediaUpdateArgs} args - Arguments to update one Media.
     * @example
     * // Update one Media
     * const media = await prisma.media.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaUpdateArgs>(args: SelectSubset<T, MediaUpdateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Media.
     * @param {MediaDeleteManyArgs} args - Arguments to filter Media to delete.
     * @example
     * // Delete a few Media
     * const { count } = await prisma.media.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaDeleteManyArgs>(args?: SelectSubset<T, MediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaUpdateManyArgs>(args: SelectSubset<T, MediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Media.
     * @param {MediaUpsertArgs} args - Arguments to update or create a Media.
     * @example
     * // Update or create a Media
     * const media = await prisma.media.upsert({
     *   create: {
     *     // ... data to create a Media
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Media we want to update
     *   }
     * })
     */
    upsert<T extends MediaUpsertArgs>(args: SelectSubset<T, MediaUpsertArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaCountArgs} args - Arguments to filter Media to count.
     * @example
     * // Count the number of Media
     * const count = await prisma.media.count({
     *   where: {
     *     // ... the filter for the Media we want to count
     *   }
     * })
    **/
    count<T extends MediaCountArgs>(
      args?: Subset<T, MediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaAggregateArgs>(args: Subset<T, MediaAggregateArgs>): Prisma.PrismaPromise<GetMediaAggregateType<T>>

    /**
     * Group by Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaGroupByArgs['orderBy'] }
        : { orderBy?: MediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Media model
   */
  readonly fields: MediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Media.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    uploadedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Media model
   */ 
  interface MediaFieldRefs {
    readonly id: FieldRef<"Media", 'String'>
    readonly name: FieldRef<"Media", 'String'>
    readonly originalName: FieldRef<"Media", 'String'>
    readonly path: FieldRef<"Media", 'String'>
    readonly url: FieldRef<"Media", 'String'>
    readonly mimeType: FieldRef<"Media", 'String'>
    readonly size: FieldRef<"Media", 'Int'>
    readonly width: FieldRef<"Media", 'Int'>
    readonly height: FieldRef<"Media", 'Int'>
    readonly storageType: FieldRef<"Media", 'StorageType'>
    readonly bucket: FieldRef<"Media", 'String'>
    readonly uploadedById: FieldRef<"Media", 'String'>
    readonly createdAt: FieldRef<"Media", 'DateTime'>
    readonly updatedAt: FieldRef<"Media", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Media findUnique
   */
  export type MediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findUniqueOrThrow
   */
  export type MediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findFirst
   */
  export type MediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findFirstOrThrow
   */
  export type MediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findMany
   */
  export type MediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media create
   */
  export type MediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to create a Media.
     */
    data: XOR<MediaCreateInput, MediaUncheckedCreateInput>
  }

  /**
   * Media createMany
   */
  export type MediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Media update
   */
  export type MediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to update a Media.
     */
    data: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
    /**
     * Choose, which Media to update.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media updateMany
   */
  export type MediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Media.
     */
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyInput>
    /**
     * Filter which Media to update
     */
    where?: MediaWhereInput
  }

  /**
   * Media upsert
   */
  export type MediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The filter to search for the Media to update in case it exists.
     */
    where: MediaWhereUniqueInput
    /**
     * In case the Media found by the `where` argument doesn't exist, create a new Media with this data.
     */
    create: XOR<MediaCreateInput, MediaUncheckedCreateInput>
    /**
     * In case the Media was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
  }

  /**
   * Media delete
   */
  export type MediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter which Media to delete.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media deleteMany
   */
  export type MediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to delete
     */
    where?: MediaWhereInput
  }

  /**
   * Media without action
   */
  export type MediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
  }


  /**
   * Model StorageConfig
   */

  export type AggregateStorageConfig = {
    _count: StorageConfigCountAggregateOutputType | null
    _avg: StorageConfigAvgAggregateOutputType | null
    _sum: StorageConfigSumAggregateOutputType | null
    _min: StorageConfigMinAggregateOutputType | null
    _max: StorageConfigMaxAggregateOutputType | null
  }

  export type StorageConfigAvgAggregateOutputType = {
    maxFileSize: number | null
  }

  export type StorageConfigSumAggregateOutputType = {
    maxFileSize: number | null
  }

  export type StorageConfigMinAggregateOutputType = {
    id: string | null
    type: $Enums.StorageType | null
    name: string | null
    isEnabled: boolean | null
    isDefault: boolean | null
    accessKeyId: string | null
    accessKeySecret: string | null
    endpoint: string | null
    bucket: string | null
    region: string | null
    awsAccessKeyId: string | null
    awsSecretAccessKey: string | null
    awsRegion: string | null
    awsBucket: string | null
    baseUrl: string | null
    maxFileSize: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StorageConfigMaxAggregateOutputType = {
    id: string | null
    type: $Enums.StorageType | null
    name: string | null
    isEnabled: boolean | null
    isDefault: boolean | null
    accessKeyId: string | null
    accessKeySecret: string | null
    endpoint: string | null
    bucket: string | null
    region: string | null
    awsAccessKeyId: string | null
    awsSecretAccessKey: string | null
    awsRegion: string | null
    awsBucket: string | null
    baseUrl: string | null
    maxFileSize: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StorageConfigCountAggregateOutputType = {
    id: number
    type: number
    name: number
    isEnabled: number
    isDefault: number
    accessKeyId: number
    accessKeySecret: number
    endpoint: number
    bucket: number
    region: number
    awsAccessKeyId: number
    awsSecretAccessKey: number
    awsRegion: number
    awsBucket: number
    baseUrl: number
    maxFileSize: number
    allowedMimeTypes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StorageConfigAvgAggregateInputType = {
    maxFileSize?: true
  }

  export type StorageConfigSumAggregateInputType = {
    maxFileSize?: true
  }

  export type StorageConfigMinAggregateInputType = {
    id?: true
    type?: true
    name?: true
    isEnabled?: true
    isDefault?: true
    accessKeyId?: true
    accessKeySecret?: true
    endpoint?: true
    bucket?: true
    region?: true
    awsAccessKeyId?: true
    awsSecretAccessKey?: true
    awsRegion?: true
    awsBucket?: true
    baseUrl?: true
    maxFileSize?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StorageConfigMaxAggregateInputType = {
    id?: true
    type?: true
    name?: true
    isEnabled?: true
    isDefault?: true
    accessKeyId?: true
    accessKeySecret?: true
    endpoint?: true
    bucket?: true
    region?: true
    awsAccessKeyId?: true
    awsSecretAccessKey?: true
    awsRegion?: true
    awsBucket?: true
    baseUrl?: true
    maxFileSize?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StorageConfigCountAggregateInputType = {
    id?: true
    type?: true
    name?: true
    isEnabled?: true
    isDefault?: true
    accessKeyId?: true
    accessKeySecret?: true
    endpoint?: true
    bucket?: true
    region?: true
    awsAccessKeyId?: true
    awsSecretAccessKey?: true
    awsRegion?: true
    awsBucket?: true
    baseUrl?: true
    maxFileSize?: true
    allowedMimeTypes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StorageConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StorageConfig to aggregate.
     */
    where?: StorageConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorageConfigs to fetch.
     */
    orderBy?: StorageConfigOrderByWithRelationInput | StorageConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StorageConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorageConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorageConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StorageConfigs
    **/
    _count?: true | StorageConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StorageConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StorageConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StorageConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StorageConfigMaxAggregateInputType
  }

  export type GetStorageConfigAggregateType<T extends StorageConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateStorageConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStorageConfig[P]>
      : GetScalarType<T[P], AggregateStorageConfig[P]>
  }




  export type StorageConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StorageConfigWhereInput
    orderBy?: StorageConfigOrderByWithAggregationInput | StorageConfigOrderByWithAggregationInput[]
    by: StorageConfigScalarFieldEnum[] | StorageConfigScalarFieldEnum
    having?: StorageConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StorageConfigCountAggregateInputType | true
    _avg?: StorageConfigAvgAggregateInputType
    _sum?: StorageConfigSumAggregateInputType
    _min?: StorageConfigMinAggregateInputType
    _max?: StorageConfigMaxAggregateInputType
  }

  export type StorageConfigGroupByOutputType = {
    id: string
    type: $Enums.StorageType
    name: string
    isEnabled: boolean
    isDefault: boolean
    accessKeyId: string | null
    accessKeySecret: string | null
    endpoint: string | null
    bucket: string | null
    region: string | null
    awsAccessKeyId: string | null
    awsSecretAccessKey: string | null
    awsRegion: string | null
    awsBucket: string | null
    baseUrl: string | null
    maxFileSize: number
    allowedMimeTypes: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: StorageConfigCountAggregateOutputType | null
    _avg: StorageConfigAvgAggregateOutputType | null
    _sum: StorageConfigSumAggregateOutputType | null
    _min: StorageConfigMinAggregateOutputType | null
    _max: StorageConfigMaxAggregateOutputType | null
  }

  type GetStorageConfigGroupByPayload<T extends StorageConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StorageConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StorageConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StorageConfigGroupByOutputType[P]>
            : GetScalarType<T[P], StorageConfigGroupByOutputType[P]>
        }
      >
    >


  export type StorageConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    isEnabled?: boolean
    isDefault?: boolean
    accessKeyId?: boolean
    accessKeySecret?: boolean
    endpoint?: boolean
    bucket?: boolean
    region?: boolean
    awsAccessKeyId?: boolean
    awsSecretAccessKey?: boolean
    awsRegion?: boolean
    awsBucket?: boolean
    baseUrl?: boolean
    maxFileSize?: boolean
    allowedMimeTypes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["storageConfig"]>


  export type StorageConfigSelectScalar = {
    id?: boolean
    type?: boolean
    name?: boolean
    isEnabled?: boolean
    isDefault?: boolean
    accessKeyId?: boolean
    accessKeySecret?: boolean
    endpoint?: boolean
    bucket?: boolean
    region?: boolean
    awsAccessKeyId?: boolean
    awsSecretAccessKey?: boolean
    awsRegion?: boolean
    awsBucket?: boolean
    baseUrl?: boolean
    maxFileSize?: boolean
    allowedMimeTypes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $StorageConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StorageConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.StorageType
      name: string
      isEnabled: boolean
      isDefault: boolean
      accessKeyId: string | null
      accessKeySecret: string | null
      endpoint: string | null
      bucket: string | null
      region: string | null
      awsAccessKeyId: string | null
      awsSecretAccessKey: string | null
      awsRegion: string | null
      awsBucket: string | null
      baseUrl: string | null
      maxFileSize: number
      allowedMimeTypes: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["storageConfig"]>
    composites: {}
  }

  type StorageConfigGetPayload<S extends boolean | null | undefined | StorageConfigDefaultArgs> = $Result.GetResult<Prisma.$StorageConfigPayload, S>

  type StorageConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StorageConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StorageConfigCountAggregateInputType | true
    }

  export interface StorageConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StorageConfig'], meta: { name: 'StorageConfig' } }
    /**
     * Find zero or one StorageConfig that matches the filter.
     * @param {StorageConfigFindUniqueArgs} args - Arguments to find a StorageConfig
     * @example
     * // Get one StorageConfig
     * const storageConfig = await prisma.storageConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StorageConfigFindUniqueArgs>(args: SelectSubset<T, StorageConfigFindUniqueArgs<ExtArgs>>): Prisma__StorageConfigClient<$Result.GetResult<Prisma.$StorageConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StorageConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StorageConfigFindUniqueOrThrowArgs} args - Arguments to find a StorageConfig
     * @example
     * // Get one StorageConfig
     * const storageConfig = await prisma.storageConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StorageConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, StorageConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StorageConfigClient<$Result.GetResult<Prisma.$StorageConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StorageConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageConfigFindFirstArgs} args - Arguments to find a StorageConfig
     * @example
     * // Get one StorageConfig
     * const storageConfig = await prisma.storageConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StorageConfigFindFirstArgs>(args?: SelectSubset<T, StorageConfigFindFirstArgs<ExtArgs>>): Prisma__StorageConfigClient<$Result.GetResult<Prisma.$StorageConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StorageConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageConfigFindFirstOrThrowArgs} args - Arguments to find a StorageConfig
     * @example
     * // Get one StorageConfig
     * const storageConfig = await prisma.storageConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StorageConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, StorageConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__StorageConfigClient<$Result.GetResult<Prisma.$StorageConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StorageConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StorageConfigs
     * const storageConfigs = await prisma.storageConfig.findMany()
     * 
     * // Get first 10 StorageConfigs
     * const storageConfigs = await prisma.storageConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storageConfigWithIdOnly = await prisma.storageConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StorageConfigFindManyArgs>(args?: SelectSubset<T, StorageConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorageConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StorageConfig.
     * @param {StorageConfigCreateArgs} args - Arguments to create a StorageConfig.
     * @example
     * // Create one StorageConfig
     * const StorageConfig = await prisma.storageConfig.create({
     *   data: {
     *     // ... data to create a StorageConfig
     *   }
     * })
     * 
     */
    create<T extends StorageConfigCreateArgs>(args: SelectSubset<T, StorageConfigCreateArgs<ExtArgs>>): Prisma__StorageConfigClient<$Result.GetResult<Prisma.$StorageConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StorageConfigs.
     * @param {StorageConfigCreateManyArgs} args - Arguments to create many StorageConfigs.
     * @example
     * // Create many StorageConfigs
     * const storageConfig = await prisma.storageConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StorageConfigCreateManyArgs>(args?: SelectSubset<T, StorageConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StorageConfig.
     * @param {StorageConfigDeleteArgs} args - Arguments to delete one StorageConfig.
     * @example
     * // Delete one StorageConfig
     * const StorageConfig = await prisma.storageConfig.delete({
     *   where: {
     *     // ... filter to delete one StorageConfig
     *   }
     * })
     * 
     */
    delete<T extends StorageConfigDeleteArgs>(args: SelectSubset<T, StorageConfigDeleteArgs<ExtArgs>>): Prisma__StorageConfigClient<$Result.GetResult<Prisma.$StorageConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StorageConfig.
     * @param {StorageConfigUpdateArgs} args - Arguments to update one StorageConfig.
     * @example
     * // Update one StorageConfig
     * const storageConfig = await prisma.storageConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StorageConfigUpdateArgs>(args: SelectSubset<T, StorageConfigUpdateArgs<ExtArgs>>): Prisma__StorageConfigClient<$Result.GetResult<Prisma.$StorageConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StorageConfigs.
     * @param {StorageConfigDeleteManyArgs} args - Arguments to filter StorageConfigs to delete.
     * @example
     * // Delete a few StorageConfigs
     * const { count } = await prisma.storageConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StorageConfigDeleteManyArgs>(args?: SelectSubset<T, StorageConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StorageConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StorageConfigs
     * const storageConfig = await prisma.storageConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StorageConfigUpdateManyArgs>(args: SelectSubset<T, StorageConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StorageConfig.
     * @param {StorageConfigUpsertArgs} args - Arguments to update or create a StorageConfig.
     * @example
     * // Update or create a StorageConfig
     * const storageConfig = await prisma.storageConfig.upsert({
     *   create: {
     *     // ... data to create a StorageConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StorageConfig we want to update
     *   }
     * })
     */
    upsert<T extends StorageConfigUpsertArgs>(args: SelectSubset<T, StorageConfigUpsertArgs<ExtArgs>>): Prisma__StorageConfigClient<$Result.GetResult<Prisma.$StorageConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StorageConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageConfigCountArgs} args - Arguments to filter StorageConfigs to count.
     * @example
     * // Count the number of StorageConfigs
     * const count = await prisma.storageConfig.count({
     *   where: {
     *     // ... the filter for the StorageConfigs we want to count
     *   }
     * })
    **/
    count<T extends StorageConfigCountArgs>(
      args?: Subset<T, StorageConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StorageConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StorageConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StorageConfigAggregateArgs>(args: Subset<T, StorageConfigAggregateArgs>): Prisma.PrismaPromise<GetStorageConfigAggregateType<T>>

    /**
     * Group by StorageConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StorageConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StorageConfigGroupByArgs['orderBy'] }
        : { orderBy?: StorageConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StorageConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStorageConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StorageConfig model
   */
  readonly fields: StorageConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StorageConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StorageConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StorageConfig model
   */ 
  interface StorageConfigFieldRefs {
    readonly id: FieldRef<"StorageConfig", 'String'>
    readonly type: FieldRef<"StorageConfig", 'StorageType'>
    readonly name: FieldRef<"StorageConfig", 'String'>
    readonly isEnabled: FieldRef<"StorageConfig", 'Boolean'>
    readonly isDefault: FieldRef<"StorageConfig", 'Boolean'>
    readonly accessKeyId: FieldRef<"StorageConfig", 'String'>
    readonly accessKeySecret: FieldRef<"StorageConfig", 'String'>
    readonly endpoint: FieldRef<"StorageConfig", 'String'>
    readonly bucket: FieldRef<"StorageConfig", 'String'>
    readonly region: FieldRef<"StorageConfig", 'String'>
    readonly awsAccessKeyId: FieldRef<"StorageConfig", 'String'>
    readonly awsSecretAccessKey: FieldRef<"StorageConfig", 'String'>
    readonly awsRegion: FieldRef<"StorageConfig", 'String'>
    readonly awsBucket: FieldRef<"StorageConfig", 'String'>
    readonly baseUrl: FieldRef<"StorageConfig", 'String'>
    readonly maxFileSize: FieldRef<"StorageConfig", 'Int'>
    readonly allowedMimeTypes: FieldRef<"StorageConfig", 'Json'>
    readonly createdAt: FieldRef<"StorageConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"StorageConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StorageConfig findUnique
   */
  export type StorageConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageConfig
     */
    select?: StorageConfigSelect<ExtArgs> | null
    /**
     * Filter, which StorageConfig to fetch.
     */
    where: StorageConfigWhereUniqueInput
  }

  /**
   * StorageConfig findUniqueOrThrow
   */
  export type StorageConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageConfig
     */
    select?: StorageConfigSelect<ExtArgs> | null
    /**
     * Filter, which StorageConfig to fetch.
     */
    where: StorageConfigWhereUniqueInput
  }

  /**
   * StorageConfig findFirst
   */
  export type StorageConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageConfig
     */
    select?: StorageConfigSelect<ExtArgs> | null
    /**
     * Filter, which StorageConfig to fetch.
     */
    where?: StorageConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorageConfigs to fetch.
     */
    orderBy?: StorageConfigOrderByWithRelationInput | StorageConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StorageConfigs.
     */
    cursor?: StorageConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorageConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorageConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StorageConfigs.
     */
    distinct?: StorageConfigScalarFieldEnum | StorageConfigScalarFieldEnum[]
  }

  /**
   * StorageConfig findFirstOrThrow
   */
  export type StorageConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageConfig
     */
    select?: StorageConfigSelect<ExtArgs> | null
    /**
     * Filter, which StorageConfig to fetch.
     */
    where?: StorageConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorageConfigs to fetch.
     */
    orderBy?: StorageConfigOrderByWithRelationInput | StorageConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StorageConfigs.
     */
    cursor?: StorageConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorageConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorageConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StorageConfigs.
     */
    distinct?: StorageConfigScalarFieldEnum | StorageConfigScalarFieldEnum[]
  }

  /**
   * StorageConfig findMany
   */
  export type StorageConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageConfig
     */
    select?: StorageConfigSelect<ExtArgs> | null
    /**
     * Filter, which StorageConfigs to fetch.
     */
    where?: StorageConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorageConfigs to fetch.
     */
    orderBy?: StorageConfigOrderByWithRelationInput | StorageConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StorageConfigs.
     */
    cursor?: StorageConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorageConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorageConfigs.
     */
    skip?: number
    distinct?: StorageConfigScalarFieldEnum | StorageConfigScalarFieldEnum[]
  }

  /**
   * StorageConfig create
   */
  export type StorageConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageConfig
     */
    select?: StorageConfigSelect<ExtArgs> | null
    /**
     * The data needed to create a StorageConfig.
     */
    data: XOR<StorageConfigCreateInput, StorageConfigUncheckedCreateInput>
  }

  /**
   * StorageConfig createMany
   */
  export type StorageConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StorageConfigs.
     */
    data: StorageConfigCreateManyInput | StorageConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StorageConfig update
   */
  export type StorageConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageConfig
     */
    select?: StorageConfigSelect<ExtArgs> | null
    /**
     * The data needed to update a StorageConfig.
     */
    data: XOR<StorageConfigUpdateInput, StorageConfigUncheckedUpdateInput>
    /**
     * Choose, which StorageConfig to update.
     */
    where: StorageConfigWhereUniqueInput
  }

  /**
   * StorageConfig updateMany
   */
  export type StorageConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StorageConfigs.
     */
    data: XOR<StorageConfigUpdateManyMutationInput, StorageConfigUncheckedUpdateManyInput>
    /**
     * Filter which StorageConfigs to update
     */
    where?: StorageConfigWhereInput
  }

  /**
   * StorageConfig upsert
   */
  export type StorageConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageConfig
     */
    select?: StorageConfigSelect<ExtArgs> | null
    /**
     * The filter to search for the StorageConfig to update in case it exists.
     */
    where: StorageConfigWhereUniqueInput
    /**
     * In case the StorageConfig found by the `where` argument doesn't exist, create a new StorageConfig with this data.
     */
    create: XOR<StorageConfigCreateInput, StorageConfigUncheckedCreateInput>
    /**
     * In case the StorageConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StorageConfigUpdateInput, StorageConfigUncheckedUpdateInput>
  }

  /**
   * StorageConfig delete
   */
  export type StorageConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageConfig
     */
    select?: StorageConfigSelect<ExtArgs> | null
    /**
     * Filter which StorageConfig to delete.
     */
    where: StorageConfigWhereUniqueInput
  }

  /**
   * StorageConfig deleteMany
   */
  export type StorageConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StorageConfigs to delete
     */
    where?: StorageConfigWhereInput
  }

  /**
   * StorageConfig without action
   */
  export type StorageConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageConfig
     */
    select?: StorageConfigSelect<ExtArgs> | null
  }


  /**
   * Model Plugin
   */

  export type AggregatePlugin = {
    _count: PluginCountAggregateOutputType | null
    _avg: PluginAvgAggregateOutputType | null
    _sum: PluginSumAggregateOutputType | null
    _min: PluginMinAggregateOutputType | null
    _max: PluginMaxAggregateOutputType | null
  }

  export type PluginAvgAggregateOutputType = {
    price: number | null
    downloadCount: number | null
    rating: number | null
  }

  export type PluginSumAggregateOutputType = {
    price: number | null
    downloadCount: number | null
    rating: number | null
  }

  export type PluginMinAggregateOutputType = {
    id: string | null
    slug: string | null
    name: string | null
    description: string | null
    icon: string | null
    version: string | null
    author: string | null
    category: $Enums.PluginCategory | null
    price: number | null
    downloadCount: number | null
    rating: number | null
    isActive: boolean | null
    isFeatured: boolean | null
    documentation: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PluginMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    name: string | null
    description: string | null
    icon: string | null
    version: string | null
    author: string | null
    category: $Enums.PluginCategory | null
    price: number | null
    downloadCount: number | null
    rating: number | null
    isActive: boolean | null
    isFeatured: boolean | null
    documentation: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PluginCountAggregateOutputType = {
    id: number
    slug: number
    name: number
    description: number
    icon: number
    version: number
    author: number
    category: number
    price: number
    downloadCount: number
    rating: number
    isActive: number
    isFeatured: number
    config: number
    permissions: number
    dependencies: number
    changelog: number
    screenshots: number
    documentation: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PluginAvgAggregateInputType = {
    price?: true
    downloadCount?: true
    rating?: true
  }

  export type PluginSumAggregateInputType = {
    price?: true
    downloadCount?: true
    rating?: true
  }

  export type PluginMinAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    description?: true
    icon?: true
    version?: true
    author?: true
    category?: true
    price?: true
    downloadCount?: true
    rating?: true
    isActive?: true
    isFeatured?: true
    documentation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PluginMaxAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    description?: true
    icon?: true
    version?: true
    author?: true
    category?: true
    price?: true
    downloadCount?: true
    rating?: true
    isActive?: true
    isFeatured?: true
    documentation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PluginCountAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    description?: true
    icon?: true
    version?: true
    author?: true
    category?: true
    price?: true
    downloadCount?: true
    rating?: true
    isActive?: true
    isFeatured?: true
    config?: true
    permissions?: true
    dependencies?: true
    changelog?: true
    screenshots?: true
    documentation?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PluginAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plugin to aggregate.
     */
    where?: PluginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plugins to fetch.
     */
    orderBy?: PluginOrderByWithRelationInput | PluginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PluginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plugins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plugins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Plugins
    **/
    _count?: true | PluginCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PluginAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PluginSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PluginMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PluginMaxAggregateInputType
  }

  export type GetPluginAggregateType<T extends PluginAggregateArgs> = {
        [P in keyof T & keyof AggregatePlugin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlugin[P]>
      : GetScalarType<T[P], AggregatePlugin[P]>
  }




  export type PluginGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PluginWhereInput
    orderBy?: PluginOrderByWithAggregationInput | PluginOrderByWithAggregationInput[]
    by: PluginScalarFieldEnum[] | PluginScalarFieldEnum
    having?: PluginScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PluginCountAggregateInputType | true
    _avg?: PluginAvgAggregateInputType
    _sum?: PluginSumAggregateInputType
    _min?: PluginMinAggregateInputType
    _max?: PluginMaxAggregateInputType
  }

  export type PluginGroupByOutputType = {
    id: string
    slug: string
    name: string
    description: string | null
    icon: string | null
    version: string
    author: string | null
    category: $Enums.PluginCategory
    price: number
    downloadCount: number
    rating: number
    isActive: boolean
    isFeatured: boolean
    config: JsonValue | null
    permissions: JsonValue
    dependencies: JsonValue
    changelog: JsonValue | null
    screenshots: JsonValue
    documentation: string | null
    createdAt: Date
    updatedAt: Date
    _count: PluginCountAggregateOutputType | null
    _avg: PluginAvgAggregateOutputType | null
    _sum: PluginSumAggregateOutputType | null
    _min: PluginMinAggregateOutputType | null
    _max: PluginMaxAggregateOutputType | null
  }

  type GetPluginGroupByPayload<T extends PluginGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PluginGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PluginGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PluginGroupByOutputType[P]>
            : GetScalarType<T[P], PluginGroupByOutputType[P]>
        }
      >
    >


  export type PluginSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    version?: boolean
    author?: boolean
    category?: boolean
    price?: boolean
    downloadCount?: boolean
    rating?: boolean
    isActive?: boolean
    isFeatured?: boolean
    config?: boolean
    permissions?: boolean
    dependencies?: boolean
    changelog?: boolean
    screenshots?: boolean
    documentation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    installations?: boolean | Plugin$installationsArgs<ExtArgs>
    _count?: boolean | PluginCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plugin"]>


  export type PluginSelectScalar = {
    id?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    version?: boolean
    author?: boolean
    category?: boolean
    price?: boolean
    downloadCount?: boolean
    rating?: boolean
    isActive?: boolean
    isFeatured?: boolean
    config?: boolean
    permissions?: boolean
    dependencies?: boolean
    changelog?: boolean
    screenshots?: boolean
    documentation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PluginInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    installations?: boolean | Plugin$installationsArgs<ExtArgs>
    _count?: boolean | PluginCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PluginPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Plugin"
    objects: {
      installations: Prisma.$PluginInstallationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      name: string
      description: string | null
      icon: string | null
      version: string
      author: string | null
      category: $Enums.PluginCategory
      price: number
      downloadCount: number
      rating: number
      isActive: boolean
      isFeatured: boolean
      config: Prisma.JsonValue | null
      permissions: Prisma.JsonValue
      dependencies: Prisma.JsonValue
      changelog: Prisma.JsonValue | null
      screenshots: Prisma.JsonValue
      documentation: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["plugin"]>
    composites: {}
  }

  type PluginGetPayload<S extends boolean | null | undefined | PluginDefaultArgs> = $Result.GetResult<Prisma.$PluginPayload, S>

  type PluginCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PluginFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PluginCountAggregateInputType | true
    }

  export interface PluginDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Plugin'], meta: { name: 'Plugin' } }
    /**
     * Find zero or one Plugin that matches the filter.
     * @param {PluginFindUniqueArgs} args - Arguments to find a Plugin
     * @example
     * // Get one Plugin
     * const plugin = await prisma.plugin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PluginFindUniqueArgs>(args: SelectSubset<T, PluginFindUniqueArgs<ExtArgs>>): Prisma__PluginClient<$Result.GetResult<Prisma.$PluginPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Plugin that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PluginFindUniqueOrThrowArgs} args - Arguments to find a Plugin
     * @example
     * // Get one Plugin
     * const plugin = await prisma.plugin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PluginFindUniqueOrThrowArgs>(args: SelectSubset<T, PluginFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PluginClient<$Result.GetResult<Prisma.$PluginPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Plugin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginFindFirstArgs} args - Arguments to find a Plugin
     * @example
     * // Get one Plugin
     * const plugin = await prisma.plugin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PluginFindFirstArgs>(args?: SelectSubset<T, PluginFindFirstArgs<ExtArgs>>): Prisma__PluginClient<$Result.GetResult<Prisma.$PluginPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Plugin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginFindFirstOrThrowArgs} args - Arguments to find a Plugin
     * @example
     * // Get one Plugin
     * const plugin = await prisma.plugin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PluginFindFirstOrThrowArgs>(args?: SelectSubset<T, PluginFindFirstOrThrowArgs<ExtArgs>>): Prisma__PluginClient<$Result.GetResult<Prisma.$PluginPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Plugins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plugins
     * const plugins = await prisma.plugin.findMany()
     * 
     * // Get first 10 Plugins
     * const plugins = await prisma.plugin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pluginWithIdOnly = await prisma.plugin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PluginFindManyArgs>(args?: SelectSubset<T, PluginFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PluginPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Plugin.
     * @param {PluginCreateArgs} args - Arguments to create a Plugin.
     * @example
     * // Create one Plugin
     * const Plugin = await prisma.plugin.create({
     *   data: {
     *     // ... data to create a Plugin
     *   }
     * })
     * 
     */
    create<T extends PluginCreateArgs>(args: SelectSubset<T, PluginCreateArgs<ExtArgs>>): Prisma__PluginClient<$Result.GetResult<Prisma.$PluginPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Plugins.
     * @param {PluginCreateManyArgs} args - Arguments to create many Plugins.
     * @example
     * // Create many Plugins
     * const plugin = await prisma.plugin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PluginCreateManyArgs>(args?: SelectSubset<T, PluginCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Plugin.
     * @param {PluginDeleteArgs} args - Arguments to delete one Plugin.
     * @example
     * // Delete one Plugin
     * const Plugin = await prisma.plugin.delete({
     *   where: {
     *     // ... filter to delete one Plugin
     *   }
     * })
     * 
     */
    delete<T extends PluginDeleteArgs>(args: SelectSubset<T, PluginDeleteArgs<ExtArgs>>): Prisma__PluginClient<$Result.GetResult<Prisma.$PluginPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Plugin.
     * @param {PluginUpdateArgs} args - Arguments to update one Plugin.
     * @example
     * // Update one Plugin
     * const plugin = await prisma.plugin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PluginUpdateArgs>(args: SelectSubset<T, PluginUpdateArgs<ExtArgs>>): Prisma__PluginClient<$Result.GetResult<Prisma.$PluginPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Plugins.
     * @param {PluginDeleteManyArgs} args - Arguments to filter Plugins to delete.
     * @example
     * // Delete a few Plugins
     * const { count } = await prisma.plugin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PluginDeleteManyArgs>(args?: SelectSubset<T, PluginDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plugins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plugins
     * const plugin = await prisma.plugin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PluginUpdateManyArgs>(args: SelectSubset<T, PluginUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Plugin.
     * @param {PluginUpsertArgs} args - Arguments to update or create a Plugin.
     * @example
     * // Update or create a Plugin
     * const plugin = await prisma.plugin.upsert({
     *   create: {
     *     // ... data to create a Plugin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plugin we want to update
     *   }
     * })
     */
    upsert<T extends PluginUpsertArgs>(args: SelectSubset<T, PluginUpsertArgs<ExtArgs>>): Prisma__PluginClient<$Result.GetResult<Prisma.$PluginPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Plugins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginCountArgs} args - Arguments to filter Plugins to count.
     * @example
     * // Count the number of Plugins
     * const count = await prisma.plugin.count({
     *   where: {
     *     // ... the filter for the Plugins we want to count
     *   }
     * })
    **/
    count<T extends PluginCountArgs>(
      args?: Subset<T, PluginCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PluginCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plugin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PluginAggregateArgs>(args: Subset<T, PluginAggregateArgs>): Prisma.PrismaPromise<GetPluginAggregateType<T>>

    /**
     * Group by Plugin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PluginGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PluginGroupByArgs['orderBy'] }
        : { orderBy?: PluginGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PluginGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPluginGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Plugin model
   */
  readonly fields: PluginFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Plugin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PluginClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    installations<T extends Plugin$installationsArgs<ExtArgs> = {}>(args?: Subset<T, Plugin$installationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PluginInstallationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Plugin model
   */ 
  interface PluginFieldRefs {
    readonly id: FieldRef<"Plugin", 'String'>
    readonly slug: FieldRef<"Plugin", 'String'>
    readonly name: FieldRef<"Plugin", 'String'>
    readonly description: FieldRef<"Plugin", 'String'>
    readonly icon: FieldRef<"Plugin", 'String'>
    readonly version: FieldRef<"Plugin", 'String'>
    readonly author: FieldRef<"Plugin", 'String'>
    readonly category: FieldRef<"Plugin", 'PluginCategory'>
    readonly price: FieldRef<"Plugin", 'Float'>
    readonly downloadCount: FieldRef<"Plugin", 'Int'>
    readonly rating: FieldRef<"Plugin", 'Float'>
    readonly isActive: FieldRef<"Plugin", 'Boolean'>
    readonly isFeatured: FieldRef<"Plugin", 'Boolean'>
    readonly config: FieldRef<"Plugin", 'Json'>
    readonly permissions: FieldRef<"Plugin", 'Json'>
    readonly dependencies: FieldRef<"Plugin", 'Json'>
    readonly changelog: FieldRef<"Plugin", 'Json'>
    readonly screenshots: FieldRef<"Plugin", 'Json'>
    readonly documentation: FieldRef<"Plugin", 'String'>
    readonly createdAt: FieldRef<"Plugin", 'DateTime'>
    readonly updatedAt: FieldRef<"Plugin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Plugin findUnique
   */
  export type PluginFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plugin
     */
    select?: PluginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInclude<ExtArgs> | null
    /**
     * Filter, which Plugin to fetch.
     */
    where: PluginWhereUniqueInput
  }

  /**
   * Plugin findUniqueOrThrow
   */
  export type PluginFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plugin
     */
    select?: PluginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInclude<ExtArgs> | null
    /**
     * Filter, which Plugin to fetch.
     */
    where: PluginWhereUniqueInput
  }

  /**
   * Plugin findFirst
   */
  export type PluginFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plugin
     */
    select?: PluginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInclude<ExtArgs> | null
    /**
     * Filter, which Plugin to fetch.
     */
    where?: PluginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plugins to fetch.
     */
    orderBy?: PluginOrderByWithRelationInput | PluginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plugins.
     */
    cursor?: PluginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plugins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plugins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plugins.
     */
    distinct?: PluginScalarFieldEnum | PluginScalarFieldEnum[]
  }

  /**
   * Plugin findFirstOrThrow
   */
  export type PluginFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plugin
     */
    select?: PluginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInclude<ExtArgs> | null
    /**
     * Filter, which Plugin to fetch.
     */
    where?: PluginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plugins to fetch.
     */
    orderBy?: PluginOrderByWithRelationInput | PluginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plugins.
     */
    cursor?: PluginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plugins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plugins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plugins.
     */
    distinct?: PluginScalarFieldEnum | PluginScalarFieldEnum[]
  }

  /**
   * Plugin findMany
   */
  export type PluginFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plugin
     */
    select?: PluginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInclude<ExtArgs> | null
    /**
     * Filter, which Plugins to fetch.
     */
    where?: PluginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plugins to fetch.
     */
    orderBy?: PluginOrderByWithRelationInput | PluginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Plugins.
     */
    cursor?: PluginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plugins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plugins.
     */
    skip?: number
    distinct?: PluginScalarFieldEnum | PluginScalarFieldEnum[]
  }

  /**
   * Plugin create
   */
  export type PluginCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plugin
     */
    select?: PluginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInclude<ExtArgs> | null
    /**
     * The data needed to create a Plugin.
     */
    data: XOR<PluginCreateInput, PluginUncheckedCreateInput>
  }

  /**
   * Plugin createMany
   */
  export type PluginCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Plugins.
     */
    data: PluginCreateManyInput | PluginCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plugin update
   */
  export type PluginUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plugin
     */
    select?: PluginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInclude<ExtArgs> | null
    /**
     * The data needed to update a Plugin.
     */
    data: XOR<PluginUpdateInput, PluginUncheckedUpdateInput>
    /**
     * Choose, which Plugin to update.
     */
    where: PluginWhereUniqueInput
  }

  /**
   * Plugin updateMany
   */
  export type PluginUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Plugins.
     */
    data: XOR<PluginUpdateManyMutationInput, PluginUncheckedUpdateManyInput>
    /**
     * Filter which Plugins to update
     */
    where?: PluginWhereInput
  }

  /**
   * Plugin upsert
   */
  export type PluginUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plugin
     */
    select?: PluginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInclude<ExtArgs> | null
    /**
     * The filter to search for the Plugin to update in case it exists.
     */
    where: PluginWhereUniqueInput
    /**
     * In case the Plugin found by the `where` argument doesn't exist, create a new Plugin with this data.
     */
    create: XOR<PluginCreateInput, PluginUncheckedCreateInput>
    /**
     * In case the Plugin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PluginUpdateInput, PluginUncheckedUpdateInput>
  }

  /**
   * Plugin delete
   */
  export type PluginDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plugin
     */
    select?: PluginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInclude<ExtArgs> | null
    /**
     * Filter which Plugin to delete.
     */
    where: PluginWhereUniqueInput
  }

  /**
   * Plugin deleteMany
   */
  export type PluginDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plugins to delete
     */
    where?: PluginWhereInput
  }

  /**
   * Plugin.installations
   */
  export type Plugin$installationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginInstallation
     */
    select?: PluginInstallationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInstallationInclude<ExtArgs> | null
    where?: PluginInstallationWhereInput
    orderBy?: PluginInstallationOrderByWithRelationInput | PluginInstallationOrderByWithRelationInput[]
    cursor?: PluginInstallationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PluginInstallationScalarFieldEnum | PluginInstallationScalarFieldEnum[]
  }

  /**
   * Plugin without action
   */
  export type PluginDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plugin
     */
    select?: PluginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInclude<ExtArgs> | null
  }


  /**
   * Model PluginInstallation
   */

  export type AggregatePluginInstallation = {
    _count: PluginInstallationCountAggregateOutputType | null
    _min: PluginInstallationMinAggregateOutputType | null
    _max: PluginInstallationMaxAggregateOutputType | null
  }

  export type PluginInstallationMinAggregateOutputType = {
    id: string | null
    pluginId: string | null
    isEnabled: boolean | null
    installedAt: Date | null
    updatedAt: Date | null
  }

  export type PluginInstallationMaxAggregateOutputType = {
    id: string | null
    pluginId: string | null
    isEnabled: boolean | null
    installedAt: Date | null
    updatedAt: Date | null
  }

  export type PluginInstallationCountAggregateOutputType = {
    id: number
    pluginId: number
    isEnabled: number
    config: number
    installedAt: number
    updatedAt: number
    _all: number
  }


  export type PluginInstallationMinAggregateInputType = {
    id?: true
    pluginId?: true
    isEnabled?: true
    installedAt?: true
    updatedAt?: true
  }

  export type PluginInstallationMaxAggregateInputType = {
    id?: true
    pluginId?: true
    isEnabled?: true
    installedAt?: true
    updatedAt?: true
  }

  export type PluginInstallationCountAggregateInputType = {
    id?: true
    pluginId?: true
    isEnabled?: true
    config?: true
    installedAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PluginInstallationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PluginInstallation to aggregate.
     */
    where?: PluginInstallationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PluginInstallations to fetch.
     */
    orderBy?: PluginInstallationOrderByWithRelationInput | PluginInstallationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PluginInstallationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PluginInstallations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PluginInstallations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PluginInstallations
    **/
    _count?: true | PluginInstallationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PluginInstallationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PluginInstallationMaxAggregateInputType
  }

  export type GetPluginInstallationAggregateType<T extends PluginInstallationAggregateArgs> = {
        [P in keyof T & keyof AggregatePluginInstallation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePluginInstallation[P]>
      : GetScalarType<T[P], AggregatePluginInstallation[P]>
  }




  export type PluginInstallationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PluginInstallationWhereInput
    orderBy?: PluginInstallationOrderByWithAggregationInput | PluginInstallationOrderByWithAggregationInput[]
    by: PluginInstallationScalarFieldEnum[] | PluginInstallationScalarFieldEnum
    having?: PluginInstallationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PluginInstallationCountAggregateInputType | true
    _min?: PluginInstallationMinAggregateInputType
    _max?: PluginInstallationMaxAggregateInputType
  }

  export type PluginInstallationGroupByOutputType = {
    id: string
    pluginId: string
    isEnabled: boolean
    config: JsonValue | null
    installedAt: Date
    updatedAt: Date
    _count: PluginInstallationCountAggregateOutputType | null
    _min: PluginInstallationMinAggregateOutputType | null
    _max: PluginInstallationMaxAggregateOutputType | null
  }

  type GetPluginInstallationGroupByPayload<T extends PluginInstallationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PluginInstallationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PluginInstallationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PluginInstallationGroupByOutputType[P]>
            : GetScalarType<T[P], PluginInstallationGroupByOutputType[P]>
        }
      >
    >


  export type PluginInstallationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pluginId?: boolean
    isEnabled?: boolean
    config?: boolean
    installedAt?: boolean
    updatedAt?: boolean
    plugin?: boolean | PluginDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pluginInstallation"]>


  export type PluginInstallationSelectScalar = {
    id?: boolean
    pluginId?: boolean
    isEnabled?: boolean
    config?: boolean
    installedAt?: boolean
    updatedAt?: boolean
  }

  export type PluginInstallationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plugin?: boolean | PluginDefaultArgs<ExtArgs>
  }

  export type $PluginInstallationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PluginInstallation"
    objects: {
      plugin: Prisma.$PluginPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      pluginId: string
      isEnabled: boolean
      config: Prisma.JsonValue | null
      installedAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pluginInstallation"]>
    composites: {}
  }

  type PluginInstallationGetPayload<S extends boolean | null | undefined | PluginInstallationDefaultArgs> = $Result.GetResult<Prisma.$PluginInstallationPayload, S>

  type PluginInstallationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PluginInstallationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PluginInstallationCountAggregateInputType | true
    }

  export interface PluginInstallationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PluginInstallation'], meta: { name: 'PluginInstallation' } }
    /**
     * Find zero or one PluginInstallation that matches the filter.
     * @param {PluginInstallationFindUniqueArgs} args - Arguments to find a PluginInstallation
     * @example
     * // Get one PluginInstallation
     * const pluginInstallation = await prisma.pluginInstallation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PluginInstallationFindUniqueArgs>(args: SelectSubset<T, PluginInstallationFindUniqueArgs<ExtArgs>>): Prisma__PluginInstallationClient<$Result.GetResult<Prisma.$PluginInstallationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PluginInstallation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PluginInstallationFindUniqueOrThrowArgs} args - Arguments to find a PluginInstallation
     * @example
     * // Get one PluginInstallation
     * const pluginInstallation = await prisma.pluginInstallation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PluginInstallationFindUniqueOrThrowArgs>(args: SelectSubset<T, PluginInstallationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PluginInstallationClient<$Result.GetResult<Prisma.$PluginInstallationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PluginInstallation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginInstallationFindFirstArgs} args - Arguments to find a PluginInstallation
     * @example
     * // Get one PluginInstallation
     * const pluginInstallation = await prisma.pluginInstallation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PluginInstallationFindFirstArgs>(args?: SelectSubset<T, PluginInstallationFindFirstArgs<ExtArgs>>): Prisma__PluginInstallationClient<$Result.GetResult<Prisma.$PluginInstallationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PluginInstallation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginInstallationFindFirstOrThrowArgs} args - Arguments to find a PluginInstallation
     * @example
     * // Get one PluginInstallation
     * const pluginInstallation = await prisma.pluginInstallation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PluginInstallationFindFirstOrThrowArgs>(args?: SelectSubset<T, PluginInstallationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PluginInstallationClient<$Result.GetResult<Prisma.$PluginInstallationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PluginInstallations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginInstallationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PluginInstallations
     * const pluginInstallations = await prisma.pluginInstallation.findMany()
     * 
     * // Get first 10 PluginInstallations
     * const pluginInstallations = await prisma.pluginInstallation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pluginInstallationWithIdOnly = await prisma.pluginInstallation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PluginInstallationFindManyArgs>(args?: SelectSubset<T, PluginInstallationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PluginInstallationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PluginInstallation.
     * @param {PluginInstallationCreateArgs} args - Arguments to create a PluginInstallation.
     * @example
     * // Create one PluginInstallation
     * const PluginInstallation = await prisma.pluginInstallation.create({
     *   data: {
     *     // ... data to create a PluginInstallation
     *   }
     * })
     * 
     */
    create<T extends PluginInstallationCreateArgs>(args: SelectSubset<T, PluginInstallationCreateArgs<ExtArgs>>): Prisma__PluginInstallationClient<$Result.GetResult<Prisma.$PluginInstallationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PluginInstallations.
     * @param {PluginInstallationCreateManyArgs} args - Arguments to create many PluginInstallations.
     * @example
     * // Create many PluginInstallations
     * const pluginInstallation = await prisma.pluginInstallation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PluginInstallationCreateManyArgs>(args?: SelectSubset<T, PluginInstallationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PluginInstallation.
     * @param {PluginInstallationDeleteArgs} args - Arguments to delete one PluginInstallation.
     * @example
     * // Delete one PluginInstallation
     * const PluginInstallation = await prisma.pluginInstallation.delete({
     *   where: {
     *     // ... filter to delete one PluginInstallation
     *   }
     * })
     * 
     */
    delete<T extends PluginInstallationDeleteArgs>(args: SelectSubset<T, PluginInstallationDeleteArgs<ExtArgs>>): Prisma__PluginInstallationClient<$Result.GetResult<Prisma.$PluginInstallationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PluginInstallation.
     * @param {PluginInstallationUpdateArgs} args - Arguments to update one PluginInstallation.
     * @example
     * // Update one PluginInstallation
     * const pluginInstallation = await prisma.pluginInstallation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PluginInstallationUpdateArgs>(args: SelectSubset<T, PluginInstallationUpdateArgs<ExtArgs>>): Prisma__PluginInstallationClient<$Result.GetResult<Prisma.$PluginInstallationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PluginInstallations.
     * @param {PluginInstallationDeleteManyArgs} args - Arguments to filter PluginInstallations to delete.
     * @example
     * // Delete a few PluginInstallations
     * const { count } = await prisma.pluginInstallation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PluginInstallationDeleteManyArgs>(args?: SelectSubset<T, PluginInstallationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PluginInstallations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginInstallationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PluginInstallations
     * const pluginInstallation = await prisma.pluginInstallation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PluginInstallationUpdateManyArgs>(args: SelectSubset<T, PluginInstallationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PluginInstallation.
     * @param {PluginInstallationUpsertArgs} args - Arguments to update or create a PluginInstallation.
     * @example
     * // Update or create a PluginInstallation
     * const pluginInstallation = await prisma.pluginInstallation.upsert({
     *   create: {
     *     // ... data to create a PluginInstallation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PluginInstallation we want to update
     *   }
     * })
     */
    upsert<T extends PluginInstallationUpsertArgs>(args: SelectSubset<T, PluginInstallationUpsertArgs<ExtArgs>>): Prisma__PluginInstallationClient<$Result.GetResult<Prisma.$PluginInstallationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PluginInstallations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginInstallationCountArgs} args - Arguments to filter PluginInstallations to count.
     * @example
     * // Count the number of PluginInstallations
     * const count = await prisma.pluginInstallation.count({
     *   where: {
     *     // ... the filter for the PluginInstallations we want to count
     *   }
     * })
    **/
    count<T extends PluginInstallationCountArgs>(
      args?: Subset<T, PluginInstallationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PluginInstallationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PluginInstallation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginInstallationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PluginInstallationAggregateArgs>(args: Subset<T, PluginInstallationAggregateArgs>): Prisma.PrismaPromise<GetPluginInstallationAggregateType<T>>

    /**
     * Group by PluginInstallation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginInstallationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PluginInstallationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PluginInstallationGroupByArgs['orderBy'] }
        : { orderBy?: PluginInstallationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PluginInstallationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPluginInstallationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PluginInstallation model
   */
  readonly fields: PluginInstallationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PluginInstallation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PluginInstallationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plugin<T extends PluginDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PluginDefaultArgs<ExtArgs>>): Prisma__PluginClient<$Result.GetResult<Prisma.$PluginPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PluginInstallation model
   */ 
  interface PluginInstallationFieldRefs {
    readonly id: FieldRef<"PluginInstallation", 'String'>
    readonly pluginId: FieldRef<"PluginInstallation", 'String'>
    readonly isEnabled: FieldRef<"PluginInstallation", 'Boolean'>
    readonly config: FieldRef<"PluginInstallation", 'Json'>
    readonly installedAt: FieldRef<"PluginInstallation", 'DateTime'>
    readonly updatedAt: FieldRef<"PluginInstallation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PluginInstallation findUnique
   */
  export type PluginInstallationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginInstallation
     */
    select?: PluginInstallationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInstallationInclude<ExtArgs> | null
    /**
     * Filter, which PluginInstallation to fetch.
     */
    where: PluginInstallationWhereUniqueInput
  }

  /**
   * PluginInstallation findUniqueOrThrow
   */
  export type PluginInstallationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginInstallation
     */
    select?: PluginInstallationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInstallationInclude<ExtArgs> | null
    /**
     * Filter, which PluginInstallation to fetch.
     */
    where: PluginInstallationWhereUniqueInput
  }

  /**
   * PluginInstallation findFirst
   */
  export type PluginInstallationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginInstallation
     */
    select?: PluginInstallationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInstallationInclude<ExtArgs> | null
    /**
     * Filter, which PluginInstallation to fetch.
     */
    where?: PluginInstallationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PluginInstallations to fetch.
     */
    orderBy?: PluginInstallationOrderByWithRelationInput | PluginInstallationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PluginInstallations.
     */
    cursor?: PluginInstallationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PluginInstallations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PluginInstallations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PluginInstallations.
     */
    distinct?: PluginInstallationScalarFieldEnum | PluginInstallationScalarFieldEnum[]
  }

  /**
   * PluginInstallation findFirstOrThrow
   */
  export type PluginInstallationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginInstallation
     */
    select?: PluginInstallationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInstallationInclude<ExtArgs> | null
    /**
     * Filter, which PluginInstallation to fetch.
     */
    where?: PluginInstallationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PluginInstallations to fetch.
     */
    orderBy?: PluginInstallationOrderByWithRelationInput | PluginInstallationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PluginInstallations.
     */
    cursor?: PluginInstallationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PluginInstallations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PluginInstallations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PluginInstallations.
     */
    distinct?: PluginInstallationScalarFieldEnum | PluginInstallationScalarFieldEnum[]
  }

  /**
   * PluginInstallation findMany
   */
  export type PluginInstallationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginInstallation
     */
    select?: PluginInstallationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInstallationInclude<ExtArgs> | null
    /**
     * Filter, which PluginInstallations to fetch.
     */
    where?: PluginInstallationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PluginInstallations to fetch.
     */
    orderBy?: PluginInstallationOrderByWithRelationInput | PluginInstallationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PluginInstallations.
     */
    cursor?: PluginInstallationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PluginInstallations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PluginInstallations.
     */
    skip?: number
    distinct?: PluginInstallationScalarFieldEnum | PluginInstallationScalarFieldEnum[]
  }

  /**
   * PluginInstallation create
   */
  export type PluginInstallationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginInstallation
     */
    select?: PluginInstallationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInstallationInclude<ExtArgs> | null
    /**
     * The data needed to create a PluginInstallation.
     */
    data: XOR<PluginInstallationCreateInput, PluginInstallationUncheckedCreateInput>
  }

  /**
   * PluginInstallation createMany
   */
  export type PluginInstallationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PluginInstallations.
     */
    data: PluginInstallationCreateManyInput | PluginInstallationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PluginInstallation update
   */
  export type PluginInstallationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginInstallation
     */
    select?: PluginInstallationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInstallationInclude<ExtArgs> | null
    /**
     * The data needed to update a PluginInstallation.
     */
    data: XOR<PluginInstallationUpdateInput, PluginInstallationUncheckedUpdateInput>
    /**
     * Choose, which PluginInstallation to update.
     */
    where: PluginInstallationWhereUniqueInput
  }

  /**
   * PluginInstallation updateMany
   */
  export type PluginInstallationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PluginInstallations.
     */
    data: XOR<PluginInstallationUpdateManyMutationInput, PluginInstallationUncheckedUpdateManyInput>
    /**
     * Filter which PluginInstallations to update
     */
    where?: PluginInstallationWhereInput
  }

  /**
   * PluginInstallation upsert
   */
  export type PluginInstallationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginInstallation
     */
    select?: PluginInstallationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInstallationInclude<ExtArgs> | null
    /**
     * The filter to search for the PluginInstallation to update in case it exists.
     */
    where: PluginInstallationWhereUniqueInput
    /**
     * In case the PluginInstallation found by the `where` argument doesn't exist, create a new PluginInstallation with this data.
     */
    create: XOR<PluginInstallationCreateInput, PluginInstallationUncheckedCreateInput>
    /**
     * In case the PluginInstallation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PluginInstallationUpdateInput, PluginInstallationUncheckedUpdateInput>
  }

  /**
   * PluginInstallation delete
   */
  export type PluginInstallationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginInstallation
     */
    select?: PluginInstallationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInstallationInclude<ExtArgs> | null
    /**
     * Filter which PluginInstallation to delete.
     */
    where: PluginInstallationWhereUniqueInput
  }

  /**
   * PluginInstallation deleteMany
   */
  export type PluginInstallationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PluginInstallations to delete
     */
    where?: PluginInstallationWhereInput
  }

  /**
   * PluginInstallation without action
   */
  export type PluginInstallationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginInstallation
     */
    select?: PluginInstallationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInstallationInclude<ExtArgs> | null
  }


  /**
   * Model ArticleCategory
   */

  export type AggregateArticleCategory = {
    _count: ArticleCategoryCountAggregateOutputType | null
    _avg: ArticleCategoryAvgAggregateOutputType | null
    _sum: ArticleCategorySumAggregateOutputType | null
    _min: ArticleCategoryMinAggregateOutputType | null
    _max: ArticleCategoryMaxAggregateOutputType | null
  }

  export type ArticleCategoryAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type ArticleCategorySumAggregateOutputType = {
    sortOrder: number | null
  }

  export type ArticleCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    parentId: string | null
    sortOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ArticleCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    parentId: string | null
    sortOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ArticleCategoryCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    parentId: number
    sortOrder: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ArticleCategoryAvgAggregateInputType = {
    sortOrder?: true
  }

  export type ArticleCategorySumAggregateInputType = {
    sortOrder?: true
  }

  export type ArticleCategoryMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    parentId?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ArticleCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    parentId?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ArticleCategoryCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    parentId?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ArticleCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArticleCategory to aggregate.
     */
    where?: ArticleCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleCategories to fetch.
     */
    orderBy?: ArticleCategoryOrderByWithRelationInput | ArticleCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArticleCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ArticleCategories
    **/
    _count?: true | ArticleCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArticleCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArticleCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArticleCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArticleCategoryMaxAggregateInputType
  }

  export type GetArticleCategoryAggregateType<T extends ArticleCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateArticleCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArticleCategory[P]>
      : GetScalarType<T[P], AggregateArticleCategory[P]>
  }




  export type ArticleCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArticleCategoryWhereInput
    orderBy?: ArticleCategoryOrderByWithAggregationInput | ArticleCategoryOrderByWithAggregationInput[]
    by: ArticleCategoryScalarFieldEnum[] | ArticleCategoryScalarFieldEnum
    having?: ArticleCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArticleCategoryCountAggregateInputType | true
    _avg?: ArticleCategoryAvgAggregateInputType
    _sum?: ArticleCategorySumAggregateInputType
    _min?: ArticleCategoryMinAggregateInputType
    _max?: ArticleCategoryMaxAggregateInputType
  }

  export type ArticleCategoryGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    parentId: string | null
    sortOrder: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ArticleCategoryCountAggregateOutputType | null
    _avg: ArticleCategoryAvgAggregateOutputType | null
    _sum: ArticleCategorySumAggregateOutputType | null
    _min: ArticleCategoryMinAggregateOutputType | null
    _max: ArticleCategoryMaxAggregateOutputType | null
  }

  type GetArticleCategoryGroupByPayload<T extends ArticleCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArticleCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArticleCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArticleCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ArticleCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ArticleCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    parentId?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | ArticleCategory$parentArgs<ExtArgs>
    children?: boolean | ArticleCategory$childrenArgs<ExtArgs>
    articles?: boolean | ArticleCategory$articlesArgs<ExtArgs>
    _count?: boolean | ArticleCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["articleCategory"]>


  export type ArticleCategorySelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    parentId?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ArticleCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | ArticleCategory$parentArgs<ExtArgs>
    children?: boolean | ArticleCategory$childrenArgs<ExtArgs>
    articles?: boolean | ArticleCategory$articlesArgs<ExtArgs>
    _count?: boolean | ArticleCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ArticleCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ArticleCategory"
    objects: {
      parent: Prisma.$ArticleCategoryPayload<ExtArgs> | null
      children: Prisma.$ArticleCategoryPayload<ExtArgs>[]
      articles: Prisma.$ArticlePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      parentId: string | null
      sortOrder: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["articleCategory"]>
    composites: {}
  }

  type ArticleCategoryGetPayload<S extends boolean | null | undefined | ArticleCategoryDefaultArgs> = $Result.GetResult<Prisma.$ArticleCategoryPayload, S>

  type ArticleCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ArticleCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ArticleCategoryCountAggregateInputType | true
    }

  export interface ArticleCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ArticleCategory'], meta: { name: 'ArticleCategory' } }
    /**
     * Find zero or one ArticleCategory that matches the filter.
     * @param {ArticleCategoryFindUniqueArgs} args - Arguments to find a ArticleCategory
     * @example
     * // Get one ArticleCategory
     * const articleCategory = await prisma.articleCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArticleCategoryFindUniqueArgs>(args: SelectSubset<T, ArticleCategoryFindUniqueArgs<ExtArgs>>): Prisma__ArticleCategoryClient<$Result.GetResult<Prisma.$ArticleCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ArticleCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ArticleCategoryFindUniqueOrThrowArgs} args - Arguments to find a ArticleCategory
     * @example
     * // Get one ArticleCategory
     * const articleCategory = await prisma.articleCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArticleCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ArticleCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArticleCategoryClient<$Result.GetResult<Prisma.$ArticleCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ArticleCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleCategoryFindFirstArgs} args - Arguments to find a ArticleCategory
     * @example
     * // Get one ArticleCategory
     * const articleCategory = await prisma.articleCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArticleCategoryFindFirstArgs>(args?: SelectSubset<T, ArticleCategoryFindFirstArgs<ExtArgs>>): Prisma__ArticleCategoryClient<$Result.GetResult<Prisma.$ArticleCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ArticleCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleCategoryFindFirstOrThrowArgs} args - Arguments to find a ArticleCategory
     * @example
     * // Get one ArticleCategory
     * const articleCategory = await prisma.articleCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArticleCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ArticleCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArticleCategoryClient<$Result.GetResult<Prisma.$ArticleCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ArticleCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ArticleCategories
     * const articleCategories = await prisma.articleCategory.findMany()
     * 
     * // Get first 10 ArticleCategories
     * const articleCategories = await prisma.articleCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const articleCategoryWithIdOnly = await prisma.articleCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ArticleCategoryFindManyArgs>(args?: SelectSubset<T, ArticleCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticleCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ArticleCategory.
     * @param {ArticleCategoryCreateArgs} args - Arguments to create a ArticleCategory.
     * @example
     * // Create one ArticleCategory
     * const ArticleCategory = await prisma.articleCategory.create({
     *   data: {
     *     // ... data to create a ArticleCategory
     *   }
     * })
     * 
     */
    create<T extends ArticleCategoryCreateArgs>(args: SelectSubset<T, ArticleCategoryCreateArgs<ExtArgs>>): Prisma__ArticleCategoryClient<$Result.GetResult<Prisma.$ArticleCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ArticleCategories.
     * @param {ArticleCategoryCreateManyArgs} args - Arguments to create many ArticleCategories.
     * @example
     * // Create many ArticleCategories
     * const articleCategory = await prisma.articleCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ArticleCategoryCreateManyArgs>(args?: SelectSubset<T, ArticleCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ArticleCategory.
     * @param {ArticleCategoryDeleteArgs} args - Arguments to delete one ArticleCategory.
     * @example
     * // Delete one ArticleCategory
     * const ArticleCategory = await prisma.articleCategory.delete({
     *   where: {
     *     // ... filter to delete one ArticleCategory
     *   }
     * })
     * 
     */
    delete<T extends ArticleCategoryDeleteArgs>(args: SelectSubset<T, ArticleCategoryDeleteArgs<ExtArgs>>): Prisma__ArticleCategoryClient<$Result.GetResult<Prisma.$ArticleCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ArticleCategory.
     * @param {ArticleCategoryUpdateArgs} args - Arguments to update one ArticleCategory.
     * @example
     * // Update one ArticleCategory
     * const articleCategory = await prisma.articleCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ArticleCategoryUpdateArgs>(args: SelectSubset<T, ArticleCategoryUpdateArgs<ExtArgs>>): Prisma__ArticleCategoryClient<$Result.GetResult<Prisma.$ArticleCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ArticleCategories.
     * @param {ArticleCategoryDeleteManyArgs} args - Arguments to filter ArticleCategories to delete.
     * @example
     * // Delete a few ArticleCategories
     * const { count } = await prisma.articleCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ArticleCategoryDeleteManyArgs>(args?: SelectSubset<T, ArticleCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArticleCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ArticleCategories
     * const articleCategory = await prisma.articleCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ArticleCategoryUpdateManyArgs>(args: SelectSubset<T, ArticleCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ArticleCategory.
     * @param {ArticleCategoryUpsertArgs} args - Arguments to update or create a ArticleCategory.
     * @example
     * // Update or create a ArticleCategory
     * const articleCategory = await prisma.articleCategory.upsert({
     *   create: {
     *     // ... data to create a ArticleCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ArticleCategory we want to update
     *   }
     * })
     */
    upsert<T extends ArticleCategoryUpsertArgs>(args: SelectSubset<T, ArticleCategoryUpsertArgs<ExtArgs>>): Prisma__ArticleCategoryClient<$Result.GetResult<Prisma.$ArticleCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ArticleCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleCategoryCountArgs} args - Arguments to filter ArticleCategories to count.
     * @example
     * // Count the number of ArticleCategories
     * const count = await prisma.articleCategory.count({
     *   where: {
     *     // ... the filter for the ArticleCategories we want to count
     *   }
     * })
    **/
    count<T extends ArticleCategoryCountArgs>(
      args?: Subset<T, ArticleCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArticleCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ArticleCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArticleCategoryAggregateArgs>(args: Subset<T, ArticleCategoryAggregateArgs>): Prisma.PrismaPromise<GetArticleCategoryAggregateType<T>>

    /**
     * Group by ArticleCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArticleCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArticleCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ArticleCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArticleCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArticleCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ArticleCategory model
   */
  readonly fields: ArticleCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ArticleCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArticleCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends ArticleCategory$parentArgs<ExtArgs> = {}>(args?: Subset<T, ArticleCategory$parentArgs<ExtArgs>>): Prisma__ArticleCategoryClient<$Result.GetResult<Prisma.$ArticleCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    children<T extends ArticleCategory$childrenArgs<ExtArgs> = {}>(args?: Subset<T, ArticleCategory$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticleCategoryPayload<ExtArgs>, T, "findMany"> | Null>
    articles<T extends ArticleCategory$articlesArgs<ExtArgs> = {}>(args?: Subset<T, ArticleCategory$articlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ArticleCategory model
   */ 
  interface ArticleCategoryFieldRefs {
    readonly id: FieldRef<"ArticleCategory", 'String'>
    readonly name: FieldRef<"ArticleCategory", 'String'>
    readonly slug: FieldRef<"ArticleCategory", 'String'>
    readonly description: FieldRef<"ArticleCategory", 'String'>
    readonly parentId: FieldRef<"ArticleCategory", 'String'>
    readonly sortOrder: FieldRef<"ArticleCategory", 'Int'>
    readonly isActive: FieldRef<"ArticleCategory", 'Boolean'>
    readonly createdAt: FieldRef<"ArticleCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"ArticleCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ArticleCategory findUnique
   */
  export type ArticleCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleCategory
     */
    select?: ArticleCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ArticleCategory to fetch.
     */
    where: ArticleCategoryWhereUniqueInput
  }

  /**
   * ArticleCategory findUniqueOrThrow
   */
  export type ArticleCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleCategory
     */
    select?: ArticleCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ArticleCategory to fetch.
     */
    where: ArticleCategoryWhereUniqueInput
  }

  /**
   * ArticleCategory findFirst
   */
  export type ArticleCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleCategory
     */
    select?: ArticleCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ArticleCategory to fetch.
     */
    where?: ArticleCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleCategories to fetch.
     */
    orderBy?: ArticleCategoryOrderByWithRelationInput | ArticleCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArticleCategories.
     */
    cursor?: ArticleCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArticleCategories.
     */
    distinct?: ArticleCategoryScalarFieldEnum | ArticleCategoryScalarFieldEnum[]
  }

  /**
   * ArticleCategory findFirstOrThrow
   */
  export type ArticleCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleCategory
     */
    select?: ArticleCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ArticleCategory to fetch.
     */
    where?: ArticleCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleCategories to fetch.
     */
    orderBy?: ArticleCategoryOrderByWithRelationInput | ArticleCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArticleCategories.
     */
    cursor?: ArticleCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArticleCategories.
     */
    distinct?: ArticleCategoryScalarFieldEnum | ArticleCategoryScalarFieldEnum[]
  }

  /**
   * ArticleCategory findMany
   */
  export type ArticleCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleCategory
     */
    select?: ArticleCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ArticleCategories to fetch.
     */
    where?: ArticleCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleCategories to fetch.
     */
    orderBy?: ArticleCategoryOrderByWithRelationInput | ArticleCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ArticleCategories.
     */
    cursor?: ArticleCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleCategories.
     */
    skip?: number
    distinct?: ArticleCategoryScalarFieldEnum | ArticleCategoryScalarFieldEnum[]
  }

  /**
   * ArticleCategory create
   */
  export type ArticleCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleCategory
     */
    select?: ArticleCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ArticleCategory.
     */
    data: XOR<ArticleCategoryCreateInput, ArticleCategoryUncheckedCreateInput>
  }

  /**
   * ArticleCategory createMany
   */
  export type ArticleCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ArticleCategories.
     */
    data: ArticleCategoryCreateManyInput | ArticleCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ArticleCategory update
   */
  export type ArticleCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleCategory
     */
    select?: ArticleCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ArticleCategory.
     */
    data: XOR<ArticleCategoryUpdateInput, ArticleCategoryUncheckedUpdateInput>
    /**
     * Choose, which ArticleCategory to update.
     */
    where: ArticleCategoryWhereUniqueInput
  }

  /**
   * ArticleCategory updateMany
   */
  export type ArticleCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ArticleCategories.
     */
    data: XOR<ArticleCategoryUpdateManyMutationInput, ArticleCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ArticleCategories to update
     */
    where?: ArticleCategoryWhereInput
  }

  /**
   * ArticleCategory upsert
   */
  export type ArticleCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleCategory
     */
    select?: ArticleCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ArticleCategory to update in case it exists.
     */
    where: ArticleCategoryWhereUniqueInput
    /**
     * In case the ArticleCategory found by the `where` argument doesn't exist, create a new ArticleCategory with this data.
     */
    create: XOR<ArticleCategoryCreateInput, ArticleCategoryUncheckedCreateInput>
    /**
     * In case the ArticleCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArticleCategoryUpdateInput, ArticleCategoryUncheckedUpdateInput>
  }

  /**
   * ArticleCategory delete
   */
  export type ArticleCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleCategory
     */
    select?: ArticleCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleCategoryInclude<ExtArgs> | null
    /**
     * Filter which ArticleCategory to delete.
     */
    where: ArticleCategoryWhereUniqueInput
  }

  /**
   * ArticleCategory deleteMany
   */
  export type ArticleCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArticleCategories to delete
     */
    where?: ArticleCategoryWhereInput
  }

  /**
   * ArticleCategory.parent
   */
  export type ArticleCategory$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleCategory
     */
    select?: ArticleCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleCategoryInclude<ExtArgs> | null
    where?: ArticleCategoryWhereInput
  }

  /**
   * ArticleCategory.children
   */
  export type ArticleCategory$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleCategory
     */
    select?: ArticleCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleCategoryInclude<ExtArgs> | null
    where?: ArticleCategoryWhereInput
    orderBy?: ArticleCategoryOrderByWithRelationInput | ArticleCategoryOrderByWithRelationInput[]
    cursor?: ArticleCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArticleCategoryScalarFieldEnum | ArticleCategoryScalarFieldEnum[]
  }

  /**
   * ArticleCategory.articles
   */
  export type ArticleCategory$articlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    where?: ArticleWhereInput
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    cursor?: ArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }

  /**
   * ArticleCategory without action
   */
  export type ArticleCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleCategory
     */
    select?: ArticleCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Article
   */

  export type AggregateArticle = {
    _count: ArticleCountAggregateOutputType | null
    _avg: ArticleAvgAggregateOutputType | null
    _sum: ArticleSumAggregateOutputType | null
    _min: ArticleMinAggregateOutputType | null
    _max: ArticleMaxAggregateOutputType | null
  }

  export type ArticleAvgAggregateOutputType = {
    viewCount: number | null
  }

  export type ArticleSumAggregateOutputType = {
    viewCount: number | null
  }

  export type ArticleMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    content: string | null
    excerpt: string | null
    coverImage: string | null
    categoryId: string | null
    authorId: string | null
    status: $Enums.ArticleStatus | null
    viewCount: number | null
    seoTitle: string | null
    seoDescription: string | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ArticleMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    content: string | null
    excerpt: string | null
    coverImage: string | null
    categoryId: string | null
    authorId: string | null
    status: $Enums.ArticleStatus | null
    viewCount: number | null
    seoTitle: string | null
    seoDescription: string | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ArticleCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    content: number
    excerpt: number
    coverImage: number
    categoryId: number
    authorId: number
    status: number
    viewCount: number
    tags: number
    seoTitle: number
    seoDescription: number
    publishedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ArticleAvgAggregateInputType = {
    viewCount?: true
  }

  export type ArticleSumAggregateInputType = {
    viewCount?: true
  }

  export type ArticleMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    content?: true
    excerpt?: true
    coverImage?: true
    categoryId?: true
    authorId?: true
    status?: true
    viewCount?: true
    seoTitle?: true
    seoDescription?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ArticleMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    content?: true
    excerpt?: true
    coverImage?: true
    categoryId?: true
    authorId?: true
    status?: true
    viewCount?: true
    seoTitle?: true
    seoDescription?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ArticleCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    content?: true
    excerpt?: true
    coverImage?: true
    categoryId?: true
    authorId?: true
    status?: true
    viewCount?: true
    tags?: true
    seoTitle?: true
    seoDescription?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ArticleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Article to aggregate.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Articles
    **/
    _count?: true | ArticleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArticleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArticleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArticleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArticleMaxAggregateInputType
  }

  export type GetArticleAggregateType<T extends ArticleAggregateArgs> = {
        [P in keyof T & keyof AggregateArticle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArticle[P]>
      : GetScalarType<T[P], AggregateArticle[P]>
  }




  export type ArticleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArticleWhereInput
    orderBy?: ArticleOrderByWithAggregationInput | ArticleOrderByWithAggregationInput[]
    by: ArticleScalarFieldEnum[] | ArticleScalarFieldEnum
    having?: ArticleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArticleCountAggregateInputType | true
    _avg?: ArticleAvgAggregateInputType
    _sum?: ArticleSumAggregateInputType
    _min?: ArticleMinAggregateInputType
    _max?: ArticleMaxAggregateInputType
  }

  export type ArticleGroupByOutputType = {
    id: string
    title: string
    slug: string
    content: string
    excerpt: string | null
    coverImage: string | null
    categoryId: string | null
    authorId: string
    status: $Enums.ArticleStatus
    viewCount: number
    tags: JsonValue
    seoTitle: string | null
    seoDescription: string | null
    publishedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ArticleCountAggregateOutputType | null
    _avg: ArticleAvgAggregateOutputType | null
    _sum: ArticleSumAggregateOutputType | null
    _min: ArticleMinAggregateOutputType | null
    _max: ArticleMaxAggregateOutputType | null
  }

  type GetArticleGroupByPayload<T extends ArticleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArticleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArticleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArticleGroupByOutputType[P]>
            : GetScalarType<T[P], ArticleGroupByOutputType[P]>
        }
      >
    >


  export type ArticleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    excerpt?: boolean
    coverImage?: boolean
    categoryId?: boolean
    authorId?: boolean
    status?: boolean
    viewCount?: boolean
    tags?: boolean
    seoTitle?: boolean
    seoDescription?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | Article$categoryArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["article"]>


  export type ArticleSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    excerpt?: boolean
    coverImage?: boolean
    categoryId?: boolean
    authorId?: boolean
    status?: boolean
    viewCount?: boolean
    tags?: boolean
    seoTitle?: boolean
    seoDescription?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ArticleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Article$categoryArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ArticlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Article"
    objects: {
      category: Prisma.$ArticleCategoryPayload<ExtArgs> | null
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      content: string
      excerpt: string | null
      coverImage: string | null
      categoryId: string | null
      authorId: string
      status: $Enums.ArticleStatus
      viewCount: number
      tags: Prisma.JsonValue
      seoTitle: string | null
      seoDescription: string | null
      publishedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["article"]>
    composites: {}
  }

  type ArticleGetPayload<S extends boolean | null | undefined | ArticleDefaultArgs> = $Result.GetResult<Prisma.$ArticlePayload, S>

  type ArticleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ArticleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ArticleCountAggregateInputType | true
    }

  export interface ArticleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Article'], meta: { name: 'Article' } }
    /**
     * Find zero or one Article that matches the filter.
     * @param {ArticleFindUniqueArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArticleFindUniqueArgs>(args: SelectSubset<T, ArticleFindUniqueArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Article that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ArticleFindUniqueOrThrowArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArticleFindUniqueOrThrowArgs>(args: SelectSubset<T, ArticleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Article that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleFindFirstArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArticleFindFirstArgs>(args?: SelectSubset<T, ArticleFindFirstArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Article that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleFindFirstOrThrowArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArticleFindFirstOrThrowArgs>(args?: SelectSubset<T, ArticleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Articles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Articles
     * const articles = await prisma.article.findMany()
     * 
     * // Get first 10 Articles
     * const articles = await prisma.article.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const articleWithIdOnly = await prisma.article.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ArticleFindManyArgs>(args?: SelectSubset<T, ArticleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Article.
     * @param {ArticleCreateArgs} args - Arguments to create a Article.
     * @example
     * // Create one Article
     * const Article = await prisma.article.create({
     *   data: {
     *     // ... data to create a Article
     *   }
     * })
     * 
     */
    create<T extends ArticleCreateArgs>(args: SelectSubset<T, ArticleCreateArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Articles.
     * @param {ArticleCreateManyArgs} args - Arguments to create many Articles.
     * @example
     * // Create many Articles
     * const article = await prisma.article.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ArticleCreateManyArgs>(args?: SelectSubset<T, ArticleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Article.
     * @param {ArticleDeleteArgs} args - Arguments to delete one Article.
     * @example
     * // Delete one Article
     * const Article = await prisma.article.delete({
     *   where: {
     *     // ... filter to delete one Article
     *   }
     * })
     * 
     */
    delete<T extends ArticleDeleteArgs>(args: SelectSubset<T, ArticleDeleteArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Article.
     * @param {ArticleUpdateArgs} args - Arguments to update one Article.
     * @example
     * // Update one Article
     * const article = await prisma.article.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ArticleUpdateArgs>(args: SelectSubset<T, ArticleUpdateArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Articles.
     * @param {ArticleDeleteManyArgs} args - Arguments to filter Articles to delete.
     * @example
     * // Delete a few Articles
     * const { count } = await prisma.article.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ArticleDeleteManyArgs>(args?: SelectSubset<T, ArticleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Articles
     * const article = await prisma.article.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ArticleUpdateManyArgs>(args: SelectSubset<T, ArticleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Article.
     * @param {ArticleUpsertArgs} args - Arguments to update or create a Article.
     * @example
     * // Update or create a Article
     * const article = await prisma.article.upsert({
     *   create: {
     *     // ... data to create a Article
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Article we want to update
     *   }
     * })
     */
    upsert<T extends ArticleUpsertArgs>(args: SelectSubset<T, ArticleUpsertArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleCountArgs} args - Arguments to filter Articles to count.
     * @example
     * // Count the number of Articles
     * const count = await prisma.article.count({
     *   where: {
     *     // ... the filter for the Articles we want to count
     *   }
     * })
    **/
    count<T extends ArticleCountArgs>(
      args?: Subset<T, ArticleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArticleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Article.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArticleAggregateArgs>(args: Subset<T, ArticleAggregateArgs>): Prisma.PrismaPromise<GetArticleAggregateType<T>>

    /**
     * Group by Article.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArticleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArticleGroupByArgs['orderBy'] }
        : { orderBy?: ArticleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArticleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArticleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Article model
   */
  readonly fields: ArticleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Article.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArticleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends Article$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Article$categoryArgs<ExtArgs>>): Prisma__ArticleCategoryClient<$Result.GetResult<Prisma.$ArticleCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Article model
   */ 
  interface ArticleFieldRefs {
    readonly id: FieldRef<"Article", 'String'>
    readonly title: FieldRef<"Article", 'String'>
    readonly slug: FieldRef<"Article", 'String'>
    readonly content: FieldRef<"Article", 'String'>
    readonly excerpt: FieldRef<"Article", 'String'>
    readonly coverImage: FieldRef<"Article", 'String'>
    readonly categoryId: FieldRef<"Article", 'String'>
    readonly authorId: FieldRef<"Article", 'String'>
    readonly status: FieldRef<"Article", 'ArticleStatus'>
    readonly viewCount: FieldRef<"Article", 'Int'>
    readonly tags: FieldRef<"Article", 'Json'>
    readonly seoTitle: FieldRef<"Article", 'String'>
    readonly seoDescription: FieldRef<"Article", 'String'>
    readonly publishedAt: FieldRef<"Article", 'DateTime'>
    readonly createdAt: FieldRef<"Article", 'DateTime'>
    readonly updatedAt: FieldRef<"Article", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Article findUnique
   */
  export type ArticleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter, which Article to fetch.
     */
    where: ArticleWhereUniqueInput
  }

  /**
   * Article findUniqueOrThrow
   */
  export type ArticleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter, which Article to fetch.
     */
    where: ArticleWhereUniqueInput
  }

  /**
   * Article findFirst
   */
  export type ArticleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter, which Article to fetch.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Articles.
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Articles.
     */
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }

  /**
   * Article findFirstOrThrow
   */
  export type ArticleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter, which Article to fetch.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Articles.
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Articles.
     */
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }

  /**
   * Article findMany
   */
  export type ArticleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter, which Articles to fetch.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Articles.
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }

  /**
   * Article create
   */
  export type ArticleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * The data needed to create a Article.
     */
    data: XOR<ArticleCreateInput, ArticleUncheckedCreateInput>
  }

  /**
   * Article createMany
   */
  export type ArticleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Articles.
     */
    data: ArticleCreateManyInput | ArticleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Article update
   */
  export type ArticleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * The data needed to update a Article.
     */
    data: XOR<ArticleUpdateInput, ArticleUncheckedUpdateInput>
    /**
     * Choose, which Article to update.
     */
    where: ArticleWhereUniqueInput
  }

  /**
   * Article updateMany
   */
  export type ArticleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Articles.
     */
    data: XOR<ArticleUpdateManyMutationInput, ArticleUncheckedUpdateManyInput>
    /**
     * Filter which Articles to update
     */
    where?: ArticleWhereInput
  }

  /**
   * Article upsert
   */
  export type ArticleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * The filter to search for the Article to update in case it exists.
     */
    where: ArticleWhereUniqueInput
    /**
     * In case the Article found by the `where` argument doesn't exist, create a new Article with this data.
     */
    create: XOR<ArticleCreateInput, ArticleUncheckedCreateInput>
    /**
     * In case the Article was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArticleUpdateInput, ArticleUncheckedUpdateInput>
  }

  /**
   * Article delete
   */
  export type ArticleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter which Article to delete.
     */
    where: ArticleWhereUniqueInput
  }

  /**
   * Article deleteMany
   */
  export type ArticleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Articles to delete
     */
    where?: ArticleWhereInput
  }

  /**
   * Article.category
   */
  export type Article$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleCategory
     */
    select?: ArticleCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleCategoryInclude<ExtArgs> | null
    where?: ArticleCategoryWhereInput
  }

  /**
   * Article without action
   */
  export type ArticleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    type: $Enums.NotificationType | null
    targetType: $Enums.NotificationTarget | null
    isRead: boolean | null
    sendAt: Date | null
    sentAt: Date | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    type: $Enums.NotificationType | null
    targetType: $Enums.NotificationTarget | null
    isRead: boolean | null
    sendAt: Date | null
    sentAt: Date | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    title: number
    content: number
    type: number
    targetType: number
    targetIds: number
    isRead: number
    sendAt: number
    sentAt: number
    createdById: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    type?: true
    targetType?: true
    isRead?: true
    sendAt?: true
    sentAt?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    type?: true
    targetType?: true
    isRead?: true
    sendAt?: true
    sentAt?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    type?: true
    targetType?: true
    targetIds?: true
    isRead?: true
    sendAt?: true
    sentAt?: true
    createdById?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    title: string
    content: string
    type: $Enums.NotificationType
    targetType: $Enums.NotificationTarget
    targetIds: JsonValue
    isRead: boolean
    sendAt: Date | null
    sentAt: Date | null
    createdById: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    targetType?: boolean
    targetIds?: boolean
    isRead?: boolean
    sendAt?: boolean
    sentAt?: boolean
    createdById?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userNotifications?: boolean | Notification$userNotificationsArgs<ExtArgs>
    _count?: boolean | NotificationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>


  export type NotificationSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    targetType?: boolean
    targetIds?: boolean
    isRead?: boolean
    sendAt?: boolean
    sentAt?: boolean
    createdById?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userNotifications?: boolean | Notification$userNotificationsArgs<ExtArgs>
    _count?: boolean | NotificationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      userNotifications: Prisma.$UserNotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: string
      type: $Enums.NotificationType
      targetType: $Enums.NotificationTarget
      targetIds: Prisma.JsonValue
      isRead: boolean
      sendAt: Date | null
      sentAt: Date | null
      createdById: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userNotifications<T extends Notification$userNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, Notification$userNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserNotificationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly content: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly targetType: FieldRef<"Notification", 'NotificationTarget'>
    readonly targetIds: FieldRef<"Notification", 'Json'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly sendAt: FieldRef<"Notification", 'DateTime'>
    readonly sentAt: FieldRef<"Notification", 'DateTime'>
    readonly createdById: FieldRef<"Notification", 'String'>
    readonly metadata: FieldRef<"Notification", 'Json'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification.userNotifications
   */
  export type Notification$userNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotification
     */
    select?: UserNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationInclude<ExtArgs> | null
    where?: UserNotificationWhereInput
    orderBy?: UserNotificationOrderByWithRelationInput | UserNotificationOrderByWithRelationInput[]
    cursor?: UserNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserNotificationScalarFieldEnum | UserNotificationScalarFieldEnum[]
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model UserNotification
   */

  export type AggregateUserNotification = {
    _count: UserNotificationCountAggregateOutputType | null
    _min: UserNotificationMinAggregateOutputType | null
    _max: UserNotificationMaxAggregateOutputType | null
  }

  export type UserNotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    notificationId: string | null
    isRead: boolean | null
    readAt: Date | null
    createdAt: Date | null
  }

  export type UserNotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    notificationId: string | null
    isRead: boolean | null
    readAt: Date | null
    createdAt: Date | null
  }

  export type UserNotificationCountAggregateOutputType = {
    id: number
    userId: number
    notificationId: number
    isRead: number
    readAt: number
    createdAt: number
    _all: number
  }


  export type UserNotificationMinAggregateInputType = {
    id?: true
    userId?: true
    notificationId?: true
    isRead?: true
    readAt?: true
    createdAt?: true
  }

  export type UserNotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    notificationId?: true
    isRead?: true
    readAt?: true
    createdAt?: true
  }

  export type UserNotificationCountAggregateInputType = {
    id?: true
    userId?: true
    notificationId?: true
    isRead?: true
    readAt?: true
    createdAt?: true
    _all?: true
  }

  export type UserNotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserNotification to aggregate.
     */
    where?: UserNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNotifications to fetch.
     */
    orderBy?: UserNotificationOrderByWithRelationInput | UserNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserNotifications
    **/
    _count?: true | UserNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserNotificationMaxAggregateInputType
  }

  export type GetUserNotificationAggregateType<T extends UserNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateUserNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserNotification[P]>
      : GetScalarType<T[P], AggregateUserNotification[P]>
  }




  export type UserNotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserNotificationWhereInput
    orderBy?: UserNotificationOrderByWithAggregationInput | UserNotificationOrderByWithAggregationInput[]
    by: UserNotificationScalarFieldEnum[] | UserNotificationScalarFieldEnum
    having?: UserNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserNotificationCountAggregateInputType | true
    _min?: UserNotificationMinAggregateInputType
    _max?: UserNotificationMaxAggregateInputType
  }

  export type UserNotificationGroupByOutputType = {
    id: string
    userId: string
    notificationId: string
    isRead: boolean
    readAt: Date | null
    createdAt: Date
    _count: UserNotificationCountAggregateOutputType | null
    _min: UserNotificationMinAggregateOutputType | null
    _max: UserNotificationMaxAggregateOutputType | null
  }

  type GetUserNotificationGroupByPayload<T extends UserNotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], UserNotificationGroupByOutputType[P]>
        }
      >
    >


  export type UserNotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    notificationId?: boolean
    isRead?: boolean
    readAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userNotification"]>


  export type UserNotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    notificationId?: boolean
    isRead?: boolean
    readAt?: boolean
    createdAt?: boolean
  }

  export type UserNotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
  }

  export type $UserNotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserNotification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      notification: Prisma.$NotificationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      notificationId: string
      isRead: boolean
      readAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["userNotification"]>
    composites: {}
  }

  type UserNotificationGetPayload<S extends boolean | null | undefined | UserNotificationDefaultArgs> = $Result.GetResult<Prisma.$UserNotificationPayload, S>

  type UserNotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserNotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserNotificationCountAggregateInputType | true
    }

  export interface UserNotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserNotification'], meta: { name: 'UserNotification' } }
    /**
     * Find zero or one UserNotification that matches the filter.
     * @param {UserNotificationFindUniqueArgs} args - Arguments to find a UserNotification
     * @example
     * // Get one UserNotification
     * const userNotification = await prisma.userNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserNotificationFindUniqueArgs>(args: SelectSubset<T, UserNotificationFindUniqueArgs<ExtArgs>>): Prisma__UserNotificationClient<$Result.GetResult<Prisma.$UserNotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserNotification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserNotificationFindUniqueOrThrowArgs} args - Arguments to find a UserNotification
     * @example
     * // Get one UserNotification
     * const userNotification = await prisma.userNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserNotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, UserNotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserNotificationClient<$Result.GetResult<Prisma.$UserNotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationFindFirstArgs} args - Arguments to find a UserNotification
     * @example
     * // Get one UserNotification
     * const userNotification = await prisma.userNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserNotificationFindFirstArgs>(args?: SelectSubset<T, UserNotificationFindFirstArgs<ExtArgs>>): Prisma__UserNotificationClient<$Result.GetResult<Prisma.$UserNotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserNotification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationFindFirstOrThrowArgs} args - Arguments to find a UserNotification
     * @example
     * // Get one UserNotification
     * const userNotification = await prisma.userNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserNotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, UserNotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserNotificationClient<$Result.GetResult<Prisma.$UserNotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserNotifications
     * const userNotifications = await prisma.userNotification.findMany()
     * 
     * // Get first 10 UserNotifications
     * const userNotifications = await prisma.userNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userNotificationWithIdOnly = await prisma.userNotification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserNotificationFindManyArgs>(args?: SelectSubset<T, UserNotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserNotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserNotification.
     * @param {UserNotificationCreateArgs} args - Arguments to create a UserNotification.
     * @example
     * // Create one UserNotification
     * const UserNotification = await prisma.userNotification.create({
     *   data: {
     *     // ... data to create a UserNotification
     *   }
     * })
     * 
     */
    create<T extends UserNotificationCreateArgs>(args: SelectSubset<T, UserNotificationCreateArgs<ExtArgs>>): Prisma__UserNotificationClient<$Result.GetResult<Prisma.$UserNotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserNotifications.
     * @param {UserNotificationCreateManyArgs} args - Arguments to create many UserNotifications.
     * @example
     * // Create many UserNotifications
     * const userNotification = await prisma.userNotification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserNotificationCreateManyArgs>(args?: SelectSubset<T, UserNotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserNotification.
     * @param {UserNotificationDeleteArgs} args - Arguments to delete one UserNotification.
     * @example
     * // Delete one UserNotification
     * const UserNotification = await prisma.userNotification.delete({
     *   where: {
     *     // ... filter to delete one UserNotification
     *   }
     * })
     * 
     */
    delete<T extends UserNotificationDeleteArgs>(args: SelectSubset<T, UserNotificationDeleteArgs<ExtArgs>>): Prisma__UserNotificationClient<$Result.GetResult<Prisma.$UserNotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserNotification.
     * @param {UserNotificationUpdateArgs} args - Arguments to update one UserNotification.
     * @example
     * // Update one UserNotification
     * const userNotification = await prisma.userNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserNotificationUpdateArgs>(args: SelectSubset<T, UserNotificationUpdateArgs<ExtArgs>>): Prisma__UserNotificationClient<$Result.GetResult<Prisma.$UserNotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserNotifications.
     * @param {UserNotificationDeleteManyArgs} args - Arguments to filter UserNotifications to delete.
     * @example
     * // Delete a few UserNotifications
     * const { count } = await prisma.userNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserNotificationDeleteManyArgs>(args?: SelectSubset<T, UserNotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserNotifications
     * const userNotification = await prisma.userNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserNotificationUpdateManyArgs>(args: SelectSubset<T, UserNotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserNotification.
     * @param {UserNotificationUpsertArgs} args - Arguments to update or create a UserNotification.
     * @example
     * // Update or create a UserNotification
     * const userNotification = await prisma.userNotification.upsert({
     *   create: {
     *     // ... data to create a UserNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserNotification we want to update
     *   }
     * })
     */
    upsert<T extends UserNotificationUpsertArgs>(args: SelectSubset<T, UserNotificationUpsertArgs<ExtArgs>>): Prisma__UserNotificationClient<$Result.GetResult<Prisma.$UserNotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationCountArgs} args - Arguments to filter UserNotifications to count.
     * @example
     * // Count the number of UserNotifications
     * const count = await prisma.userNotification.count({
     *   where: {
     *     // ... the filter for the UserNotifications we want to count
     *   }
     * })
    **/
    count<T extends UserNotificationCountArgs>(
      args?: Subset<T, UserNotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserNotificationAggregateArgs>(args: Subset<T, UserNotificationAggregateArgs>): Prisma.PrismaPromise<GetUserNotificationAggregateType<T>>

    /**
     * Group by UserNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserNotificationGroupByArgs['orderBy'] }
        : { orderBy?: UserNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserNotification model
   */
  readonly fields: UserNotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserNotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    notification<T extends NotificationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NotificationDefaultArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserNotification model
   */ 
  interface UserNotificationFieldRefs {
    readonly id: FieldRef<"UserNotification", 'String'>
    readonly userId: FieldRef<"UserNotification", 'String'>
    readonly notificationId: FieldRef<"UserNotification", 'String'>
    readonly isRead: FieldRef<"UserNotification", 'Boolean'>
    readonly readAt: FieldRef<"UserNotification", 'DateTime'>
    readonly createdAt: FieldRef<"UserNotification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserNotification findUnique
   */
  export type UserNotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotification
     */
    select?: UserNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationInclude<ExtArgs> | null
    /**
     * Filter, which UserNotification to fetch.
     */
    where: UserNotificationWhereUniqueInput
  }

  /**
   * UserNotification findUniqueOrThrow
   */
  export type UserNotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotification
     */
    select?: UserNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationInclude<ExtArgs> | null
    /**
     * Filter, which UserNotification to fetch.
     */
    where: UserNotificationWhereUniqueInput
  }

  /**
   * UserNotification findFirst
   */
  export type UserNotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotification
     */
    select?: UserNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationInclude<ExtArgs> | null
    /**
     * Filter, which UserNotification to fetch.
     */
    where?: UserNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNotifications to fetch.
     */
    orderBy?: UserNotificationOrderByWithRelationInput | UserNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserNotifications.
     */
    cursor?: UserNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserNotifications.
     */
    distinct?: UserNotificationScalarFieldEnum | UserNotificationScalarFieldEnum[]
  }

  /**
   * UserNotification findFirstOrThrow
   */
  export type UserNotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotification
     */
    select?: UserNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationInclude<ExtArgs> | null
    /**
     * Filter, which UserNotification to fetch.
     */
    where?: UserNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNotifications to fetch.
     */
    orderBy?: UserNotificationOrderByWithRelationInput | UserNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserNotifications.
     */
    cursor?: UserNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserNotifications.
     */
    distinct?: UserNotificationScalarFieldEnum | UserNotificationScalarFieldEnum[]
  }

  /**
   * UserNotification findMany
   */
  export type UserNotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotification
     */
    select?: UserNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationInclude<ExtArgs> | null
    /**
     * Filter, which UserNotifications to fetch.
     */
    where?: UserNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNotifications to fetch.
     */
    orderBy?: UserNotificationOrderByWithRelationInput | UserNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserNotifications.
     */
    cursor?: UserNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNotifications.
     */
    skip?: number
    distinct?: UserNotificationScalarFieldEnum | UserNotificationScalarFieldEnum[]
  }

  /**
   * UserNotification create
   */
  export type UserNotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotification
     */
    select?: UserNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a UserNotification.
     */
    data: XOR<UserNotificationCreateInput, UserNotificationUncheckedCreateInput>
  }

  /**
   * UserNotification createMany
   */
  export type UserNotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserNotifications.
     */
    data: UserNotificationCreateManyInput | UserNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserNotification update
   */
  export type UserNotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotification
     */
    select?: UserNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a UserNotification.
     */
    data: XOR<UserNotificationUpdateInput, UserNotificationUncheckedUpdateInput>
    /**
     * Choose, which UserNotification to update.
     */
    where: UserNotificationWhereUniqueInput
  }

  /**
   * UserNotification updateMany
   */
  export type UserNotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserNotifications.
     */
    data: XOR<UserNotificationUpdateManyMutationInput, UserNotificationUncheckedUpdateManyInput>
    /**
     * Filter which UserNotifications to update
     */
    where?: UserNotificationWhereInput
  }

  /**
   * UserNotification upsert
   */
  export type UserNotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotification
     */
    select?: UserNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the UserNotification to update in case it exists.
     */
    where: UserNotificationWhereUniqueInput
    /**
     * In case the UserNotification found by the `where` argument doesn't exist, create a new UserNotification with this data.
     */
    create: XOR<UserNotificationCreateInput, UserNotificationUncheckedCreateInput>
    /**
     * In case the UserNotification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserNotificationUpdateInput, UserNotificationUncheckedUpdateInput>
  }

  /**
   * UserNotification delete
   */
  export type UserNotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotification
     */
    select?: UserNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationInclude<ExtArgs> | null
    /**
     * Filter which UserNotification to delete.
     */
    where: UserNotificationWhereUniqueInput
  }

  /**
   * UserNotification deleteMany
   */
  export type UserNotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserNotifications to delete
     */
    where?: UserNotificationWhereInput
  }

  /**
   * UserNotification without action
   */
  export type UserNotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotification
     */
    select?: UserNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNotificationInclude<ExtArgs> | null
  }


  /**
   * Model PaymentConfig
   */

  export type AggregatePaymentConfig = {
    _count: PaymentConfigCountAggregateOutputType | null
    _avg: PaymentConfigAvgAggregateOutputType | null
    _sum: PaymentConfigSumAggregateOutputType | null
    _min: PaymentConfigMinAggregateOutputType | null
    _max: PaymentConfigMaxAggregateOutputType | null
  }

  export type PaymentConfigAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type PaymentConfigSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type PaymentConfigMinAggregateOutputType = {
    id: string | null
    provider: $Enums.PaymentProvider | null
    name: string | null
    isEnabled: boolean | null
    isSandbox: boolean | null
    wechatAppId: string | null
    wechatMchId: string | null
    wechatApiKey: string | null
    wechatCertPath: string | null
    alipayAppId: string | null
    alipayPrivateKey: string | null
    alipayPublicKey: string | null
    paypalClientId: string | null
    paypalSecret: string | null
    stripePublicKey: string | null
    stripeSecretKey: string | null
    stripeWebhookSecret: string | null
    epayUrl: string | null
    epayPid: string | null
    epayKey: string | null
    notifyUrl: string | null
    returnUrl: string | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentConfigMaxAggregateOutputType = {
    id: string | null
    provider: $Enums.PaymentProvider | null
    name: string | null
    isEnabled: boolean | null
    isSandbox: boolean | null
    wechatAppId: string | null
    wechatMchId: string | null
    wechatApiKey: string | null
    wechatCertPath: string | null
    alipayAppId: string | null
    alipayPrivateKey: string | null
    alipayPublicKey: string | null
    paypalClientId: string | null
    paypalSecret: string | null
    stripePublicKey: string | null
    stripeSecretKey: string | null
    stripeWebhookSecret: string | null
    epayUrl: string | null
    epayPid: string | null
    epayKey: string | null
    notifyUrl: string | null
    returnUrl: string | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentConfigCountAggregateOutputType = {
    id: number
    provider: number
    name: number
    isEnabled: number
    isSandbox: number
    wechatAppId: number
    wechatMchId: number
    wechatApiKey: number
    wechatCertPath: number
    alipayAppId: number
    alipayPrivateKey: number
    alipayPublicKey: number
    paypalClientId: number
    paypalSecret: number
    stripePublicKey: number
    stripeSecretKey: number
    stripeWebhookSecret: number
    epayUrl: number
    epayPid: number
    epayKey: number
    notifyUrl: number
    returnUrl: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentConfigAvgAggregateInputType = {
    sortOrder?: true
  }

  export type PaymentConfigSumAggregateInputType = {
    sortOrder?: true
  }

  export type PaymentConfigMinAggregateInputType = {
    id?: true
    provider?: true
    name?: true
    isEnabled?: true
    isSandbox?: true
    wechatAppId?: true
    wechatMchId?: true
    wechatApiKey?: true
    wechatCertPath?: true
    alipayAppId?: true
    alipayPrivateKey?: true
    alipayPublicKey?: true
    paypalClientId?: true
    paypalSecret?: true
    stripePublicKey?: true
    stripeSecretKey?: true
    stripeWebhookSecret?: true
    epayUrl?: true
    epayPid?: true
    epayKey?: true
    notifyUrl?: true
    returnUrl?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentConfigMaxAggregateInputType = {
    id?: true
    provider?: true
    name?: true
    isEnabled?: true
    isSandbox?: true
    wechatAppId?: true
    wechatMchId?: true
    wechatApiKey?: true
    wechatCertPath?: true
    alipayAppId?: true
    alipayPrivateKey?: true
    alipayPublicKey?: true
    paypalClientId?: true
    paypalSecret?: true
    stripePublicKey?: true
    stripeSecretKey?: true
    stripeWebhookSecret?: true
    epayUrl?: true
    epayPid?: true
    epayKey?: true
    notifyUrl?: true
    returnUrl?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentConfigCountAggregateInputType = {
    id?: true
    provider?: true
    name?: true
    isEnabled?: true
    isSandbox?: true
    wechatAppId?: true
    wechatMchId?: true
    wechatApiKey?: true
    wechatCertPath?: true
    alipayAppId?: true
    alipayPrivateKey?: true
    alipayPublicKey?: true
    paypalClientId?: true
    paypalSecret?: true
    stripePublicKey?: true
    stripeSecretKey?: true
    stripeWebhookSecret?: true
    epayUrl?: true
    epayPid?: true
    epayKey?: true
    notifyUrl?: true
    returnUrl?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentConfig to aggregate.
     */
    where?: PaymentConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentConfigs to fetch.
     */
    orderBy?: PaymentConfigOrderByWithRelationInput | PaymentConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentConfigs
    **/
    _count?: true | PaymentConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentConfigMaxAggregateInputType
  }

  export type GetPaymentConfigAggregateType<T extends PaymentConfigAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentConfig[P]>
      : GetScalarType<T[P], AggregatePaymentConfig[P]>
  }




  export type PaymentConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentConfigWhereInput
    orderBy?: PaymentConfigOrderByWithAggregationInput | PaymentConfigOrderByWithAggregationInput[]
    by: PaymentConfigScalarFieldEnum[] | PaymentConfigScalarFieldEnum
    having?: PaymentConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentConfigCountAggregateInputType | true
    _avg?: PaymentConfigAvgAggregateInputType
    _sum?: PaymentConfigSumAggregateInputType
    _min?: PaymentConfigMinAggregateInputType
    _max?: PaymentConfigMaxAggregateInputType
  }

  export type PaymentConfigGroupByOutputType = {
    id: string
    provider: $Enums.PaymentProvider
    name: string
    isEnabled: boolean
    isSandbox: boolean
    wechatAppId: string | null
    wechatMchId: string | null
    wechatApiKey: string | null
    wechatCertPath: string | null
    alipayAppId: string | null
    alipayPrivateKey: string | null
    alipayPublicKey: string | null
    paypalClientId: string | null
    paypalSecret: string | null
    stripePublicKey: string | null
    stripeSecretKey: string | null
    stripeWebhookSecret: string | null
    epayUrl: string | null
    epayPid: string | null
    epayKey: string | null
    notifyUrl: string | null
    returnUrl: string | null
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: PaymentConfigCountAggregateOutputType | null
    _avg: PaymentConfigAvgAggregateOutputType | null
    _sum: PaymentConfigSumAggregateOutputType | null
    _min: PaymentConfigMinAggregateOutputType | null
    _max: PaymentConfigMaxAggregateOutputType | null
  }

  type GetPaymentConfigGroupByPayload<T extends PaymentConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentConfigGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentConfigGroupByOutputType[P]>
        }
      >
    >


  export type PaymentConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    name?: boolean
    isEnabled?: boolean
    isSandbox?: boolean
    wechatAppId?: boolean
    wechatMchId?: boolean
    wechatApiKey?: boolean
    wechatCertPath?: boolean
    alipayAppId?: boolean
    alipayPrivateKey?: boolean
    alipayPublicKey?: boolean
    paypalClientId?: boolean
    paypalSecret?: boolean
    stripePublicKey?: boolean
    stripeSecretKey?: boolean
    stripeWebhookSecret?: boolean
    epayUrl?: boolean
    epayPid?: boolean
    epayKey?: boolean
    notifyUrl?: boolean
    returnUrl?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentConfig"]>


  export type PaymentConfigSelectScalar = {
    id?: boolean
    provider?: boolean
    name?: boolean
    isEnabled?: boolean
    isSandbox?: boolean
    wechatAppId?: boolean
    wechatMchId?: boolean
    wechatApiKey?: boolean
    wechatCertPath?: boolean
    alipayAppId?: boolean
    alipayPrivateKey?: boolean
    alipayPublicKey?: boolean
    paypalClientId?: boolean
    paypalSecret?: boolean
    stripePublicKey?: boolean
    stripeSecretKey?: boolean
    stripeWebhookSecret?: boolean
    epayUrl?: boolean
    epayPid?: boolean
    epayKey?: boolean
    notifyUrl?: boolean
    returnUrl?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $PaymentConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      provider: $Enums.PaymentProvider
      name: string
      isEnabled: boolean
      isSandbox: boolean
      wechatAppId: string | null
      wechatMchId: string | null
      wechatApiKey: string | null
      wechatCertPath: string | null
      alipayAppId: string | null
      alipayPrivateKey: string | null
      alipayPublicKey: string | null
      paypalClientId: string | null
      paypalSecret: string | null
      stripePublicKey: string | null
      stripeSecretKey: string | null
      stripeWebhookSecret: string | null
      epayUrl: string | null
      epayPid: string | null
      epayKey: string | null
      notifyUrl: string | null
      returnUrl: string | null
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paymentConfig"]>
    composites: {}
  }

  type PaymentConfigGetPayload<S extends boolean | null | undefined | PaymentConfigDefaultArgs> = $Result.GetResult<Prisma.$PaymentConfigPayload, S>

  type PaymentConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentConfigCountAggregateInputType | true
    }

  export interface PaymentConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentConfig'], meta: { name: 'PaymentConfig' } }
    /**
     * Find zero or one PaymentConfig that matches the filter.
     * @param {PaymentConfigFindUniqueArgs} args - Arguments to find a PaymentConfig
     * @example
     * // Get one PaymentConfig
     * const paymentConfig = await prisma.paymentConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentConfigFindUniqueArgs>(args: SelectSubset<T, PaymentConfigFindUniqueArgs<ExtArgs>>): Prisma__PaymentConfigClient<$Result.GetResult<Prisma.$PaymentConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PaymentConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentConfigFindUniqueOrThrowArgs} args - Arguments to find a PaymentConfig
     * @example
     * // Get one PaymentConfig
     * const paymentConfig = await prisma.paymentConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentConfigClient<$Result.GetResult<Prisma.$PaymentConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PaymentConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentConfigFindFirstArgs} args - Arguments to find a PaymentConfig
     * @example
     * // Get one PaymentConfig
     * const paymentConfig = await prisma.paymentConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentConfigFindFirstArgs>(args?: SelectSubset<T, PaymentConfigFindFirstArgs<ExtArgs>>): Prisma__PaymentConfigClient<$Result.GetResult<Prisma.$PaymentConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PaymentConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentConfigFindFirstOrThrowArgs} args - Arguments to find a PaymentConfig
     * @example
     * // Get one PaymentConfig
     * const paymentConfig = await prisma.paymentConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentConfigClient<$Result.GetResult<Prisma.$PaymentConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PaymentConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentConfigs
     * const paymentConfigs = await prisma.paymentConfig.findMany()
     * 
     * // Get first 10 PaymentConfigs
     * const paymentConfigs = await prisma.paymentConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentConfigWithIdOnly = await prisma.paymentConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentConfigFindManyArgs>(args?: SelectSubset<T, PaymentConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PaymentConfig.
     * @param {PaymentConfigCreateArgs} args - Arguments to create a PaymentConfig.
     * @example
     * // Create one PaymentConfig
     * const PaymentConfig = await prisma.paymentConfig.create({
     *   data: {
     *     // ... data to create a PaymentConfig
     *   }
     * })
     * 
     */
    create<T extends PaymentConfigCreateArgs>(args: SelectSubset<T, PaymentConfigCreateArgs<ExtArgs>>): Prisma__PaymentConfigClient<$Result.GetResult<Prisma.$PaymentConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PaymentConfigs.
     * @param {PaymentConfigCreateManyArgs} args - Arguments to create many PaymentConfigs.
     * @example
     * // Create many PaymentConfigs
     * const paymentConfig = await prisma.paymentConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentConfigCreateManyArgs>(args?: SelectSubset<T, PaymentConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PaymentConfig.
     * @param {PaymentConfigDeleteArgs} args - Arguments to delete one PaymentConfig.
     * @example
     * // Delete one PaymentConfig
     * const PaymentConfig = await prisma.paymentConfig.delete({
     *   where: {
     *     // ... filter to delete one PaymentConfig
     *   }
     * })
     * 
     */
    delete<T extends PaymentConfigDeleteArgs>(args: SelectSubset<T, PaymentConfigDeleteArgs<ExtArgs>>): Prisma__PaymentConfigClient<$Result.GetResult<Prisma.$PaymentConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PaymentConfig.
     * @param {PaymentConfigUpdateArgs} args - Arguments to update one PaymentConfig.
     * @example
     * // Update one PaymentConfig
     * const paymentConfig = await prisma.paymentConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentConfigUpdateArgs>(args: SelectSubset<T, PaymentConfigUpdateArgs<ExtArgs>>): Prisma__PaymentConfigClient<$Result.GetResult<Prisma.$PaymentConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PaymentConfigs.
     * @param {PaymentConfigDeleteManyArgs} args - Arguments to filter PaymentConfigs to delete.
     * @example
     * // Delete a few PaymentConfigs
     * const { count } = await prisma.paymentConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentConfigDeleteManyArgs>(args?: SelectSubset<T, PaymentConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentConfigs
     * const paymentConfig = await prisma.paymentConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentConfigUpdateManyArgs>(args: SelectSubset<T, PaymentConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PaymentConfig.
     * @param {PaymentConfigUpsertArgs} args - Arguments to update or create a PaymentConfig.
     * @example
     * // Update or create a PaymentConfig
     * const paymentConfig = await prisma.paymentConfig.upsert({
     *   create: {
     *     // ... data to create a PaymentConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentConfig we want to update
     *   }
     * })
     */
    upsert<T extends PaymentConfigUpsertArgs>(args: SelectSubset<T, PaymentConfigUpsertArgs<ExtArgs>>): Prisma__PaymentConfigClient<$Result.GetResult<Prisma.$PaymentConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PaymentConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentConfigCountArgs} args - Arguments to filter PaymentConfigs to count.
     * @example
     * // Count the number of PaymentConfigs
     * const count = await prisma.paymentConfig.count({
     *   where: {
     *     // ... the filter for the PaymentConfigs we want to count
     *   }
     * })
    **/
    count<T extends PaymentConfigCountArgs>(
      args?: Subset<T, PaymentConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentConfigAggregateArgs>(args: Subset<T, PaymentConfigAggregateArgs>): Prisma.PrismaPromise<GetPaymentConfigAggregateType<T>>

    /**
     * Group by PaymentConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentConfigGroupByArgs['orderBy'] }
        : { orderBy?: PaymentConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentConfig model
   */
  readonly fields: PaymentConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentConfig model
   */ 
  interface PaymentConfigFieldRefs {
    readonly id: FieldRef<"PaymentConfig", 'String'>
    readonly provider: FieldRef<"PaymentConfig", 'PaymentProvider'>
    readonly name: FieldRef<"PaymentConfig", 'String'>
    readonly isEnabled: FieldRef<"PaymentConfig", 'Boolean'>
    readonly isSandbox: FieldRef<"PaymentConfig", 'Boolean'>
    readonly wechatAppId: FieldRef<"PaymentConfig", 'String'>
    readonly wechatMchId: FieldRef<"PaymentConfig", 'String'>
    readonly wechatApiKey: FieldRef<"PaymentConfig", 'String'>
    readonly wechatCertPath: FieldRef<"PaymentConfig", 'String'>
    readonly alipayAppId: FieldRef<"PaymentConfig", 'String'>
    readonly alipayPrivateKey: FieldRef<"PaymentConfig", 'String'>
    readonly alipayPublicKey: FieldRef<"PaymentConfig", 'String'>
    readonly paypalClientId: FieldRef<"PaymentConfig", 'String'>
    readonly paypalSecret: FieldRef<"PaymentConfig", 'String'>
    readonly stripePublicKey: FieldRef<"PaymentConfig", 'String'>
    readonly stripeSecretKey: FieldRef<"PaymentConfig", 'String'>
    readonly stripeWebhookSecret: FieldRef<"PaymentConfig", 'String'>
    readonly epayUrl: FieldRef<"PaymentConfig", 'String'>
    readonly epayPid: FieldRef<"PaymentConfig", 'String'>
    readonly epayKey: FieldRef<"PaymentConfig", 'String'>
    readonly notifyUrl: FieldRef<"PaymentConfig", 'String'>
    readonly returnUrl: FieldRef<"PaymentConfig", 'String'>
    readonly sortOrder: FieldRef<"PaymentConfig", 'Int'>
    readonly createdAt: FieldRef<"PaymentConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentConfig findUnique
   */
  export type PaymentConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentConfig
     */
    select?: PaymentConfigSelect<ExtArgs> | null
    /**
     * Filter, which PaymentConfig to fetch.
     */
    where: PaymentConfigWhereUniqueInput
  }

  /**
   * PaymentConfig findUniqueOrThrow
   */
  export type PaymentConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentConfig
     */
    select?: PaymentConfigSelect<ExtArgs> | null
    /**
     * Filter, which PaymentConfig to fetch.
     */
    where: PaymentConfigWhereUniqueInput
  }

  /**
   * PaymentConfig findFirst
   */
  export type PaymentConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentConfig
     */
    select?: PaymentConfigSelect<ExtArgs> | null
    /**
     * Filter, which PaymentConfig to fetch.
     */
    where?: PaymentConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentConfigs to fetch.
     */
    orderBy?: PaymentConfigOrderByWithRelationInput | PaymentConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentConfigs.
     */
    cursor?: PaymentConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentConfigs.
     */
    distinct?: PaymentConfigScalarFieldEnum | PaymentConfigScalarFieldEnum[]
  }

  /**
   * PaymentConfig findFirstOrThrow
   */
  export type PaymentConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentConfig
     */
    select?: PaymentConfigSelect<ExtArgs> | null
    /**
     * Filter, which PaymentConfig to fetch.
     */
    where?: PaymentConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentConfigs to fetch.
     */
    orderBy?: PaymentConfigOrderByWithRelationInput | PaymentConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentConfigs.
     */
    cursor?: PaymentConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentConfigs.
     */
    distinct?: PaymentConfigScalarFieldEnum | PaymentConfigScalarFieldEnum[]
  }

  /**
   * PaymentConfig findMany
   */
  export type PaymentConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentConfig
     */
    select?: PaymentConfigSelect<ExtArgs> | null
    /**
     * Filter, which PaymentConfigs to fetch.
     */
    where?: PaymentConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentConfigs to fetch.
     */
    orderBy?: PaymentConfigOrderByWithRelationInput | PaymentConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentConfigs.
     */
    cursor?: PaymentConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentConfigs.
     */
    skip?: number
    distinct?: PaymentConfigScalarFieldEnum | PaymentConfigScalarFieldEnum[]
  }

  /**
   * PaymentConfig create
   */
  export type PaymentConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentConfig
     */
    select?: PaymentConfigSelect<ExtArgs> | null
    /**
     * The data needed to create a PaymentConfig.
     */
    data: XOR<PaymentConfigCreateInput, PaymentConfigUncheckedCreateInput>
  }

  /**
   * PaymentConfig createMany
   */
  export type PaymentConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentConfigs.
     */
    data: PaymentConfigCreateManyInput | PaymentConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentConfig update
   */
  export type PaymentConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentConfig
     */
    select?: PaymentConfigSelect<ExtArgs> | null
    /**
     * The data needed to update a PaymentConfig.
     */
    data: XOR<PaymentConfigUpdateInput, PaymentConfigUncheckedUpdateInput>
    /**
     * Choose, which PaymentConfig to update.
     */
    where: PaymentConfigWhereUniqueInput
  }

  /**
   * PaymentConfig updateMany
   */
  export type PaymentConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentConfigs.
     */
    data: XOR<PaymentConfigUpdateManyMutationInput, PaymentConfigUncheckedUpdateManyInput>
    /**
     * Filter which PaymentConfigs to update
     */
    where?: PaymentConfigWhereInput
  }

  /**
   * PaymentConfig upsert
   */
  export type PaymentConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentConfig
     */
    select?: PaymentConfigSelect<ExtArgs> | null
    /**
     * The filter to search for the PaymentConfig to update in case it exists.
     */
    where: PaymentConfigWhereUniqueInput
    /**
     * In case the PaymentConfig found by the `where` argument doesn't exist, create a new PaymentConfig with this data.
     */
    create: XOR<PaymentConfigCreateInput, PaymentConfigUncheckedCreateInput>
    /**
     * In case the PaymentConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentConfigUpdateInput, PaymentConfigUncheckedUpdateInput>
  }

  /**
   * PaymentConfig delete
   */
  export type PaymentConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentConfig
     */
    select?: PaymentConfigSelect<ExtArgs> | null
    /**
     * Filter which PaymentConfig to delete.
     */
    where: PaymentConfigWhereUniqueInput
  }

  /**
   * PaymentConfig deleteMany
   */
  export type PaymentConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentConfigs to delete
     */
    where?: PaymentConfigWhereInput
  }

  /**
   * PaymentConfig without action
   */
  export type PaymentConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentConfig
     */
    select?: PaymentConfigSelect<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    amount: number | null
  }

  export type OrderSumAggregateOutputType = {
    amount: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    orderNo: string | null
    userId: string | null
    orderType: $Enums.OrderType | null
    status: $Enums.OrderStatus | null
    amount: number | null
    currency: string | null
    paymentMethod: $Enums.PaymentProvider | null
    transactionId: string | null
    productId: string | null
    productName: string | null
    productDesc: string | null
    paidAt: Date | null
    refundedAt: Date | null
    expiredAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    orderNo: string | null
    userId: string | null
    orderType: $Enums.OrderType | null
    status: $Enums.OrderStatus | null
    amount: number | null
    currency: string | null
    paymentMethod: $Enums.PaymentProvider | null
    transactionId: string | null
    productId: string | null
    productName: string | null
    productDesc: string | null
    paidAt: Date | null
    refundedAt: Date | null
    expiredAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    orderNo: number
    userId: number
    orderType: number
    status: number
    amount: number
    currency: number
    paymentMethod: number
    transactionId: number
    productId: number
    productName: number
    productDesc: number
    metadata: number
    paidAt: number
    refundedAt: number
    expiredAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    amount?: true
  }

  export type OrderSumAggregateInputType = {
    amount?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    orderNo?: true
    userId?: true
    orderType?: true
    status?: true
    amount?: true
    currency?: true
    paymentMethod?: true
    transactionId?: true
    productId?: true
    productName?: true
    productDesc?: true
    paidAt?: true
    refundedAt?: true
    expiredAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    orderNo?: true
    userId?: true
    orderType?: true
    status?: true
    amount?: true
    currency?: true
    paymentMethod?: true
    transactionId?: true
    productId?: true
    productName?: true
    productDesc?: true
    paidAt?: true
    refundedAt?: true
    expiredAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    orderNo?: true
    userId?: true
    orderType?: true
    status?: true
    amount?: true
    currency?: true
    paymentMethod?: true
    transactionId?: true
    productId?: true
    productName?: true
    productDesc?: true
    metadata?: true
    paidAt?: true
    refundedAt?: true
    expiredAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    orderNo: string
    userId: string
    orderType: $Enums.OrderType
    status: $Enums.OrderStatus
    amount: number
    currency: string
    paymentMethod: $Enums.PaymentProvider | null
    transactionId: string | null
    productId: string | null
    productName: string
    productDesc: string | null
    metadata: JsonValue | null
    paidAt: Date | null
    refundedAt: Date | null
    expiredAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNo?: boolean
    userId?: boolean
    orderType?: boolean
    status?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    productId?: boolean
    productName?: boolean
    productDesc?: boolean
    metadata?: boolean
    paidAt?: boolean
    refundedAt?: boolean
    expiredAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>


  export type OrderSelectScalar = {
    id?: boolean
    orderNo?: boolean
    userId?: boolean
    orderType?: boolean
    status?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    productId?: boolean
    productName?: boolean
    productDesc?: boolean
    metadata?: boolean
    paidAt?: boolean
    refundedAt?: boolean
    expiredAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderNo: string
      userId: string
      orderType: $Enums.OrderType
      status: $Enums.OrderStatus
      amount: number
      currency: string
      paymentMethod: $Enums.PaymentProvider | null
      transactionId: string | null
      productId: string | null
      productName: string
      productDesc: string | null
      metadata: Prisma.JsonValue | null
      paidAt: Date | null
      refundedAt: Date | null
      expiredAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */ 
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly orderNo: FieldRef<"Order", 'String'>
    readonly userId: FieldRef<"Order", 'String'>
    readonly orderType: FieldRef<"Order", 'OrderType'>
    readonly status: FieldRef<"Order", 'OrderStatus'>
    readonly amount: FieldRef<"Order", 'Float'>
    readonly currency: FieldRef<"Order", 'String'>
    readonly paymentMethod: FieldRef<"Order", 'PaymentProvider'>
    readonly transactionId: FieldRef<"Order", 'String'>
    readonly productId: FieldRef<"Order", 'String'>
    readonly productName: FieldRef<"Order", 'String'>
    readonly productDesc: FieldRef<"Order", 'String'>
    readonly metadata: FieldRef<"Order", 'Json'>
    readonly paidAt: FieldRef<"Order", 'DateTime'>
    readonly refundedAt: FieldRef<"Order", 'DateTime'>
    readonly expiredAt: FieldRef<"Order", 'DateTime'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model MembershipPlan
   */

  export type AggregateMembershipPlan = {
    _count: MembershipPlanCountAggregateOutputType | null
    _avg: MembershipPlanAvgAggregateOutputType | null
    _sum: MembershipPlanSumAggregateOutputType | null
    _min: MembershipPlanMinAggregateOutputType | null
    _max: MembershipPlanMaxAggregateOutputType | null
  }

  export type MembershipPlanAvgAggregateOutputType = {
    price: number | null
    originalPrice: number | null
    duration: number | null
    sortOrder: number | null
  }

  export type MembershipPlanSumAggregateOutputType = {
    price: number | null
    originalPrice: number | null
    duration: number | null
    sortOrder: number | null
  }

  export type MembershipPlanMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    price: number | null
    originalPrice: number | null
    currency: string | null
    duration: number | null
    isActive: boolean | null
    isFeatured: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MembershipPlanMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    price: number | null
    originalPrice: number | null
    currency: string | null
    duration: number | null
    isActive: boolean | null
    isFeatured: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MembershipPlanCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    price: number
    originalPrice: number
    currency: number
    duration: number
    features: number
    limits: number
    isActive: number
    isFeatured: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MembershipPlanAvgAggregateInputType = {
    price?: true
    originalPrice?: true
    duration?: true
    sortOrder?: true
  }

  export type MembershipPlanSumAggregateInputType = {
    price?: true
    originalPrice?: true
    duration?: true
    sortOrder?: true
  }

  export type MembershipPlanMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    price?: true
    originalPrice?: true
    currency?: true
    duration?: true
    isActive?: true
    isFeatured?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MembershipPlanMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    price?: true
    originalPrice?: true
    currency?: true
    duration?: true
    isActive?: true
    isFeatured?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MembershipPlanCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    price?: true
    originalPrice?: true
    currency?: true
    duration?: true
    features?: true
    limits?: true
    isActive?: true
    isFeatured?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MembershipPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MembershipPlan to aggregate.
     */
    where?: MembershipPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MembershipPlans to fetch.
     */
    orderBy?: MembershipPlanOrderByWithRelationInput | MembershipPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MembershipPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MembershipPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MembershipPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MembershipPlans
    **/
    _count?: true | MembershipPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MembershipPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MembershipPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MembershipPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MembershipPlanMaxAggregateInputType
  }

  export type GetMembershipPlanAggregateType<T extends MembershipPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateMembershipPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMembershipPlan[P]>
      : GetScalarType<T[P], AggregateMembershipPlan[P]>
  }




  export type MembershipPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MembershipPlanWhereInput
    orderBy?: MembershipPlanOrderByWithAggregationInput | MembershipPlanOrderByWithAggregationInput[]
    by: MembershipPlanScalarFieldEnum[] | MembershipPlanScalarFieldEnum
    having?: MembershipPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MembershipPlanCountAggregateInputType | true
    _avg?: MembershipPlanAvgAggregateInputType
    _sum?: MembershipPlanSumAggregateInputType
    _min?: MembershipPlanMinAggregateInputType
    _max?: MembershipPlanMaxAggregateInputType
  }

  export type MembershipPlanGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    price: number
    originalPrice: number | null
    currency: string
    duration: number
    features: JsonValue
    limits: JsonValue | null
    isActive: boolean
    isFeatured: boolean
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: MembershipPlanCountAggregateOutputType | null
    _avg: MembershipPlanAvgAggregateOutputType | null
    _sum: MembershipPlanSumAggregateOutputType | null
    _min: MembershipPlanMinAggregateOutputType | null
    _max: MembershipPlanMaxAggregateOutputType | null
  }

  type GetMembershipPlanGroupByPayload<T extends MembershipPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MembershipPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MembershipPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MembershipPlanGroupByOutputType[P]>
            : GetScalarType<T[P], MembershipPlanGroupByOutputType[P]>
        }
      >
    >


  export type MembershipPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    price?: boolean
    originalPrice?: boolean
    currency?: boolean
    duration?: boolean
    features?: boolean
    limits?: boolean
    isActive?: boolean
    isFeatured?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | MembershipPlan$usersArgs<ExtArgs>
    _count?: boolean | MembershipPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["membershipPlan"]>


  export type MembershipPlanSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    price?: boolean
    originalPrice?: boolean
    currency?: boolean
    duration?: boolean
    features?: boolean
    limits?: boolean
    isActive?: boolean
    isFeatured?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MembershipPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | MembershipPlan$usersArgs<ExtArgs>
    _count?: boolean | MembershipPlanCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MembershipPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MembershipPlan"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      price: number
      originalPrice: number | null
      currency: string
      duration: number
      features: Prisma.JsonValue
      limits: Prisma.JsonValue | null
      isActive: boolean
      isFeatured: boolean
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["membershipPlan"]>
    composites: {}
  }

  type MembershipPlanGetPayload<S extends boolean | null | undefined | MembershipPlanDefaultArgs> = $Result.GetResult<Prisma.$MembershipPlanPayload, S>

  type MembershipPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MembershipPlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MembershipPlanCountAggregateInputType | true
    }

  export interface MembershipPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MembershipPlan'], meta: { name: 'MembershipPlan' } }
    /**
     * Find zero or one MembershipPlan that matches the filter.
     * @param {MembershipPlanFindUniqueArgs} args - Arguments to find a MembershipPlan
     * @example
     * // Get one MembershipPlan
     * const membershipPlan = await prisma.membershipPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MembershipPlanFindUniqueArgs>(args: SelectSubset<T, MembershipPlanFindUniqueArgs<ExtArgs>>): Prisma__MembershipPlanClient<$Result.GetResult<Prisma.$MembershipPlanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MembershipPlan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MembershipPlanFindUniqueOrThrowArgs} args - Arguments to find a MembershipPlan
     * @example
     * // Get one MembershipPlan
     * const membershipPlan = await prisma.membershipPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MembershipPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, MembershipPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MembershipPlanClient<$Result.GetResult<Prisma.$MembershipPlanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MembershipPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipPlanFindFirstArgs} args - Arguments to find a MembershipPlan
     * @example
     * // Get one MembershipPlan
     * const membershipPlan = await prisma.membershipPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MembershipPlanFindFirstArgs>(args?: SelectSubset<T, MembershipPlanFindFirstArgs<ExtArgs>>): Prisma__MembershipPlanClient<$Result.GetResult<Prisma.$MembershipPlanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MembershipPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipPlanFindFirstOrThrowArgs} args - Arguments to find a MembershipPlan
     * @example
     * // Get one MembershipPlan
     * const membershipPlan = await prisma.membershipPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MembershipPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, MembershipPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__MembershipPlanClient<$Result.GetResult<Prisma.$MembershipPlanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MembershipPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MembershipPlans
     * const membershipPlans = await prisma.membershipPlan.findMany()
     * 
     * // Get first 10 MembershipPlans
     * const membershipPlans = await prisma.membershipPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const membershipPlanWithIdOnly = await prisma.membershipPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MembershipPlanFindManyArgs>(args?: SelectSubset<T, MembershipPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipPlanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MembershipPlan.
     * @param {MembershipPlanCreateArgs} args - Arguments to create a MembershipPlan.
     * @example
     * // Create one MembershipPlan
     * const MembershipPlan = await prisma.membershipPlan.create({
     *   data: {
     *     // ... data to create a MembershipPlan
     *   }
     * })
     * 
     */
    create<T extends MembershipPlanCreateArgs>(args: SelectSubset<T, MembershipPlanCreateArgs<ExtArgs>>): Prisma__MembershipPlanClient<$Result.GetResult<Prisma.$MembershipPlanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MembershipPlans.
     * @param {MembershipPlanCreateManyArgs} args - Arguments to create many MembershipPlans.
     * @example
     * // Create many MembershipPlans
     * const membershipPlan = await prisma.membershipPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MembershipPlanCreateManyArgs>(args?: SelectSubset<T, MembershipPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MembershipPlan.
     * @param {MembershipPlanDeleteArgs} args - Arguments to delete one MembershipPlan.
     * @example
     * // Delete one MembershipPlan
     * const MembershipPlan = await prisma.membershipPlan.delete({
     *   where: {
     *     // ... filter to delete one MembershipPlan
     *   }
     * })
     * 
     */
    delete<T extends MembershipPlanDeleteArgs>(args: SelectSubset<T, MembershipPlanDeleteArgs<ExtArgs>>): Prisma__MembershipPlanClient<$Result.GetResult<Prisma.$MembershipPlanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MembershipPlan.
     * @param {MembershipPlanUpdateArgs} args - Arguments to update one MembershipPlan.
     * @example
     * // Update one MembershipPlan
     * const membershipPlan = await prisma.membershipPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MembershipPlanUpdateArgs>(args: SelectSubset<T, MembershipPlanUpdateArgs<ExtArgs>>): Prisma__MembershipPlanClient<$Result.GetResult<Prisma.$MembershipPlanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MembershipPlans.
     * @param {MembershipPlanDeleteManyArgs} args - Arguments to filter MembershipPlans to delete.
     * @example
     * // Delete a few MembershipPlans
     * const { count } = await prisma.membershipPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MembershipPlanDeleteManyArgs>(args?: SelectSubset<T, MembershipPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MembershipPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MembershipPlans
     * const membershipPlan = await prisma.membershipPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MembershipPlanUpdateManyArgs>(args: SelectSubset<T, MembershipPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MembershipPlan.
     * @param {MembershipPlanUpsertArgs} args - Arguments to update or create a MembershipPlan.
     * @example
     * // Update or create a MembershipPlan
     * const membershipPlan = await prisma.membershipPlan.upsert({
     *   create: {
     *     // ... data to create a MembershipPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MembershipPlan we want to update
     *   }
     * })
     */
    upsert<T extends MembershipPlanUpsertArgs>(args: SelectSubset<T, MembershipPlanUpsertArgs<ExtArgs>>): Prisma__MembershipPlanClient<$Result.GetResult<Prisma.$MembershipPlanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MembershipPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipPlanCountArgs} args - Arguments to filter MembershipPlans to count.
     * @example
     * // Count the number of MembershipPlans
     * const count = await prisma.membershipPlan.count({
     *   where: {
     *     // ... the filter for the MembershipPlans we want to count
     *   }
     * })
    **/
    count<T extends MembershipPlanCountArgs>(
      args?: Subset<T, MembershipPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MembershipPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MembershipPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MembershipPlanAggregateArgs>(args: Subset<T, MembershipPlanAggregateArgs>): Prisma.PrismaPromise<GetMembershipPlanAggregateType<T>>

    /**
     * Group by MembershipPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MembershipPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MembershipPlanGroupByArgs['orderBy'] }
        : { orderBy?: MembershipPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MembershipPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMembershipPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MembershipPlan model
   */
  readonly fields: MembershipPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MembershipPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MembershipPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends MembershipPlan$usersArgs<ExtArgs> = {}>(args?: Subset<T, MembershipPlan$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MembershipPlan model
   */ 
  interface MembershipPlanFieldRefs {
    readonly id: FieldRef<"MembershipPlan", 'String'>
    readonly name: FieldRef<"MembershipPlan", 'String'>
    readonly slug: FieldRef<"MembershipPlan", 'String'>
    readonly description: FieldRef<"MembershipPlan", 'String'>
    readonly price: FieldRef<"MembershipPlan", 'Float'>
    readonly originalPrice: FieldRef<"MembershipPlan", 'Float'>
    readonly currency: FieldRef<"MembershipPlan", 'String'>
    readonly duration: FieldRef<"MembershipPlan", 'Int'>
    readonly features: FieldRef<"MembershipPlan", 'Json'>
    readonly limits: FieldRef<"MembershipPlan", 'Json'>
    readonly isActive: FieldRef<"MembershipPlan", 'Boolean'>
    readonly isFeatured: FieldRef<"MembershipPlan", 'Boolean'>
    readonly sortOrder: FieldRef<"MembershipPlan", 'Int'>
    readonly createdAt: FieldRef<"MembershipPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"MembershipPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MembershipPlan findUnique
   */
  export type MembershipPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlan
     */
    select?: MembershipPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipPlanInclude<ExtArgs> | null
    /**
     * Filter, which MembershipPlan to fetch.
     */
    where: MembershipPlanWhereUniqueInput
  }

  /**
   * MembershipPlan findUniqueOrThrow
   */
  export type MembershipPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlan
     */
    select?: MembershipPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipPlanInclude<ExtArgs> | null
    /**
     * Filter, which MembershipPlan to fetch.
     */
    where: MembershipPlanWhereUniqueInput
  }

  /**
   * MembershipPlan findFirst
   */
  export type MembershipPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlan
     */
    select?: MembershipPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipPlanInclude<ExtArgs> | null
    /**
     * Filter, which MembershipPlan to fetch.
     */
    where?: MembershipPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MembershipPlans to fetch.
     */
    orderBy?: MembershipPlanOrderByWithRelationInput | MembershipPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MembershipPlans.
     */
    cursor?: MembershipPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MembershipPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MembershipPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MembershipPlans.
     */
    distinct?: MembershipPlanScalarFieldEnum | MembershipPlanScalarFieldEnum[]
  }

  /**
   * MembershipPlan findFirstOrThrow
   */
  export type MembershipPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlan
     */
    select?: MembershipPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipPlanInclude<ExtArgs> | null
    /**
     * Filter, which MembershipPlan to fetch.
     */
    where?: MembershipPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MembershipPlans to fetch.
     */
    orderBy?: MembershipPlanOrderByWithRelationInput | MembershipPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MembershipPlans.
     */
    cursor?: MembershipPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MembershipPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MembershipPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MembershipPlans.
     */
    distinct?: MembershipPlanScalarFieldEnum | MembershipPlanScalarFieldEnum[]
  }

  /**
   * MembershipPlan findMany
   */
  export type MembershipPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlan
     */
    select?: MembershipPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipPlanInclude<ExtArgs> | null
    /**
     * Filter, which MembershipPlans to fetch.
     */
    where?: MembershipPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MembershipPlans to fetch.
     */
    orderBy?: MembershipPlanOrderByWithRelationInput | MembershipPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MembershipPlans.
     */
    cursor?: MembershipPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MembershipPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MembershipPlans.
     */
    skip?: number
    distinct?: MembershipPlanScalarFieldEnum | MembershipPlanScalarFieldEnum[]
  }

  /**
   * MembershipPlan create
   */
  export type MembershipPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlan
     */
    select?: MembershipPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a MembershipPlan.
     */
    data: XOR<MembershipPlanCreateInput, MembershipPlanUncheckedCreateInput>
  }

  /**
   * MembershipPlan createMany
   */
  export type MembershipPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MembershipPlans.
     */
    data: MembershipPlanCreateManyInput | MembershipPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MembershipPlan update
   */
  export type MembershipPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlan
     */
    select?: MembershipPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a MembershipPlan.
     */
    data: XOR<MembershipPlanUpdateInput, MembershipPlanUncheckedUpdateInput>
    /**
     * Choose, which MembershipPlan to update.
     */
    where: MembershipPlanWhereUniqueInput
  }

  /**
   * MembershipPlan updateMany
   */
  export type MembershipPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MembershipPlans.
     */
    data: XOR<MembershipPlanUpdateManyMutationInput, MembershipPlanUncheckedUpdateManyInput>
    /**
     * Filter which MembershipPlans to update
     */
    where?: MembershipPlanWhereInput
  }

  /**
   * MembershipPlan upsert
   */
  export type MembershipPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlan
     */
    select?: MembershipPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the MembershipPlan to update in case it exists.
     */
    where: MembershipPlanWhereUniqueInput
    /**
     * In case the MembershipPlan found by the `where` argument doesn't exist, create a new MembershipPlan with this data.
     */
    create: XOR<MembershipPlanCreateInput, MembershipPlanUncheckedCreateInput>
    /**
     * In case the MembershipPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MembershipPlanUpdateInput, MembershipPlanUncheckedUpdateInput>
  }

  /**
   * MembershipPlan delete
   */
  export type MembershipPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlan
     */
    select?: MembershipPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipPlanInclude<ExtArgs> | null
    /**
     * Filter which MembershipPlan to delete.
     */
    where: MembershipPlanWhereUniqueInput
  }

  /**
   * MembershipPlan deleteMany
   */
  export type MembershipPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MembershipPlans to delete
     */
    where?: MembershipPlanWhereInput
  }

  /**
   * MembershipPlan.users
   */
  export type MembershipPlan$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * MembershipPlan without action
   */
  export type MembershipPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlan
     */
    select?: MembershipPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipPlanInclude<ExtArgs> | null
  }


  /**
   * Model PointsConfig
   */

  export type AggregatePointsConfig = {
    _count: PointsConfigCountAggregateOutputType | null
    _avg: PointsConfigAvgAggregateOutputType | null
    _sum: PointsConfigSumAggregateOutputType | null
    _min: PointsConfigMinAggregateOutputType | null
    _max: PointsConfigMaxAggregateOutputType | null
  }

  export type PointsConfigAvgAggregateOutputType = {
    points: number | null
    dailyLimit: number | null
    totalLimit: number | null
  }

  export type PointsConfigSumAggregateOutputType = {
    points: number | null
    dailyLimit: number | null
    totalLimit: number | null
  }

  export type PointsConfigMinAggregateOutputType = {
    id: string | null
    key: string | null
    name: string | null
    description: string | null
    points: number | null
    isEnabled: boolean | null
    dailyLimit: number | null
    totalLimit: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PointsConfigMaxAggregateOutputType = {
    id: string | null
    key: string | null
    name: string | null
    description: string | null
    points: number | null
    isEnabled: boolean | null
    dailyLimit: number | null
    totalLimit: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PointsConfigCountAggregateOutputType = {
    id: number
    key: number
    name: number
    description: number
    points: number
    isEnabled: number
    dailyLimit: number
    totalLimit: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PointsConfigAvgAggregateInputType = {
    points?: true
    dailyLimit?: true
    totalLimit?: true
  }

  export type PointsConfigSumAggregateInputType = {
    points?: true
    dailyLimit?: true
    totalLimit?: true
  }

  export type PointsConfigMinAggregateInputType = {
    id?: true
    key?: true
    name?: true
    description?: true
    points?: true
    isEnabled?: true
    dailyLimit?: true
    totalLimit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PointsConfigMaxAggregateInputType = {
    id?: true
    key?: true
    name?: true
    description?: true
    points?: true
    isEnabled?: true
    dailyLimit?: true
    totalLimit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PointsConfigCountAggregateInputType = {
    id?: true
    key?: true
    name?: true
    description?: true
    points?: true
    isEnabled?: true
    dailyLimit?: true
    totalLimit?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PointsConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PointsConfig to aggregate.
     */
    where?: PointsConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointsConfigs to fetch.
     */
    orderBy?: PointsConfigOrderByWithRelationInput | PointsConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PointsConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointsConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointsConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PointsConfigs
    **/
    _count?: true | PointsConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PointsConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PointsConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PointsConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PointsConfigMaxAggregateInputType
  }

  export type GetPointsConfigAggregateType<T extends PointsConfigAggregateArgs> = {
        [P in keyof T & keyof AggregatePointsConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePointsConfig[P]>
      : GetScalarType<T[P], AggregatePointsConfig[P]>
  }




  export type PointsConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PointsConfigWhereInput
    orderBy?: PointsConfigOrderByWithAggregationInput | PointsConfigOrderByWithAggregationInput[]
    by: PointsConfigScalarFieldEnum[] | PointsConfigScalarFieldEnum
    having?: PointsConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PointsConfigCountAggregateInputType | true
    _avg?: PointsConfigAvgAggregateInputType
    _sum?: PointsConfigSumAggregateInputType
    _min?: PointsConfigMinAggregateInputType
    _max?: PointsConfigMaxAggregateInputType
  }

  export type PointsConfigGroupByOutputType = {
    id: string
    key: string
    name: string
    description: string | null
    points: number
    isEnabled: boolean
    dailyLimit: number | null
    totalLimit: number | null
    createdAt: Date
    updatedAt: Date
    _count: PointsConfigCountAggregateOutputType | null
    _avg: PointsConfigAvgAggregateOutputType | null
    _sum: PointsConfigSumAggregateOutputType | null
    _min: PointsConfigMinAggregateOutputType | null
    _max: PointsConfigMaxAggregateOutputType | null
  }

  type GetPointsConfigGroupByPayload<T extends PointsConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PointsConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PointsConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PointsConfigGroupByOutputType[P]>
            : GetScalarType<T[P], PointsConfigGroupByOutputType[P]>
        }
      >
    >


  export type PointsConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    name?: boolean
    description?: boolean
    points?: boolean
    isEnabled?: boolean
    dailyLimit?: boolean
    totalLimit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["pointsConfig"]>


  export type PointsConfigSelectScalar = {
    id?: boolean
    key?: boolean
    name?: boolean
    description?: boolean
    points?: boolean
    isEnabled?: boolean
    dailyLimit?: boolean
    totalLimit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $PointsConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PointsConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      name: string
      description: string | null
      points: number
      isEnabled: boolean
      dailyLimit: number | null
      totalLimit: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pointsConfig"]>
    composites: {}
  }

  type PointsConfigGetPayload<S extends boolean | null | undefined | PointsConfigDefaultArgs> = $Result.GetResult<Prisma.$PointsConfigPayload, S>

  type PointsConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PointsConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PointsConfigCountAggregateInputType | true
    }

  export interface PointsConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PointsConfig'], meta: { name: 'PointsConfig' } }
    /**
     * Find zero or one PointsConfig that matches the filter.
     * @param {PointsConfigFindUniqueArgs} args - Arguments to find a PointsConfig
     * @example
     * // Get one PointsConfig
     * const pointsConfig = await prisma.pointsConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PointsConfigFindUniqueArgs>(args: SelectSubset<T, PointsConfigFindUniqueArgs<ExtArgs>>): Prisma__PointsConfigClient<$Result.GetResult<Prisma.$PointsConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PointsConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PointsConfigFindUniqueOrThrowArgs} args - Arguments to find a PointsConfig
     * @example
     * // Get one PointsConfig
     * const pointsConfig = await prisma.pointsConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PointsConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, PointsConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PointsConfigClient<$Result.GetResult<Prisma.$PointsConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PointsConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsConfigFindFirstArgs} args - Arguments to find a PointsConfig
     * @example
     * // Get one PointsConfig
     * const pointsConfig = await prisma.pointsConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PointsConfigFindFirstArgs>(args?: SelectSubset<T, PointsConfigFindFirstArgs<ExtArgs>>): Prisma__PointsConfigClient<$Result.GetResult<Prisma.$PointsConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PointsConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsConfigFindFirstOrThrowArgs} args - Arguments to find a PointsConfig
     * @example
     * // Get one PointsConfig
     * const pointsConfig = await prisma.pointsConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PointsConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, PointsConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__PointsConfigClient<$Result.GetResult<Prisma.$PointsConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PointsConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PointsConfigs
     * const pointsConfigs = await prisma.pointsConfig.findMany()
     * 
     * // Get first 10 PointsConfigs
     * const pointsConfigs = await prisma.pointsConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pointsConfigWithIdOnly = await prisma.pointsConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PointsConfigFindManyArgs>(args?: SelectSubset<T, PointsConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointsConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PointsConfig.
     * @param {PointsConfigCreateArgs} args - Arguments to create a PointsConfig.
     * @example
     * // Create one PointsConfig
     * const PointsConfig = await prisma.pointsConfig.create({
     *   data: {
     *     // ... data to create a PointsConfig
     *   }
     * })
     * 
     */
    create<T extends PointsConfigCreateArgs>(args: SelectSubset<T, PointsConfigCreateArgs<ExtArgs>>): Prisma__PointsConfigClient<$Result.GetResult<Prisma.$PointsConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PointsConfigs.
     * @param {PointsConfigCreateManyArgs} args - Arguments to create many PointsConfigs.
     * @example
     * // Create many PointsConfigs
     * const pointsConfig = await prisma.pointsConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PointsConfigCreateManyArgs>(args?: SelectSubset<T, PointsConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PointsConfig.
     * @param {PointsConfigDeleteArgs} args - Arguments to delete one PointsConfig.
     * @example
     * // Delete one PointsConfig
     * const PointsConfig = await prisma.pointsConfig.delete({
     *   where: {
     *     // ... filter to delete one PointsConfig
     *   }
     * })
     * 
     */
    delete<T extends PointsConfigDeleteArgs>(args: SelectSubset<T, PointsConfigDeleteArgs<ExtArgs>>): Prisma__PointsConfigClient<$Result.GetResult<Prisma.$PointsConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PointsConfig.
     * @param {PointsConfigUpdateArgs} args - Arguments to update one PointsConfig.
     * @example
     * // Update one PointsConfig
     * const pointsConfig = await prisma.pointsConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PointsConfigUpdateArgs>(args: SelectSubset<T, PointsConfigUpdateArgs<ExtArgs>>): Prisma__PointsConfigClient<$Result.GetResult<Prisma.$PointsConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PointsConfigs.
     * @param {PointsConfigDeleteManyArgs} args - Arguments to filter PointsConfigs to delete.
     * @example
     * // Delete a few PointsConfigs
     * const { count } = await prisma.pointsConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PointsConfigDeleteManyArgs>(args?: SelectSubset<T, PointsConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PointsConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PointsConfigs
     * const pointsConfig = await prisma.pointsConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PointsConfigUpdateManyArgs>(args: SelectSubset<T, PointsConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PointsConfig.
     * @param {PointsConfigUpsertArgs} args - Arguments to update or create a PointsConfig.
     * @example
     * // Update or create a PointsConfig
     * const pointsConfig = await prisma.pointsConfig.upsert({
     *   create: {
     *     // ... data to create a PointsConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PointsConfig we want to update
     *   }
     * })
     */
    upsert<T extends PointsConfigUpsertArgs>(args: SelectSubset<T, PointsConfigUpsertArgs<ExtArgs>>): Prisma__PointsConfigClient<$Result.GetResult<Prisma.$PointsConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PointsConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsConfigCountArgs} args - Arguments to filter PointsConfigs to count.
     * @example
     * // Count the number of PointsConfigs
     * const count = await prisma.pointsConfig.count({
     *   where: {
     *     // ... the filter for the PointsConfigs we want to count
     *   }
     * })
    **/
    count<T extends PointsConfigCountArgs>(
      args?: Subset<T, PointsConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PointsConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PointsConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PointsConfigAggregateArgs>(args: Subset<T, PointsConfigAggregateArgs>): Prisma.PrismaPromise<GetPointsConfigAggregateType<T>>

    /**
     * Group by PointsConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointsConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PointsConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PointsConfigGroupByArgs['orderBy'] }
        : { orderBy?: PointsConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PointsConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPointsConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PointsConfig model
   */
  readonly fields: PointsConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PointsConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PointsConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PointsConfig model
   */ 
  interface PointsConfigFieldRefs {
    readonly id: FieldRef<"PointsConfig", 'String'>
    readonly key: FieldRef<"PointsConfig", 'String'>
    readonly name: FieldRef<"PointsConfig", 'String'>
    readonly description: FieldRef<"PointsConfig", 'String'>
    readonly points: FieldRef<"PointsConfig", 'Int'>
    readonly isEnabled: FieldRef<"PointsConfig", 'Boolean'>
    readonly dailyLimit: FieldRef<"PointsConfig", 'Int'>
    readonly totalLimit: FieldRef<"PointsConfig", 'Int'>
    readonly createdAt: FieldRef<"PointsConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"PointsConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PointsConfig findUnique
   */
  export type PointsConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsConfig
     */
    select?: PointsConfigSelect<ExtArgs> | null
    /**
     * Filter, which PointsConfig to fetch.
     */
    where: PointsConfigWhereUniqueInput
  }

  /**
   * PointsConfig findUniqueOrThrow
   */
  export type PointsConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsConfig
     */
    select?: PointsConfigSelect<ExtArgs> | null
    /**
     * Filter, which PointsConfig to fetch.
     */
    where: PointsConfigWhereUniqueInput
  }

  /**
   * PointsConfig findFirst
   */
  export type PointsConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsConfig
     */
    select?: PointsConfigSelect<ExtArgs> | null
    /**
     * Filter, which PointsConfig to fetch.
     */
    where?: PointsConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointsConfigs to fetch.
     */
    orderBy?: PointsConfigOrderByWithRelationInput | PointsConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PointsConfigs.
     */
    cursor?: PointsConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointsConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointsConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PointsConfigs.
     */
    distinct?: PointsConfigScalarFieldEnum | PointsConfigScalarFieldEnum[]
  }

  /**
   * PointsConfig findFirstOrThrow
   */
  export type PointsConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsConfig
     */
    select?: PointsConfigSelect<ExtArgs> | null
    /**
     * Filter, which PointsConfig to fetch.
     */
    where?: PointsConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointsConfigs to fetch.
     */
    orderBy?: PointsConfigOrderByWithRelationInput | PointsConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PointsConfigs.
     */
    cursor?: PointsConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointsConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointsConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PointsConfigs.
     */
    distinct?: PointsConfigScalarFieldEnum | PointsConfigScalarFieldEnum[]
  }

  /**
   * PointsConfig findMany
   */
  export type PointsConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsConfig
     */
    select?: PointsConfigSelect<ExtArgs> | null
    /**
     * Filter, which PointsConfigs to fetch.
     */
    where?: PointsConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointsConfigs to fetch.
     */
    orderBy?: PointsConfigOrderByWithRelationInput | PointsConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PointsConfigs.
     */
    cursor?: PointsConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointsConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointsConfigs.
     */
    skip?: number
    distinct?: PointsConfigScalarFieldEnum | PointsConfigScalarFieldEnum[]
  }

  /**
   * PointsConfig create
   */
  export type PointsConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsConfig
     */
    select?: PointsConfigSelect<ExtArgs> | null
    /**
     * The data needed to create a PointsConfig.
     */
    data: XOR<PointsConfigCreateInput, PointsConfigUncheckedCreateInput>
  }

  /**
   * PointsConfig createMany
   */
  export type PointsConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PointsConfigs.
     */
    data: PointsConfigCreateManyInput | PointsConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PointsConfig update
   */
  export type PointsConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsConfig
     */
    select?: PointsConfigSelect<ExtArgs> | null
    /**
     * The data needed to update a PointsConfig.
     */
    data: XOR<PointsConfigUpdateInput, PointsConfigUncheckedUpdateInput>
    /**
     * Choose, which PointsConfig to update.
     */
    where: PointsConfigWhereUniqueInput
  }

  /**
   * PointsConfig updateMany
   */
  export type PointsConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PointsConfigs.
     */
    data: XOR<PointsConfigUpdateManyMutationInput, PointsConfigUncheckedUpdateManyInput>
    /**
     * Filter which PointsConfigs to update
     */
    where?: PointsConfigWhereInput
  }

  /**
   * PointsConfig upsert
   */
  export type PointsConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsConfig
     */
    select?: PointsConfigSelect<ExtArgs> | null
    /**
     * The filter to search for the PointsConfig to update in case it exists.
     */
    where: PointsConfigWhereUniqueInput
    /**
     * In case the PointsConfig found by the `where` argument doesn't exist, create a new PointsConfig with this data.
     */
    create: XOR<PointsConfigCreateInput, PointsConfigUncheckedCreateInput>
    /**
     * In case the PointsConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PointsConfigUpdateInput, PointsConfigUncheckedUpdateInput>
  }

  /**
   * PointsConfig delete
   */
  export type PointsConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsConfig
     */
    select?: PointsConfigSelect<ExtArgs> | null
    /**
     * Filter which PointsConfig to delete.
     */
    where: PointsConfigWhereUniqueInput
  }

  /**
   * PointsConfig deleteMany
   */
  export type PointsConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PointsConfigs to delete
     */
    where?: PointsConfigWhereInput
  }

  /**
   * PointsConfig without action
   */
  export type PointsConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointsConfig
     */
    select?: PointsConfigSelect<ExtArgs> | null
  }


  /**
   * Model PointRecord
   */

  export type AggregatePointRecord = {
    _count: PointRecordCountAggregateOutputType | null
    _avg: PointRecordAvgAggregateOutputType | null
    _sum: PointRecordSumAggregateOutputType | null
    _min: PointRecordMinAggregateOutputType | null
    _max: PointRecordMaxAggregateOutputType | null
  }

  export type PointRecordAvgAggregateOutputType = {
    points: number | null
    balance: number | null
  }

  export type PointRecordSumAggregateOutputType = {
    points: number | null
    balance: number | null
  }

  export type PointRecordMinAggregateOutputType = {
    id: string | null
    userId: string | null
    points: number | null
    balance: number | null
    type: $Enums.PointType | null
    description: string | null
    relatedId: string | null
    createdAt: Date | null
  }

  export type PointRecordMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    points: number | null
    balance: number | null
    type: $Enums.PointType | null
    description: string | null
    relatedId: string | null
    createdAt: Date | null
  }

  export type PointRecordCountAggregateOutputType = {
    id: number
    userId: number
    points: number
    balance: number
    type: number
    description: number
    relatedId: number
    createdAt: number
    _all: number
  }


  export type PointRecordAvgAggregateInputType = {
    points?: true
    balance?: true
  }

  export type PointRecordSumAggregateInputType = {
    points?: true
    balance?: true
  }

  export type PointRecordMinAggregateInputType = {
    id?: true
    userId?: true
    points?: true
    balance?: true
    type?: true
    description?: true
    relatedId?: true
    createdAt?: true
  }

  export type PointRecordMaxAggregateInputType = {
    id?: true
    userId?: true
    points?: true
    balance?: true
    type?: true
    description?: true
    relatedId?: true
    createdAt?: true
  }

  export type PointRecordCountAggregateInputType = {
    id?: true
    userId?: true
    points?: true
    balance?: true
    type?: true
    description?: true
    relatedId?: true
    createdAt?: true
    _all?: true
  }

  export type PointRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PointRecord to aggregate.
     */
    where?: PointRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointRecords to fetch.
     */
    orderBy?: PointRecordOrderByWithRelationInput | PointRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PointRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PointRecords
    **/
    _count?: true | PointRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PointRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PointRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PointRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PointRecordMaxAggregateInputType
  }

  export type GetPointRecordAggregateType<T extends PointRecordAggregateArgs> = {
        [P in keyof T & keyof AggregatePointRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePointRecord[P]>
      : GetScalarType<T[P], AggregatePointRecord[P]>
  }




  export type PointRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PointRecordWhereInput
    orderBy?: PointRecordOrderByWithAggregationInput | PointRecordOrderByWithAggregationInput[]
    by: PointRecordScalarFieldEnum[] | PointRecordScalarFieldEnum
    having?: PointRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PointRecordCountAggregateInputType | true
    _avg?: PointRecordAvgAggregateInputType
    _sum?: PointRecordSumAggregateInputType
    _min?: PointRecordMinAggregateInputType
    _max?: PointRecordMaxAggregateInputType
  }

  export type PointRecordGroupByOutputType = {
    id: string
    userId: string
    points: number
    balance: number
    type: $Enums.PointType
    description: string
    relatedId: string | null
    createdAt: Date
    _count: PointRecordCountAggregateOutputType | null
    _avg: PointRecordAvgAggregateOutputType | null
    _sum: PointRecordSumAggregateOutputType | null
    _min: PointRecordMinAggregateOutputType | null
    _max: PointRecordMaxAggregateOutputType | null
  }

  type GetPointRecordGroupByPayload<T extends PointRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PointRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PointRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PointRecordGroupByOutputType[P]>
            : GetScalarType<T[P], PointRecordGroupByOutputType[P]>
        }
      >
    >


  export type PointRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    points?: boolean
    balance?: boolean
    type?: boolean
    description?: boolean
    relatedId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pointRecord"]>


  export type PointRecordSelectScalar = {
    id?: boolean
    userId?: boolean
    points?: boolean
    balance?: boolean
    type?: boolean
    description?: boolean
    relatedId?: boolean
    createdAt?: boolean
  }

  export type PointRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PointRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PointRecord"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      points: number
      balance: number
      type: $Enums.PointType
      description: string
      relatedId: string | null
      createdAt: Date
    }, ExtArgs["result"]["pointRecord"]>
    composites: {}
  }

  type PointRecordGetPayload<S extends boolean | null | undefined | PointRecordDefaultArgs> = $Result.GetResult<Prisma.$PointRecordPayload, S>

  type PointRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PointRecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PointRecordCountAggregateInputType | true
    }

  export interface PointRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PointRecord'], meta: { name: 'PointRecord' } }
    /**
     * Find zero or one PointRecord that matches the filter.
     * @param {PointRecordFindUniqueArgs} args - Arguments to find a PointRecord
     * @example
     * // Get one PointRecord
     * const pointRecord = await prisma.pointRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PointRecordFindUniqueArgs>(args: SelectSubset<T, PointRecordFindUniqueArgs<ExtArgs>>): Prisma__PointRecordClient<$Result.GetResult<Prisma.$PointRecordPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PointRecord that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PointRecordFindUniqueOrThrowArgs} args - Arguments to find a PointRecord
     * @example
     * // Get one PointRecord
     * const pointRecord = await prisma.pointRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PointRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, PointRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PointRecordClient<$Result.GetResult<Prisma.$PointRecordPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PointRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointRecordFindFirstArgs} args - Arguments to find a PointRecord
     * @example
     * // Get one PointRecord
     * const pointRecord = await prisma.pointRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PointRecordFindFirstArgs>(args?: SelectSubset<T, PointRecordFindFirstArgs<ExtArgs>>): Prisma__PointRecordClient<$Result.GetResult<Prisma.$PointRecordPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PointRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointRecordFindFirstOrThrowArgs} args - Arguments to find a PointRecord
     * @example
     * // Get one PointRecord
     * const pointRecord = await prisma.pointRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PointRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, PointRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__PointRecordClient<$Result.GetResult<Prisma.$PointRecordPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PointRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PointRecords
     * const pointRecords = await prisma.pointRecord.findMany()
     * 
     * // Get first 10 PointRecords
     * const pointRecords = await prisma.pointRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pointRecordWithIdOnly = await prisma.pointRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PointRecordFindManyArgs>(args?: SelectSubset<T, PointRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointRecordPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PointRecord.
     * @param {PointRecordCreateArgs} args - Arguments to create a PointRecord.
     * @example
     * // Create one PointRecord
     * const PointRecord = await prisma.pointRecord.create({
     *   data: {
     *     // ... data to create a PointRecord
     *   }
     * })
     * 
     */
    create<T extends PointRecordCreateArgs>(args: SelectSubset<T, PointRecordCreateArgs<ExtArgs>>): Prisma__PointRecordClient<$Result.GetResult<Prisma.$PointRecordPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PointRecords.
     * @param {PointRecordCreateManyArgs} args - Arguments to create many PointRecords.
     * @example
     * // Create many PointRecords
     * const pointRecord = await prisma.pointRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PointRecordCreateManyArgs>(args?: SelectSubset<T, PointRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PointRecord.
     * @param {PointRecordDeleteArgs} args - Arguments to delete one PointRecord.
     * @example
     * // Delete one PointRecord
     * const PointRecord = await prisma.pointRecord.delete({
     *   where: {
     *     // ... filter to delete one PointRecord
     *   }
     * })
     * 
     */
    delete<T extends PointRecordDeleteArgs>(args: SelectSubset<T, PointRecordDeleteArgs<ExtArgs>>): Prisma__PointRecordClient<$Result.GetResult<Prisma.$PointRecordPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PointRecord.
     * @param {PointRecordUpdateArgs} args - Arguments to update one PointRecord.
     * @example
     * // Update one PointRecord
     * const pointRecord = await prisma.pointRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PointRecordUpdateArgs>(args: SelectSubset<T, PointRecordUpdateArgs<ExtArgs>>): Prisma__PointRecordClient<$Result.GetResult<Prisma.$PointRecordPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PointRecords.
     * @param {PointRecordDeleteManyArgs} args - Arguments to filter PointRecords to delete.
     * @example
     * // Delete a few PointRecords
     * const { count } = await prisma.pointRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PointRecordDeleteManyArgs>(args?: SelectSubset<T, PointRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PointRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PointRecords
     * const pointRecord = await prisma.pointRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PointRecordUpdateManyArgs>(args: SelectSubset<T, PointRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PointRecord.
     * @param {PointRecordUpsertArgs} args - Arguments to update or create a PointRecord.
     * @example
     * // Update or create a PointRecord
     * const pointRecord = await prisma.pointRecord.upsert({
     *   create: {
     *     // ... data to create a PointRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PointRecord we want to update
     *   }
     * })
     */
    upsert<T extends PointRecordUpsertArgs>(args: SelectSubset<T, PointRecordUpsertArgs<ExtArgs>>): Prisma__PointRecordClient<$Result.GetResult<Prisma.$PointRecordPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PointRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointRecordCountArgs} args - Arguments to filter PointRecords to count.
     * @example
     * // Count the number of PointRecords
     * const count = await prisma.pointRecord.count({
     *   where: {
     *     // ... the filter for the PointRecords we want to count
     *   }
     * })
    **/
    count<T extends PointRecordCountArgs>(
      args?: Subset<T, PointRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PointRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PointRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PointRecordAggregateArgs>(args: Subset<T, PointRecordAggregateArgs>): Prisma.PrismaPromise<GetPointRecordAggregateType<T>>

    /**
     * Group by PointRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PointRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PointRecordGroupByArgs['orderBy'] }
        : { orderBy?: PointRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PointRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPointRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PointRecord model
   */
  readonly fields: PointRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PointRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PointRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PointRecord model
   */ 
  interface PointRecordFieldRefs {
    readonly id: FieldRef<"PointRecord", 'String'>
    readonly userId: FieldRef<"PointRecord", 'String'>
    readonly points: FieldRef<"PointRecord", 'Int'>
    readonly balance: FieldRef<"PointRecord", 'Int'>
    readonly type: FieldRef<"PointRecord", 'PointType'>
    readonly description: FieldRef<"PointRecord", 'String'>
    readonly relatedId: FieldRef<"PointRecord", 'String'>
    readonly createdAt: FieldRef<"PointRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PointRecord findUnique
   */
  export type PointRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointRecord
     */
    select?: PointRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointRecordInclude<ExtArgs> | null
    /**
     * Filter, which PointRecord to fetch.
     */
    where: PointRecordWhereUniqueInput
  }

  /**
   * PointRecord findUniqueOrThrow
   */
  export type PointRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointRecord
     */
    select?: PointRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointRecordInclude<ExtArgs> | null
    /**
     * Filter, which PointRecord to fetch.
     */
    where: PointRecordWhereUniqueInput
  }

  /**
   * PointRecord findFirst
   */
  export type PointRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointRecord
     */
    select?: PointRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointRecordInclude<ExtArgs> | null
    /**
     * Filter, which PointRecord to fetch.
     */
    where?: PointRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointRecords to fetch.
     */
    orderBy?: PointRecordOrderByWithRelationInput | PointRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PointRecords.
     */
    cursor?: PointRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PointRecords.
     */
    distinct?: PointRecordScalarFieldEnum | PointRecordScalarFieldEnum[]
  }

  /**
   * PointRecord findFirstOrThrow
   */
  export type PointRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointRecord
     */
    select?: PointRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointRecordInclude<ExtArgs> | null
    /**
     * Filter, which PointRecord to fetch.
     */
    where?: PointRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointRecords to fetch.
     */
    orderBy?: PointRecordOrderByWithRelationInput | PointRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PointRecords.
     */
    cursor?: PointRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PointRecords.
     */
    distinct?: PointRecordScalarFieldEnum | PointRecordScalarFieldEnum[]
  }

  /**
   * PointRecord findMany
   */
  export type PointRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointRecord
     */
    select?: PointRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointRecordInclude<ExtArgs> | null
    /**
     * Filter, which PointRecords to fetch.
     */
    where?: PointRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointRecords to fetch.
     */
    orderBy?: PointRecordOrderByWithRelationInput | PointRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PointRecords.
     */
    cursor?: PointRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointRecords.
     */
    skip?: number
    distinct?: PointRecordScalarFieldEnum | PointRecordScalarFieldEnum[]
  }

  /**
   * PointRecord create
   */
  export type PointRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointRecord
     */
    select?: PointRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a PointRecord.
     */
    data: XOR<PointRecordCreateInput, PointRecordUncheckedCreateInput>
  }

  /**
   * PointRecord createMany
   */
  export type PointRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PointRecords.
     */
    data: PointRecordCreateManyInput | PointRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PointRecord update
   */
  export type PointRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointRecord
     */
    select?: PointRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a PointRecord.
     */
    data: XOR<PointRecordUpdateInput, PointRecordUncheckedUpdateInput>
    /**
     * Choose, which PointRecord to update.
     */
    where: PointRecordWhereUniqueInput
  }

  /**
   * PointRecord updateMany
   */
  export type PointRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PointRecords.
     */
    data: XOR<PointRecordUpdateManyMutationInput, PointRecordUncheckedUpdateManyInput>
    /**
     * Filter which PointRecords to update
     */
    where?: PointRecordWhereInput
  }

  /**
   * PointRecord upsert
   */
  export type PointRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointRecord
     */
    select?: PointRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the PointRecord to update in case it exists.
     */
    where: PointRecordWhereUniqueInput
    /**
     * In case the PointRecord found by the `where` argument doesn't exist, create a new PointRecord with this data.
     */
    create: XOR<PointRecordCreateInput, PointRecordUncheckedCreateInput>
    /**
     * In case the PointRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PointRecordUpdateInput, PointRecordUncheckedUpdateInput>
  }

  /**
   * PointRecord delete
   */
  export type PointRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointRecord
     */
    select?: PointRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointRecordInclude<ExtArgs> | null
    /**
     * Filter which PointRecord to delete.
     */
    where: PointRecordWhereUniqueInput
  }

  /**
   * PointRecord deleteMany
   */
  export type PointRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PointRecords to delete
     */
    where?: PointRecordWhereInput
  }

  /**
   * PointRecord without action
   */
  export type PointRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointRecord
     */
    select?: PointRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointRecordInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    isSystem: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    isSystem: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    displayName: number
    description: number
    isSystem: number
    permissions: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    isSystem?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    isSystem?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    isSystem?: true
    permissions?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    name: string
    displayName: string
    description: string | null
    isSystem: boolean
    permissions: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    isSystem?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userAssignments?: boolean | Role$userAssignmentsArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>


  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    isSystem?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userAssignments?: boolean | Role$userAssignmentsArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      userAssignments: Prisma.$UserRoleAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      displayName: string
      description: string | null
      isSystem: boolean
      permissions: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userAssignments<T extends Role$userAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Role$userAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRoleAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */ 
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly name: FieldRef<"Role", 'String'>
    readonly displayName: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
    readonly isSystem: FieldRef<"Role", 'Boolean'>
    readonly permissions: FieldRef<"Role", 'Json'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly updatedAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
  }

  /**
   * Role.userAssignments
   */
  export type Role$userAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleAssignment
     */
    select?: UserRoleAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleAssignmentInclude<ExtArgs> | null
    where?: UserRoleAssignmentWhereInput
    orderBy?: UserRoleAssignmentOrderByWithRelationInput | UserRoleAssignmentOrderByWithRelationInput[]
    cursor?: UserRoleAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleAssignmentScalarFieldEnum | UserRoleAssignmentScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model UserRoleAssignment
   */

  export type AggregateUserRoleAssignment = {
    _count: UserRoleAssignmentCountAggregateOutputType | null
    _min: UserRoleAssignmentMinAggregateOutputType | null
    _max: UserRoleAssignmentMaxAggregateOutputType | null
  }

  export type UserRoleAssignmentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    roleId: string | null
    createdAt: Date | null
  }

  export type UserRoleAssignmentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    roleId: string | null
    createdAt: Date | null
  }

  export type UserRoleAssignmentCountAggregateOutputType = {
    id: number
    userId: number
    roleId: number
    createdAt: number
    _all: number
  }


  export type UserRoleAssignmentMinAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    createdAt?: true
  }

  export type UserRoleAssignmentMaxAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    createdAt?: true
  }

  export type UserRoleAssignmentCountAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    createdAt?: true
    _all?: true
  }

  export type UserRoleAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoleAssignment to aggregate.
     */
    where?: UserRoleAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoleAssignments to fetch.
     */
    orderBy?: UserRoleAssignmentOrderByWithRelationInput | UserRoleAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoleAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoleAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoleAssignments
    **/
    _count?: true | UserRoleAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleAssignmentMaxAggregateInputType
  }

  export type GetUserRoleAssignmentAggregateType<T extends UserRoleAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRoleAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRoleAssignment[P]>
      : GetScalarType<T[P], AggregateUserRoleAssignment[P]>
  }




  export type UserRoleAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleAssignmentWhereInput
    orderBy?: UserRoleAssignmentOrderByWithAggregationInput | UserRoleAssignmentOrderByWithAggregationInput[]
    by: UserRoleAssignmentScalarFieldEnum[] | UserRoleAssignmentScalarFieldEnum
    having?: UserRoleAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleAssignmentCountAggregateInputType | true
    _min?: UserRoleAssignmentMinAggregateInputType
    _max?: UserRoleAssignmentMaxAggregateInputType
  }

  export type UserRoleAssignmentGroupByOutputType = {
    id: string
    userId: string
    roleId: string
    createdAt: Date
    _count: UserRoleAssignmentCountAggregateOutputType | null
    _min: UserRoleAssignmentMinAggregateOutputType | null
    _max: UserRoleAssignmentMaxAggregateOutputType | null
  }

  type GetUserRoleAssignmentGroupByPayload<T extends UserRoleAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRoleAssignment"]>


  export type UserRoleAssignmentSelectScalar = {
    id?: boolean
    userId?: boolean
    roleId?: boolean
    createdAt?: boolean
  }

  export type UserRoleAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $UserRoleAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRoleAssignment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      roleId: string
      createdAt: Date
    }, ExtArgs["result"]["userRoleAssignment"]>
    composites: {}
  }

  type UserRoleAssignmentGetPayload<S extends boolean | null | undefined | UserRoleAssignmentDefaultArgs> = $Result.GetResult<Prisma.$UserRoleAssignmentPayload, S>

  type UserRoleAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserRoleAssignmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserRoleAssignmentCountAggregateInputType | true
    }

  export interface UserRoleAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRoleAssignment'], meta: { name: 'UserRoleAssignment' } }
    /**
     * Find zero or one UserRoleAssignment that matches the filter.
     * @param {UserRoleAssignmentFindUniqueArgs} args - Arguments to find a UserRoleAssignment
     * @example
     * // Get one UserRoleAssignment
     * const userRoleAssignment = await prisma.userRoleAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleAssignmentFindUniqueArgs>(args: SelectSubset<T, UserRoleAssignmentFindUniqueArgs<ExtArgs>>): Prisma__UserRoleAssignmentClient<$Result.GetResult<Prisma.$UserRoleAssignmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserRoleAssignment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserRoleAssignmentFindUniqueOrThrowArgs} args - Arguments to find a UserRoleAssignment
     * @example
     * // Get one UserRoleAssignment
     * const userRoleAssignment = await prisma.userRoleAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRoleAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRoleAssignmentClient<$Result.GetResult<Prisma.$UserRoleAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserRoleAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAssignmentFindFirstArgs} args - Arguments to find a UserRoleAssignment
     * @example
     * // Get one UserRoleAssignment
     * const userRoleAssignment = await prisma.userRoleAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleAssignmentFindFirstArgs>(args?: SelectSubset<T, UserRoleAssignmentFindFirstArgs<ExtArgs>>): Prisma__UserRoleAssignmentClient<$Result.GetResult<Prisma.$UserRoleAssignmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserRoleAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAssignmentFindFirstOrThrowArgs} args - Arguments to find a UserRoleAssignment
     * @example
     * // Get one UserRoleAssignment
     * const userRoleAssignment = await prisma.userRoleAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRoleAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRoleAssignmentClient<$Result.GetResult<Prisma.$UserRoleAssignmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserRoleAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoleAssignments
     * const userRoleAssignments = await prisma.userRoleAssignment.findMany()
     * 
     * // Get first 10 UserRoleAssignments
     * const userRoleAssignments = await prisma.userRoleAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userRoleAssignmentWithIdOnly = await prisma.userRoleAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserRoleAssignmentFindManyArgs>(args?: SelectSubset<T, UserRoleAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRoleAssignmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserRoleAssignment.
     * @param {UserRoleAssignmentCreateArgs} args - Arguments to create a UserRoleAssignment.
     * @example
     * // Create one UserRoleAssignment
     * const UserRoleAssignment = await prisma.userRoleAssignment.create({
     *   data: {
     *     // ... data to create a UserRoleAssignment
     *   }
     * })
     * 
     */
    create<T extends UserRoleAssignmentCreateArgs>(args: SelectSubset<T, UserRoleAssignmentCreateArgs<ExtArgs>>): Prisma__UserRoleAssignmentClient<$Result.GetResult<Prisma.$UserRoleAssignmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserRoleAssignments.
     * @param {UserRoleAssignmentCreateManyArgs} args - Arguments to create many UserRoleAssignments.
     * @example
     * // Create many UserRoleAssignments
     * const userRoleAssignment = await prisma.userRoleAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRoleAssignmentCreateManyArgs>(args?: SelectSubset<T, UserRoleAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserRoleAssignment.
     * @param {UserRoleAssignmentDeleteArgs} args - Arguments to delete one UserRoleAssignment.
     * @example
     * // Delete one UserRoleAssignment
     * const UserRoleAssignment = await prisma.userRoleAssignment.delete({
     *   where: {
     *     // ... filter to delete one UserRoleAssignment
     *   }
     * })
     * 
     */
    delete<T extends UserRoleAssignmentDeleteArgs>(args: SelectSubset<T, UserRoleAssignmentDeleteArgs<ExtArgs>>): Prisma__UserRoleAssignmentClient<$Result.GetResult<Prisma.$UserRoleAssignmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserRoleAssignment.
     * @param {UserRoleAssignmentUpdateArgs} args - Arguments to update one UserRoleAssignment.
     * @example
     * // Update one UserRoleAssignment
     * const userRoleAssignment = await prisma.userRoleAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRoleAssignmentUpdateArgs>(args: SelectSubset<T, UserRoleAssignmentUpdateArgs<ExtArgs>>): Prisma__UserRoleAssignmentClient<$Result.GetResult<Prisma.$UserRoleAssignmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserRoleAssignments.
     * @param {UserRoleAssignmentDeleteManyArgs} args - Arguments to filter UserRoleAssignments to delete.
     * @example
     * // Delete a few UserRoleAssignments
     * const { count } = await prisma.userRoleAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRoleAssignmentDeleteManyArgs>(args?: SelectSubset<T, UserRoleAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoleAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoleAssignments
     * const userRoleAssignment = await prisma.userRoleAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRoleAssignmentUpdateManyArgs>(args: SelectSubset<T, UserRoleAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserRoleAssignment.
     * @param {UserRoleAssignmentUpsertArgs} args - Arguments to update or create a UserRoleAssignment.
     * @example
     * // Update or create a UserRoleAssignment
     * const userRoleAssignment = await prisma.userRoleAssignment.upsert({
     *   create: {
     *     // ... data to create a UserRoleAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRoleAssignment we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleAssignmentUpsertArgs>(args: SelectSubset<T, UserRoleAssignmentUpsertArgs<ExtArgs>>): Prisma__UserRoleAssignmentClient<$Result.GetResult<Prisma.$UserRoleAssignmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserRoleAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAssignmentCountArgs} args - Arguments to filter UserRoleAssignments to count.
     * @example
     * // Count the number of UserRoleAssignments
     * const count = await prisma.userRoleAssignment.count({
     *   where: {
     *     // ... the filter for the UserRoleAssignments we want to count
     *   }
     * })
    **/
    count<T extends UserRoleAssignmentCountArgs>(
      args?: Subset<T, UserRoleAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRoleAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleAssignmentAggregateArgs>(args: Subset<T, UserRoleAssignmentAggregateArgs>): Prisma.PrismaPromise<GetUserRoleAssignmentAggregateType<T>>

    /**
     * Group by UserRoleAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRoleAssignment model
   */
  readonly fields: UserRoleAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRoleAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRoleAssignment model
   */ 
  interface UserRoleAssignmentFieldRefs {
    readonly id: FieldRef<"UserRoleAssignment", 'String'>
    readonly userId: FieldRef<"UserRoleAssignment", 'String'>
    readonly roleId: FieldRef<"UserRoleAssignment", 'String'>
    readonly createdAt: FieldRef<"UserRoleAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserRoleAssignment findUnique
   */
  export type UserRoleAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleAssignment
     */
    select?: UserRoleAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which UserRoleAssignment to fetch.
     */
    where: UserRoleAssignmentWhereUniqueInput
  }

  /**
   * UserRoleAssignment findUniqueOrThrow
   */
  export type UserRoleAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleAssignment
     */
    select?: UserRoleAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which UserRoleAssignment to fetch.
     */
    where: UserRoleAssignmentWhereUniqueInput
  }

  /**
   * UserRoleAssignment findFirst
   */
  export type UserRoleAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleAssignment
     */
    select?: UserRoleAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which UserRoleAssignment to fetch.
     */
    where?: UserRoleAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoleAssignments to fetch.
     */
    orderBy?: UserRoleAssignmentOrderByWithRelationInput | UserRoleAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoleAssignments.
     */
    cursor?: UserRoleAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoleAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoleAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoleAssignments.
     */
    distinct?: UserRoleAssignmentScalarFieldEnum | UserRoleAssignmentScalarFieldEnum[]
  }

  /**
   * UserRoleAssignment findFirstOrThrow
   */
  export type UserRoleAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleAssignment
     */
    select?: UserRoleAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which UserRoleAssignment to fetch.
     */
    where?: UserRoleAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoleAssignments to fetch.
     */
    orderBy?: UserRoleAssignmentOrderByWithRelationInput | UserRoleAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoleAssignments.
     */
    cursor?: UserRoleAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoleAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoleAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoleAssignments.
     */
    distinct?: UserRoleAssignmentScalarFieldEnum | UserRoleAssignmentScalarFieldEnum[]
  }

  /**
   * UserRoleAssignment findMany
   */
  export type UserRoleAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleAssignment
     */
    select?: UserRoleAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which UserRoleAssignments to fetch.
     */
    where?: UserRoleAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoleAssignments to fetch.
     */
    orderBy?: UserRoleAssignmentOrderByWithRelationInput | UserRoleAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoleAssignments.
     */
    cursor?: UserRoleAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoleAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoleAssignments.
     */
    skip?: number
    distinct?: UserRoleAssignmentScalarFieldEnum | UserRoleAssignmentScalarFieldEnum[]
  }

  /**
   * UserRoleAssignment create
   */
  export type UserRoleAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleAssignment
     */
    select?: UserRoleAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRoleAssignment.
     */
    data: XOR<UserRoleAssignmentCreateInput, UserRoleAssignmentUncheckedCreateInput>
  }

  /**
   * UserRoleAssignment createMany
   */
  export type UserRoleAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoleAssignments.
     */
    data: UserRoleAssignmentCreateManyInput | UserRoleAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRoleAssignment update
   */
  export type UserRoleAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleAssignment
     */
    select?: UserRoleAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRoleAssignment.
     */
    data: XOR<UserRoleAssignmentUpdateInput, UserRoleAssignmentUncheckedUpdateInput>
    /**
     * Choose, which UserRoleAssignment to update.
     */
    where: UserRoleAssignmentWhereUniqueInput
  }

  /**
   * UserRoleAssignment updateMany
   */
  export type UserRoleAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoleAssignments.
     */
    data: XOR<UserRoleAssignmentUpdateManyMutationInput, UserRoleAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which UserRoleAssignments to update
     */
    where?: UserRoleAssignmentWhereInput
  }

  /**
   * UserRoleAssignment upsert
   */
  export type UserRoleAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleAssignment
     */
    select?: UserRoleAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRoleAssignment to update in case it exists.
     */
    where: UserRoleAssignmentWhereUniqueInput
    /**
     * In case the UserRoleAssignment found by the `where` argument doesn't exist, create a new UserRoleAssignment with this data.
     */
    create: XOR<UserRoleAssignmentCreateInput, UserRoleAssignmentUncheckedCreateInput>
    /**
     * In case the UserRoleAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleAssignmentUpdateInput, UserRoleAssignmentUncheckedUpdateInput>
  }

  /**
   * UserRoleAssignment delete
   */
  export type UserRoleAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleAssignment
     */
    select?: UserRoleAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleAssignmentInclude<ExtArgs> | null
    /**
     * Filter which UserRoleAssignment to delete.
     */
    where: UserRoleAssignmentWhereUniqueInput
  }

  /**
   * UserRoleAssignment deleteMany
   */
  export type UserRoleAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoleAssignments to delete
     */
    where?: UserRoleAssignmentWhereInput
  }

  /**
   * UserRoleAssignment without action
   */
  export type UserRoleAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleAssignment
     */
    select?: UserRoleAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type PermissionSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type PermissionMinAggregateOutputType = {
    id: string | null
    key: string | null
    name: string | null
    description: string | null
    module: string | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: string | null
    key: string | null
    name: string | null
    description: string | null
    module: string | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    key: number
    name: number
    description: number
    module: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PermissionAvgAggregateInputType = {
    sortOrder?: true
  }

  export type PermissionSumAggregateInputType = {
    sortOrder?: true
  }

  export type PermissionMinAggregateInputType = {
    id?: true
    key?: true
    name?: true
    description?: true
    module?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    key?: true
    name?: true
    description?: true
    module?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    key?: true
    name?: true
    description?: true
    module?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _avg?: PermissionAvgAggregateInputType
    _sum?: PermissionSumAggregateInputType
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: string
    key: string
    name: string
    description: string | null
    module: string
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    name?: boolean
    description?: boolean
    module?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["permission"]>


  export type PermissionSelectScalar = {
    id?: boolean
    key?: boolean
    name?: boolean
    description?: boolean
    module?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      name: string
      description: string | null
      module: string
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */ 
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'String'>
    readonly key: FieldRef<"Permission", 'String'>
    readonly name: FieldRef<"Permission", 'String'>
    readonly description: FieldRef<"Permission", 'String'>
    readonly module: FieldRef<"Permission", 'String'>
    readonly sortOrder: FieldRef<"Permission", 'Int'>
    readonly createdAt: FieldRef<"Permission", 'DateTime'>
    readonly updatedAt: FieldRef<"Permission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
  }


  /**
   * Model Language
   */

  export type AggregateLanguage = {
    _count: LanguageCountAggregateOutputType | null
    _avg: LanguageAvgAggregateOutputType | null
    _sum: LanguageSumAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  export type LanguageAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type LanguageSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type LanguageMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    nativeName: string | null
    isEnabled: boolean | null
    isDefault: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LanguageMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    nativeName: string | null
    isEnabled: boolean | null
    isDefault: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LanguageCountAggregateOutputType = {
    id: number
    code: number
    name: number
    nativeName: number
    isEnabled: number
    isDefault: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LanguageAvgAggregateInputType = {
    sortOrder?: true
  }

  export type LanguageSumAggregateInputType = {
    sortOrder?: true
  }

  export type LanguageMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    nativeName?: true
    isEnabled?: true
    isDefault?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LanguageMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    nativeName?: true
    isEnabled?: true
    isDefault?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LanguageCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    nativeName?: true
    isEnabled?: true
    isDefault?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LanguageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Language to aggregate.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Languages
    **/
    _count?: true | LanguageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LanguageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LanguageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LanguageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LanguageMaxAggregateInputType
  }

  export type GetLanguageAggregateType<T extends LanguageAggregateArgs> = {
        [P in keyof T & keyof AggregateLanguage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLanguage[P]>
      : GetScalarType<T[P], AggregateLanguage[P]>
  }




  export type LanguageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LanguageWhereInput
    orderBy?: LanguageOrderByWithAggregationInput | LanguageOrderByWithAggregationInput[]
    by: LanguageScalarFieldEnum[] | LanguageScalarFieldEnum
    having?: LanguageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LanguageCountAggregateInputType | true
    _avg?: LanguageAvgAggregateInputType
    _sum?: LanguageSumAggregateInputType
    _min?: LanguageMinAggregateInputType
    _max?: LanguageMaxAggregateInputType
  }

  export type LanguageGroupByOutputType = {
    id: string
    code: string
    name: string
    nativeName: string
    isEnabled: boolean
    isDefault: boolean
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: LanguageCountAggregateOutputType | null
    _avg: LanguageAvgAggregateOutputType | null
    _sum: LanguageSumAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  type GetLanguageGroupByPayload<T extends LanguageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LanguageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LanguageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LanguageGroupByOutputType[P]>
            : GetScalarType<T[P], LanguageGroupByOutputType[P]>
        }
      >
    >


  export type LanguageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    nativeName?: boolean
    isEnabled?: boolean
    isDefault?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    translations?: boolean | Language$translationsArgs<ExtArgs>
    _count?: boolean | LanguageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["language"]>


  export type LanguageSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    nativeName?: boolean
    isEnabled?: boolean
    isDefault?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LanguageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translations?: boolean | Language$translationsArgs<ExtArgs>
    _count?: boolean | LanguageCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $LanguagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Language"
    objects: {
      translations: Prisma.$TranslationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      nativeName: string
      isEnabled: boolean
      isDefault: boolean
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["language"]>
    composites: {}
  }

  type LanguageGetPayload<S extends boolean | null | undefined | LanguageDefaultArgs> = $Result.GetResult<Prisma.$LanguagePayload, S>

  type LanguageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LanguageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LanguageCountAggregateInputType | true
    }

  export interface LanguageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Language'], meta: { name: 'Language' } }
    /**
     * Find zero or one Language that matches the filter.
     * @param {LanguageFindUniqueArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LanguageFindUniqueArgs>(args: SelectSubset<T, LanguageFindUniqueArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Language that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LanguageFindUniqueOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LanguageFindUniqueOrThrowArgs>(args: SelectSubset<T, LanguageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Language that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindFirstArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LanguageFindFirstArgs>(args?: SelectSubset<T, LanguageFindFirstArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Language that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindFirstOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LanguageFindFirstOrThrowArgs>(args?: SelectSubset<T, LanguageFindFirstOrThrowArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Languages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Languages
     * const languages = await prisma.language.findMany()
     * 
     * // Get first 10 Languages
     * const languages = await prisma.language.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const languageWithIdOnly = await prisma.language.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LanguageFindManyArgs>(args?: SelectSubset<T, LanguageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Language.
     * @param {LanguageCreateArgs} args - Arguments to create a Language.
     * @example
     * // Create one Language
     * const Language = await prisma.language.create({
     *   data: {
     *     // ... data to create a Language
     *   }
     * })
     * 
     */
    create<T extends LanguageCreateArgs>(args: SelectSubset<T, LanguageCreateArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Languages.
     * @param {LanguageCreateManyArgs} args - Arguments to create many Languages.
     * @example
     * // Create many Languages
     * const language = await prisma.language.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LanguageCreateManyArgs>(args?: SelectSubset<T, LanguageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Language.
     * @param {LanguageDeleteArgs} args - Arguments to delete one Language.
     * @example
     * // Delete one Language
     * const Language = await prisma.language.delete({
     *   where: {
     *     // ... filter to delete one Language
     *   }
     * })
     * 
     */
    delete<T extends LanguageDeleteArgs>(args: SelectSubset<T, LanguageDeleteArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Language.
     * @param {LanguageUpdateArgs} args - Arguments to update one Language.
     * @example
     * // Update one Language
     * const language = await prisma.language.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LanguageUpdateArgs>(args: SelectSubset<T, LanguageUpdateArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Languages.
     * @param {LanguageDeleteManyArgs} args - Arguments to filter Languages to delete.
     * @example
     * // Delete a few Languages
     * const { count } = await prisma.language.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LanguageDeleteManyArgs>(args?: SelectSubset<T, LanguageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Languages
     * const language = await prisma.language.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LanguageUpdateManyArgs>(args: SelectSubset<T, LanguageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Language.
     * @param {LanguageUpsertArgs} args - Arguments to update or create a Language.
     * @example
     * // Update or create a Language
     * const language = await prisma.language.upsert({
     *   create: {
     *     // ... data to create a Language
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Language we want to update
     *   }
     * })
     */
    upsert<T extends LanguageUpsertArgs>(args: SelectSubset<T, LanguageUpsertArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageCountArgs} args - Arguments to filter Languages to count.
     * @example
     * // Count the number of Languages
     * const count = await prisma.language.count({
     *   where: {
     *     // ... the filter for the Languages we want to count
     *   }
     * })
    **/
    count<T extends LanguageCountArgs>(
      args?: Subset<T, LanguageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LanguageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LanguageAggregateArgs>(args: Subset<T, LanguageAggregateArgs>): Prisma.PrismaPromise<GetLanguageAggregateType<T>>

    /**
     * Group by Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LanguageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LanguageGroupByArgs['orderBy'] }
        : { orderBy?: LanguageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LanguageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLanguageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Language model
   */
  readonly fields: LanguageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Language.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LanguageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    translations<T extends Language$translationsArgs<ExtArgs> = {}>(args?: Subset<T, Language$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Language model
   */ 
  interface LanguageFieldRefs {
    readonly id: FieldRef<"Language", 'String'>
    readonly code: FieldRef<"Language", 'String'>
    readonly name: FieldRef<"Language", 'String'>
    readonly nativeName: FieldRef<"Language", 'String'>
    readonly isEnabled: FieldRef<"Language", 'Boolean'>
    readonly isDefault: FieldRef<"Language", 'Boolean'>
    readonly sortOrder: FieldRef<"Language", 'Int'>
    readonly createdAt: FieldRef<"Language", 'DateTime'>
    readonly updatedAt: FieldRef<"Language", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Language findUnique
   */
  export type LanguageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language findUniqueOrThrow
   */
  export type LanguageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language findFirst
   */
  export type LanguageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     */
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language findFirstOrThrow
   */
  export type LanguageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     */
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language findMany
   */
  export type LanguageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Languages to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language create
   */
  export type LanguageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The data needed to create a Language.
     */
    data: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
  }

  /**
   * Language createMany
   */
  export type LanguageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Languages.
     */
    data: LanguageCreateManyInput | LanguageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Language update
   */
  export type LanguageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The data needed to update a Language.
     */
    data: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
    /**
     * Choose, which Language to update.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language updateMany
   */
  export type LanguageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Languages.
     */
    data: XOR<LanguageUpdateManyMutationInput, LanguageUncheckedUpdateManyInput>
    /**
     * Filter which Languages to update
     */
    where?: LanguageWhereInput
  }

  /**
   * Language upsert
   */
  export type LanguageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The filter to search for the Language to update in case it exists.
     */
    where: LanguageWhereUniqueInput
    /**
     * In case the Language found by the `where` argument doesn't exist, create a new Language with this data.
     */
    create: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
    /**
     * In case the Language was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
  }

  /**
   * Language delete
   */
  export type LanguageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter which Language to delete.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language deleteMany
   */
  export type LanguageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Languages to delete
     */
    where?: LanguageWhereInput
  }

  /**
   * Language.translations
   */
  export type Language$translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationInclude<ExtArgs> | null
    where?: TranslationWhereInput
    orderBy?: TranslationOrderByWithRelationInput | TranslationOrderByWithRelationInput[]
    cursor?: TranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TranslationScalarFieldEnum | TranslationScalarFieldEnum[]
  }

  /**
   * Language without action
   */
  export type LanguageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
  }


  /**
   * Model Translation
   */

  export type AggregateTranslation = {
    _count: TranslationCountAggregateOutputType | null
    _min: TranslationMinAggregateOutputType | null
    _max: TranslationMaxAggregateOutputType | null
  }

  export type TranslationMinAggregateOutputType = {
    id: string | null
    languageId: string | null
    key: string | null
    value: string | null
    namespace: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TranslationMaxAggregateOutputType = {
    id: string | null
    languageId: string | null
    key: string | null
    value: string | null
    namespace: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TranslationCountAggregateOutputType = {
    id: number
    languageId: number
    key: number
    value: number
    namespace: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TranslationMinAggregateInputType = {
    id?: true
    languageId?: true
    key?: true
    value?: true
    namespace?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TranslationMaxAggregateInputType = {
    id?: true
    languageId?: true
    key?: true
    value?: true
    namespace?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TranslationCountAggregateInputType = {
    id?: true
    languageId?: true
    key?: true
    value?: true
    namespace?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Translation to aggregate.
     */
    where?: TranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Translations to fetch.
     */
    orderBy?: TranslationOrderByWithRelationInput | TranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Translations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Translations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Translations
    **/
    _count?: true | TranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TranslationMaxAggregateInputType
  }

  export type GetTranslationAggregateType<T extends TranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTranslation[P]>
      : GetScalarType<T[P], AggregateTranslation[P]>
  }




  export type TranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TranslationWhereInput
    orderBy?: TranslationOrderByWithAggregationInput | TranslationOrderByWithAggregationInput[]
    by: TranslationScalarFieldEnum[] | TranslationScalarFieldEnum
    having?: TranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TranslationCountAggregateInputType | true
    _min?: TranslationMinAggregateInputType
    _max?: TranslationMaxAggregateInputType
  }

  export type TranslationGroupByOutputType = {
    id: string
    languageId: string
    key: string
    value: string
    namespace: string
    createdAt: Date
    updatedAt: Date
    _count: TranslationCountAggregateOutputType | null
    _min: TranslationMinAggregateOutputType | null
    _max: TranslationMaxAggregateOutputType | null
  }

  type GetTranslationGroupByPayload<T extends TranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TranslationGroupByOutputType[P]>
            : GetScalarType<T[P], TranslationGroupByOutputType[P]>
        }
      >
    >


  export type TranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    languageId?: boolean
    key?: boolean
    value?: boolean
    namespace?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["translation"]>


  export type TranslationSelectScalar = {
    id?: boolean
    languageId?: boolean
    key?: boolean
    value?: boolean
    namespace?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TranslationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    language?: boolean | LanguageDefaultArgs<ExtArgs>
  }

  export type $TranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Translation"
    objects: {
      language: Prisma.$LanguagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      languageId: string
      key: string
      value: string
      namespace: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["translation"]>
    composites: {}
  }

  type TranslationGetPayload<S extends boolean | null | undefined | TranslationDefaultArgs> = $Result.GetResult<Prisma.$TranslationPayload, S>

  type TranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TranslationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TranslationCountAggregateInputType | true
    }

  export interface TranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Translation'], meta: { name: 'Translation' } }
    /**
     * Find zero or one Translation that matches the filter.
     * @param {TranslationFindUniqueArgs} args - Arguments to find a Translation
     * @example
     * // Get one Translation
     * const translation = await prisma.translation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TranslationFindUniqueArgs>(args: SelectSubset<T, TranslationFindUniqueArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Translation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TranslationFindUniqueOrThrowArgs} args - Arguments to find a Translation
     * @example
     * // Get one Translation
     * const translation = await prisma.translation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, TranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Translation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationFindFirstArgs} args - Arguments to find a Translation
     * @example
     * // Get one Translation
     * const translation = await prisma.translation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TranslationFindFirstArgs>(args?: SelectSubset<T, TranslationFindFirstArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Translation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationFindFirstOrThrowArgs} args - Arguments to find a Translation
     * @example
     * // Get one Translation
     * const translation = await prisma.translation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, TranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Translations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Translations
     * const translations = await prisma.translation.findMany()
     * 
     * // Get first 10 Translations
     * const translations = await prisma.translation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const translationWithIdOnly = await prisma.translation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TranslationFindManyArgs>(args?: SelectSubset<T, TranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Translation.
     * @param {TranslationCreateArgs} args - Arguments to create a Translation.
     * @example
     * // Create one Translation
     * const Translation = await prisma.translation.create({
     *   data: {
     *     // ... data to create a Translation
     *   }
     * })
     * 
     */
    create<T extends TranslationCreateArgs>(args: SelectSubset<T, TranslationCreateArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Translations.
     * @param {TranslationCreateManyArgs} args - Arguments to create many Translations.
     * @example
     * // Create many Translations
     * const translation = await prisma.translation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TranslationCreateManyArgs>(args?: SelectSubset<T, TranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Translation.
     * @param {TranslationDeleteArgs} args - Arguments to delete one Translation.
     * @example
     * // Delete one Translation
     * const Translation = await prisma.translation.delete({
     *   where: {
     *     // ... filter to delete one Translation
     *   }
     * })
     * 
     */
    delete<T extends TranslationDeleteArgs>(args: SelectSubset<T, TranslationDeleteArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Translation.
     * @param {TranslationUpdateArgs} args - Arguments to update one Translation.
     * @example
     * // Update one Translation
     * const translation = await prisma.translation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TranslationUpdateArgs>(args: SelectSubset<T, TranslationUpdateArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Translations.
     * @param {TranslationDeleteManyArgs} args - Arguments to filter Translations to delete.
     * @example
     * // Delete a few Translations
     * const { count } = await prisma.translation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TranslationDeleteManyArgs>(args?: SelectSubset<T, TranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Translations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Translations
     * const translation = await prisma.translation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TranslationUpdateManyArgs>(args: SelectSubset<T, TranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Translation.
     * @param {TranslationUpsertArgs} args - Arguments to update or create a Translation.
     * @example
     * // Update or create a Translation
     * const translation = await prisma.translation.upsert({
     *   create: {
     *     // ... data to create a Translation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Translation we want to update
     *   }
     * })
     */
    upsert<T extends TranslationUpsertArgs>(args: SelectSubset<T, TranslationUpsertArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Translations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationCountArgs} args - Arguments to filter Translations to count.
     * @example
     * // Count the number of Translations
     * const count = await prisma.translation.count({
     *   where: {
     *     // ... the filter for the Translations we want to count
     *   }
     * })
    **/
    count<T extends TranslationCountArgs>(
      args?: Subset<T, TranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Translation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TranslationAggregateArgs>(args: Subset<T, TranslationAggregateArgs>): Prisma.PrismaPromise<GetTranslationAggregateType<T>>

    /**
     * Group by Translation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TranslationGroupByArgs['orderBy'] }
        : { orderBy?: TranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Translation model
   */
  readonly fields: TranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Translation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    language<T extends LanguageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LanguageDefaultArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Translation model
   */ 
  interface TranslationFieldRefs {
    readonly id: FieldRef<"Translation", 'String'>
    readonly languageId: FieldRef<"Translation", 'String'>
    readonly key: FieldRef<"Translation", 'String'>
    readonly value: FieldRef<"Translation", 'String'>
    readonly namespace: FieldRef<"Translation", 'String'>
    readonly createdAt: FieldRef<"Translation", 'DateTime'>
    readonly updatedAt: FieldRef<"Translation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Translation findUnique
   */
  export type TranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationInclude<ExtArgs> | null
    /**
     * Filter, which Translation to fetch.
     */
    where: TranslationWhereUniqueInput
  }

  /**
   * Translation findUniqueOrThrow
   */
  export type TranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationInclude<ExtArgs> | null
    /**
     * Filter, which Translation to fetch.
     */
    where: TranslationWhereUniqueInput
  }

  /**
   * Translation findFirst
   */
  export type TranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationInclude<ExtArgs> | null
    /**
     * Filter, which Translation to fetch.
     */
    where?: TranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Translations to fetch.
     */
    orderBy?: TranslationOrderByWithRelationInput | TranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Translations.
     */
    cursor?: TranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Translations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Translations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Translations.
     */
    distinct?: TranslationScalarFieldEnum | TranslationScalarFieldEnum[]
  }

  /**
   * Translation findFirstOrThrow
   */
  export type TranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationInclude<ExtArgs> | null
    /**
     * Filter, which Translation to fetch.
     */
    where?: TranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Translations to fetch.
     */
    orderBy?: TranslationOrderByWithRelationInput | TranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Translations.
     */
    cursor?: TranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Translations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Translations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Translations.
     */
    distinct?: TranslationScalarFieldEnum | TranslationScalarFieldEnum[]
  }

  /**
   * Translation findMany
   */
  export type TranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationInclude<ExtArgs> | null
    /**
     * Filter, which Translations to fetch.
     */
    where?: TranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Translations to fetch.
     */
    orderBy?: TranslationOrderByWithRelationInput | TranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Translations.
     */
    cursor?: TranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Translations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Translations.
     */
    skip?: number
    distinct?: TranslationScalarFieldEnum | TranslationScalarFieldEnum[]
  }

  /**
   * Translation create
   */
  export type TranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a Translation.
     */
    data: XOR<TranslationCreateInput, TranslationUncheckedCreateInput>
  }

  /**
   * Translation createMany
   */
  export type TranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Translations.
     */
    data: TranslationCreateManyInput | TranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Translation update
   */
  export type TranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a Translation.
     */
    data: XOR<TranslationUpdateInput, TranslationUncheckedUpdateInput>
    /**
     * Choose, which Translation to update.
     */
    where: TranslationWhereUniqueInput
  }

  /**
   * Translation updateMany
   */
  export type TranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Translations.
     */
    data: XOR<TranslationUpdateManyMutationInput, TranslationUncheckedUpdateManyInput>
    /**
     * Filter which Translations to update
     */
    where?: TranslationWhereInput
  }

  /**
   * Translation upsert
   */
  export type TranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the Translation to update in case it exists.
     */
    where: TranslationWhereUniqueInput
    /**
     * In case the Translation found by the `where` argument doesn't exist, create a new Translation with this data.
     */
    create: XOR<TranslationCreateInput, TranslationUncheckedCreateInput>
    /**
     * In case the Translation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TranslationUpdateInput, TranslationUncheckedUpdateInput>
  }

  /**
   * Translation delete
   */
  export type TranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationInclude<ExtArgs> | null
    /**
     * Filter which Translation to delete.
     */
    where: TranslationWhereUniqueInput
  }

  /**
   * Translation deleteMany
   */
  export type TranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Translations to delete
     */
    where?: TranslationWhereInput
  }

  /**
   * Translation without action
   */
  export type TranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranslationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    avatar: 'avatar',
    phone: 'phone',
    role: 'role',
    department: 'department',
    isActive: 'isActive',
    language: 'language',
    membershipId: 'membershipId',
    membershipExpireAt: 'membershipExpireAt',
    points: 'points',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const OAuthAccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    provider: 'provider',
    providerId: 'providerId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    tokenExpireAt: 'tokenExpireAt',
    profile: 'profile',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OAuthAccountScalarFieldEnum = (typeof OAuthAccountScalarFieldEnum)[keyof typeof OAuthAccountScalarFieldEnum]


  export const LoginConfigScalarFieldEnum: {
    id: 'id',
    provider: 'provider',
    name: 'name',
    isEnabled: 'isEnabled',
    appId: 'appId',
    appSecret: 'appSecret',
    redirectUri: 'redirectUri',
    scope: 'scope',
    config: 'config',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LoginConfigScalarFieldEnum = (typeof LoginConfigScalarFieldEnum)[keyof typeof LoginConfigScalarFieldEnum]


  export const ScenarioScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    category: 'category',
    difficulty: 'difficulty',
    estimatedDuration: 'estimatedDuration',
    isActive: 'isActive',
    practiceCount: 'practiceCount',
    averageScore: 'averageScore',
    buyerPersona: 'buyerPersona',
    objections: 'objections',
    idealResponses: 'idealResponses',
    maxTurns: 'maxTurns',
    scoringWeights: 'scoringWeights',
    openingPrompt: 'openingPrompt',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ScenarioScalarFieldEnum = (typeof ScenarioScalarFieldEnum)[keyof typeof ScenarioScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    scenarioId: 'scenarioId',
    status: 'status',
    startedAt: 'startedAt',
    completedAt: 'completedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    role: 'role',
    content: 'content',
    timestamp: 'timestamp'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const FeedbackScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    overallScore: 'overallScore',
    dimensions: 'dimensions',
    summary: 'summary',
    recommendations: 'recommendations',
    createdAt: 'createdAt'
  };

  export type FeedbackScalarFieldEnum = (typeof FeedbackScalarFieldEnum)[keyof typeof FeedbackScalarFieldEnum]


  export const FollowUpEmailScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    userId: 'userId',
    toAddress: 'toAddress',
    subject: 'subject',
    body: 'body',
    isEdited: 'isEdited',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FollowUpEmailScalarFieldEnum = (typeof FollowUpEmailScalarFieldEnum)[keyof typeof FollowUpEmailScalarFieldEnum]


  export const AIModelScalarFieldEnum: {
    id: 'id',
    modelId: 'modelId',
    name: 'name',
    provider: 'provider',
    description: 'description',
    apiEndpoint: 'apiEndpoint',
    apiKey: 'apiKey',
    isDefault: 'isDefault',
    isActive: 'isActive',
    config: 'config',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AIModelScalarFieldEnum = (typeof AIModelScalarFieldEnum)[keyof typeof AIModelScalarFieldEnum]


  export const SystemSettingScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SystemSettingScalarFieldEnum = (typeof SystemSettingScalarFieldEnum)[keyof typeof SystemSettingScalarFieldEnum]


  export const BuyerPersonaTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    role: 'role',
    company: 'company',
    background: 'background',
    concerns: 'concerns',
    personality: 'personality',
    category: 'category',
    isDefault: 'isDefault',
    isActive: 'isActive',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BuyerPersonaTemplateScalarFieldEnum = (typeof BuyerPersonaTemplateScalarFieldEnum)[keyof typeof BuyerPersonaTemplateScalarFieldEnum]


  export const OperationLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    operationType: 'operationType',
    targetType: 'targetType',
    targetId: 'targetId',
    description: 'description',
    details: 'details',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type OperationLogScalarFieldEnum = (typeof OperationLogScalarFieldEnum)[keyof typeof OperationLogScalarFieldEnum]


  export const MediaScalarFieldEnum: {
    id: 'id',
    name: 'name',
    originalName: 'originalName',
    path: 'path',
    url: 'url',
    mimeType: 'mimeType',
    size: 'size',
    width: 'width',
    height: 'height',
    storageType: 'storageType',
    bucket: 'bucket',
    uploadedById: 'uploadedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MediaScalarFieldEnum = (typeof MediaScalarFieldEnum)[keyof typeof MediaScalarFieldEnum]


  export const StorageConfigScalarFieldEnum: {
    id: 'id',
    type: 'type',
    name: 'name',
    isEnabled: 'isEnabled',
    isDefault: 'isDefault',
    accessKeyId: 'accessKeyId',
    accessKeySecret: 'accessKeySecret',
    endpoint: 'endpoint',
    bucket: 'bucket',
    region: 'region',
    awsAccessKeyId: 'awsAccessKeyId',
    awsSecretAccessKey: 'awsSecretAccessKey',
    awsRegion: 'awsRegion',
    awsBucket: 'awsBucket',
    baseUrl: 'baseUrl',
    maxFileSize: 'maxFileSize',
    allowedMimeTypes: 'allowedMimeTypes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StorageConfigScalarFieldEnum = (typeof StorageConfigScalarFieldEnum)[keyof typeof StorageConfigScalarFieldEnum]


  export const PluginScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    name: 'name',
    description: 'description',
    icon: 'icon',
    version: 'version',
    author: 'author',
    category: 'category',
    price: 'price',
    downloadCount: 'downloadCount',
    rating: 'rating',
    isActive: 'isActive',
    isFeatured: 'isFeatured',
    config: 'config',
    permissions: 'permissions',
    dependencies: 'dependencies',
    changelog: 'changelog',
    screenshots: 'screenshots',
    documentation: 'documentation',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PluginScalarFieldEnum = (typeof PluginScalarFieldEnum)[keyof typeof PluginScalarFieldEnum]


  export const PluginInstallationScalarFieldEnum: {
    id: 'id',
    pluginId: 'pluginId',
    isEnabled: 'isEnabled',
    config: 'config',
    installedAt: 'installedAt',
    updatedAt: 'updatedAt'
  };

  export type PluginInstallationScalarFieldEnum = (typeof PluginInstallationScalarFieldEnum)[keyof typeof PluginInstallationScalarFieldEnum]


  export const ArticleCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    parentId: 'parentId',
    sortOrder: 'sortOrder',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ArticleCategoryScalarFieldEnum = (typeof ArticleCategoryScalarFieldEnum)[keyof typeof ArticleCategoryScalarFieldEnum]


  export const ArticleScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    content: 'content',
    excerpt: 'excerpt',
    coverImage: 'coverImage',
    categoryId: 'categoryId',
    authorId: 'authorId',
    status: 'status',
    viewCount: 'viewCount',
    tags: 'tags',
    seoTitle: 'seoTitle',
    seoDescription: 'seoDescription',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ArticleScalarFieldEnum = (typeof ArticleScalarFieldEnum)[keyof typeof ArticleScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    type: 'type',
    targetType: 'targetType',
    targetIds: 'targetIds',
    isRead: 'isRead',
    sendAt: 'sendAt',
    sentAt: 'sentAt',
    createdById: 'createdById',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const UserNotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    notificationId: 'notificationId',
    isRead: 'isRead',
    readAt: 'readAt',
    createdAt: 'createdAt'
  };

  export type UserNotificationScalarFieldEnum = (typeof UserNotificationScalarFieldEnum)[keyof typeof UserNotificationScalarFieldEnum]


  export const PaymentConfigScalarFieldEnum: {
    id: 'id',
    provider: 'provider',
    name: 'name',
    isEnabled: 'isEnabled',
    isSandbox: 'isSandbox',
    wechatAppId: 'wechatAppId',
    wechatMchId: 'wechatMchId',
    wechatApiKey: 'wechatApiKey',
    wechatCertPath: 'wechatCertPath',
    alipayAppId: 'alipayAppId',
    alipayPrivateKey: 'alipayPrivateKey',
    alipayPublicKey: 'alipayPublicKey',
    paypalClientId: 'paypalClientId',
    paypalSecret: 'paypalSecret',
    stripePublicKey: 'stripePublicKey',
    stripeSecretKey: 'stripeSecretKey',
    stripeWebhookSecret: 'stripeWebhookSecret',
    epayUrl: 'epayUrl',
    epayPid: 'epayPid',
    epayKey: 'epayKey',
    notifyUrl: 'notifyUrl',
    returnUrl: 'returnUrl',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentConfigScalarFieldEnum = (typeof PaymentConfigScalarFieldEnum)[keyof typeof PaymentConfigScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    orderNo: 'orderNo',
    userId: 'userId',
    orderType: 'orderType',
    status: 'status',
    amount: 'amount',
    currency: 'currency',
    paymentMethod: 'paymentMethod',
    transactionId: 'transactionId',
    productId: 'productId',
    productName: 'productName',
    productDesc: 'productDesc',
    metadata: 'metadata',
    paidAt: 'paidAt',
    refundedAt: 'refundedAt',
    expiredAt: 'expiredAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const MembershipPlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    price: 'price',
    originalPrice: 'originalPrice',
    currency: 'currency',
    duration: 'duration',
    features: 'features',
    limits: 'limits',
    isActive: 'isActive',
    isFeatured: 'isFeatured',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MembershipPlanScalarFieldEnum = (typeof MembershipPlanScalarFieldEnum)[keyof typeof MembershipPlanScalarFieldEnum]


  export const PointsConfigScalarFieldEnum: {
    id: 'id',
    key: 'key',
    name: 'name',
    description: 'description',
    points: 'points',
    isEnabled: 'isEnabled',
    dailyLimit: 'dailyLimit',
    totalLimit: 'totalLimit',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PointsConfigScalarFieldEnum = (typeof PointsConfigScalarFieldEnum)[keyof typeof PointsConfigScalarFieldEnum]


  export const PointRecordScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    points: 'points',
    balance: 'balance',
    type: 'type',
    description: 'description',
    relatedId: 'relatedId',
    createdAt: 'createdAt'
  };

  export type PointRecordScalarFieldEnum = (typeof PointRecordScalarFieldEnum)[keyof typeof PointRecordScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    displayName: 'displayName',
    description: 'description',
    isSystem: 'isSystem',
    permissions: 'permissions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const UserRoleAssignmentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    roleId: 'roleId',
    createdAt: 'createdAt'
  };

  export type UserRoleAssignmentScalarFieldEnum = (typeof UserRoleAssignmentScalarFieldEnum)[keyof typeof UserRoleAssignmentScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    key: 'key',
    name: 'name',
    description: 'description',
    module: 'module',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const LanguageScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    nativeName: 'nativeName',
    isEnabled: 'isEnabled',
    isDefault: 'isDefault',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LanguageScalarFieldEnum = (typeof LanguageScalarFieldEnum)[keyof typeof LanguageScalarFieldEnum]


  export const TranslationScalarFieldEnum: {
    id: 'id',
    languageId: 'languageId',
    key: 'key',
    value: 'value',
    namespace: 'namespace',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TranslationScalarFieldEnum = (typeof TranslationScalarFieldEnum)[keyof typeof TranslationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'OAuthProvider'
   */
  export type EnumOAuthProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OAuthProvider'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Difficulty'
   */
  export type EnumDifficultyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Difficulty'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'SessionStatus'
   */
  export type EnumSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionStatus'>
    


  /**
   * Reference to a field of type 'MessageRole'
   */
  export type EnumMessageRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageRole'>
    


  /**
   * Reference to a field of type 'StorageType'
   */
  export type EnumStorageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StorageType'>
    


  /**
   * Reference to a field of type 'PluginCategory'
   */
  export type EnumPluginCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PluginCategory'>
    


  /**
   * Reference to a field of type 'ArticleStatus'
   */
  export type EnumArticleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ArticleStatus'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationTarget'
   */
  export type EnumNotificationTargetFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationTarget'>
    


  /**
   * Reference to a field of type 'PaymentProvider'
   */
  export type EnumPaymentProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentProvider'>
    


  /**
   * Reference to a field of type 'OrderType'
   */
  export type EnumOrderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderType'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'PointType'
   */
  export type EnumPointTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PointType'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    name?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    department?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    language?: StringFilter<"User"> | string
    membershipId?: StringNullableFilter<"User"> | string | null
    membershipExpireAt?: DateTimeNullableFilter<"User"> | Date | string | null
    points?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    membership?: XOR<MembershipPlanNullableRelationFilter, MembershipPlanWhereInput> | null
    sessions?: SessionListRelationFilter
    scenarios?: ScenarioListRelationFilter
    emails?: FollowUpEmailListRelationFilter
    personaTemplates?: BuyerPersonaTemplateListRelationFilter
    operationLogs?: OperationLogListRelationFilter
    oauthAccounts?: OAuthAccountListRelationFilter
    orders?: OrderListRelationFilter
    pointRecords?: PointRecordListRelationFilter
    notifications?: UserNotificationListRelationFilter
    articles?: ArticleListRelationFilter
    media?: MediaListRelationFilter
    roleAssignments?: UserRoleAssignmentListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    name?: SortOrder
    avatar?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    role?: SortOrder
    department?: SortOrderInput | SortOrder
    isActive?: SortOrder
    language?: SortOrder
    membershipId?: SortOrderInput | SortOrder
    membershipExpireAt?: SortOrderInput | SortOrder
    points?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    membership?: MembershipPlanOrderByWithRelationInput
    sessions?: SessionOrderByRelationAggregateInput
    scenarios?: ScenarioOrderByRelationAggregateInput
    emails?: FollowUpEmailOrderByRelationAggregateInput
    personaTemplates?: BuyerPersonaTemplateOrderByRelationAggregateInput
    operationLogs?: OperationLogOrderByRelationAggregateInput
    oauthAccounts?: OAuthAccountOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    pointRecords?: PointRecordOrderByRelationAggregateInput
    notifications?: UserNotificationOrderByRelationAggregateInput
    articles?: ArticleOrderByRelationAggregateInput
    media?: MediaOrderByRelationAggregateInput
    roleAssignments?: UserRoleAssignmentOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    phone?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringNullableFilter<"User"> | string | null
    name?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    department?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    language?: StringFilter<"User"> | string
    membershipId?: StringNullableFilter<"User"> | string | null
    membershipExpireAt?: DateTimeNullableFilter<"User"> | Date | string | null
    points?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    membership?: XOR<MembershipPlanNullableRelationFilter, MembershipPlanWhereInput> | null
    sessions?: SessionListRelationFilter
    scenarios?: ScenarioListRelationFilter
    emails?: FollowUpEmailListRelationFilter
    personaTemplates?: BuyerPersonaTemplateListRelationFilter
    operationLogs?: OperationLogListRelationFilter
    oauthAccounts?: OAuthAccountListRelationFilter
    orders?: OrderListRelationFilter
    pointRecords?: PointRecordListRelationFilter
    notifications?: UserNotificationListRelationFilter
    articles?: ArticleListRelationFilter
    media?: MediaListRelationFilter
    roleAssignments?: UserRoleAssignmentListRelationFilter
  }, "id" | "email" | "phone">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    name?: SortOrder
    avatar?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    role?: SortOrder
    department?: SortOrderInput | SortOrder
    isActive?: SortOrder
    language?: SortOrder
    membershipId?: SortOrderInput | SortOrder
    membershipExpireAt?: SortOrderInput | SortOrder
    points?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    name?: StringWithAggregatesFilter<"User"> | string
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    department?: StringNullableWithAggregatesFilter<"User"> | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    language?: StringWithAggregatesFilter<"User"> | string
    membershipId?: StringNullableWithAggregatesFilter<"User"> | string | null
    membershipExpireAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    points?: IntWithAggregatesFilter<"User"> | number
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type OAuthAccountWhereInput = {
    AND?: OAuthAccountWhereInput | OAuthAccountWhereInput[]
    OR?: OAuthAccountWhereInput[]
    NOT?: OAuthAccountWhereInput | OAuthAccountWhereInput[]
    id?: StringFilter<"OAuthAccount"> | string
    userId?: StringFilter<"OAuthAccount"> | string
    provider?: EnumOAuthProviderFilter<"OAuthAccount"> | $Enums.OAuthProvider
    providerId?: StringFilter<"OAuthAccount"> | string
    accessToken?: StringNullableFilter<"OAuthAccount"> | string | null
    refreshToken?: StringNullableFilter<"OAuthAccount"> | string | null
    tokenExpireAt?: DateTimeNullableFilter<"OAuthAccount"> | Date | string | null
    profile?: JsonNullableFilter<"OAuthAccount">
    createdAt?: DateTimeFilter<"OAuthAccount"> | Date | string
    updatedAt?: DateTimeFilter<"OAuthAccount"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type OAuthAccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    tokenExpireAt?: SortOrderInput | SortOrder
    profile?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type OAuthAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerId?: OAuthAccountProviderProviderIdCompoundUniqueInput
    AND?: OAuthAccountWhereInput | OAuthAccountWhereInput[]
    OR?: OAuthAccountWhereInput[]
    NOT?: OAuthAccountWhereInput | OAuthAccountWhereInput[]
    userId?: StringFilter<"OAuthAccount"> | string
    provider?: EnumOAuthProviderFilter<"OAuthAccount"> | $Enums.OAuthProvider
    providerId?: StringFilter<"OAuthAccount"> | string
    accessToken?: StringNullableFilter<"OAuthAccount"> | string | null
    refreshToken?: StringNullableFilter<"OAuthAccount"> | string | null
    tokenExpireAt?: DateTimeNullableFilter<"OAuthAccount"> | Date | string | null
    profile?: JsonNullableFilter<"OAuthAccount">
    createdAt?: DateTimeFilter<"OAuthAccount"> | Date | string
    updatedAt?: DateTimeFilter<"OAuthAccount"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "provider_providerId">

  export type OAuthAccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    tokenExpireAt?: SortOrderInput | SortOrder
    profile?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OAuthAccountCountOrderByAggregateInput
    _max?: OAuthAccountMaxOrderByAggregateInput
    _min?: OAuthAccountMinOrderByAggregateInput
  }

  export type OAuthAccountScalarWhereWithAggregatesInput = {
    AND?: OAuthAccountScalarWhereWithAggregatesInput | OAuthAccountScalarWhereWithAggregatesInput[]
    OR?: OAuthAccountScalarWhereWithAggregatesInput[]
    NOT?: OAuthAccountScalarWhereWithAggregatesInput | OAuthAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OAuthAccount"> | string
    userId?: StringWithAggregatesFilter<"OAuthAccount"> | string
    provider?: EnumOAuthProviderWithAggregatesFilter<"OAuthAccount"> | $Enums.OAuthProvider
    providerId?: StringWithAggregatesFilter<"OAuthAccount"> | string
    accessToken?: StringNullableWithAggregatesFilter<"OAuthAccount"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"OAuthAccount"> | string | null
    tokenExpireAt?: DateTimeNullableWithAggregatesFilter<"OAuthAccount"> | Date | string | null
    profile?: JsonNullableWithAggregatesFilter<"OAuthAccount">
    createdAt?: DateTimeWithAggregatesFilter<"OAuthAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OAuthAccount"> | Date | string
  }

  export type LoginConfigWhereInput = {
    AND?: LoginConfigWhereInput | LoginConfigWhereInput[]
    OR?: LoginConfigWhereInput[]
    NOT?: LoginConfigWhereInput | LoginConfigWhereInput[]
    id?: StringFilter<"LoginConfig"> | string
    provider?: EnumOAuthProviderFilter<"LoginConfig"> | $Enums.OAuthProvider
    name?: StringFilter<"LoginConfig"> | string
    isEnabled?: BoolFilter<"LoginConfig"> | boolean
    appId?: StringNullableFilter<"LoginConfig"> | string | null
    appSecret?: StringNullableFilter<"LoginConfig"> | string | null
    redirectUri?: StringNullableFilter<"LoginConfig"> | string | null
    scope?: StringNullableFilter<"LoginConfig"> | string | null
    config?: JsonNullableFilter<"LoginConfig">
    sortOrder?: IntFilter<"LoginConfig"> | number
    createdAt?: DateTimeFilter<"LoginConfig"> | Date | string
    updatedAt?: DateTimeFilter<"LoginConfig"> | Date | string
  }

  export type LoginConfigOrderByWithRelationInput = {
    id?: SortOrder
    provider?: SortOrder
    name?: SortOrder
    isEnabled?: SortOrder
    appId?: SortOrderInput | SortOrder
    appSecret?: SortOrderInput | SortOrder
    redirectUri?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    config?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoginConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider?: $Enums.OAuthProvider
    AND?: LoginConfigWhereInput | LoginConfigWhereInput[]
    OR?: LoginConfigWhereInput[]
    NOT?: LoginConfigWhereInput | LoginConfigWhereInput[]
    name?: StringFilter<"LoginConfig"> | string
    isEnabled?: BoolFilter<"LoginConfig"> | boolean
    appId?: StringNullableFilter<"LoginConfig"> | string | null
    appSecret?: StringNullableFilter<"LoginConfig"> | string | null
    redirectUri?: StringNullableFilter<"LoginConfig"> | string | null
    scope?: StringNullableFilter<"LoginConfig"> | string | null
    config?: JsonNullableFilter<"LoginConfig">
    sortOrder?: IntFilter<"LoginConfig"> | number
    createdAt?: DateTimeFilter<"LoginConfig"> | Date | string
    updatedAt?: DateTimeFilter<"LoginConfig"> | Date | string
  }, "id" | "provider">

  export type LoginConfigOrderByWithAggregationInput = {
    id?: SortOrder
    provider?: SortOrder
    name?: SortOrder
    isEnabled?: SortOrder
    appId?: SortOrderInput | SortOrder
    appSecret?: SortOrderInput | SortOrder
    redirectUri?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    config?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LoginConfigCountOrderByAggregateInput
    _avg?: LoginConfigAvgOrderByAggregateInput
    _max?: LoginConfigMaxOrderByAggregateInput
    _min?: LoginConfigMinOrderByAggregateInput
    _sum?: LoginConfigSumOrderByAggregateInput
  }

  export type LoginConfigScalarWhereWithAggregatesInput = {
    AND?: LoginConfigScalarWhereWithAggregatesInput | LoginConfigScalarWhereWithAggregatesInput[]
    OR?: LoginConfigScalarWhereWithAggregatesInput[]
    NOT?: LoginConfigScalarWhereWithAggregatesInput | LoginConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LoginConfig"> | string
    provider?: EnumOAuthProviderWithAggregatesFilter<"LoginConfig"> | $Enums.OAuthProvider
    name?: StringWithAggregatesFilter<"LoginConfig"> | string
    isEnabled?: BoolWithAggregatesFilter<"LoginConfig"> | boolean
    appId?: StringNullableWithAggregatesFilter<"LoginConfig"> | string | null
    appSecret?: StringNullableWithAggregatesFilter<"LoginConfig"> | string | null
    redirectUri?: StringNullableWithAggregatesFilter<"LoginConfig"> | string | null
    scope?: StringNullableWithAggregatesFilter<"LoginConfig"> | string | null
    config?: JsonNullableWithAggregatesFilter<"LoginConfig">
    sortOrder?: IntWithAggregatesFilter<"LoginConfig"> | number
    createdAt?: DateTimeWithAggregatesFilter<"LoginConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LoginConfig"> | Date | string
  }

  export type ScenarioWhereInput = {
    AND?: ScenarioWhereInput | ScenarioWhereInput[]
    OR?: ScenarioWhereInput[]
    NOT?: ScenarioWhereInput | ScenarioWhereInput[]
    id?: StringFilter<"Scenario"> | string
    title?: StringFilter<"Scenario"> | string
    description?: StringFilter<"Scenario"> | string
    category?: StringFilter<"Scenario"> | string
    difficulty?: EnumDifficultyFilter<"Scenario"> | $Enums.Difficulty
    estimatedDuration?: IntFilter<"Scenario"> | number
    isActive?: BoolFilter<"Scenario"> | boolean
    practiceCount?: IntFilter<"Scenario"> | number
    averageScore?: FloatFilter<"Scenario"> | number
    buyerPersona?: JsonFilter<"Scenario">
    objections?: JsonFilter<"Scenario">
    idealResponses?: JsonFilter<"Scenario">
    maxTurns?: IntFilter<"Scenario"> | number
    scoringWeights?: JsonNullableFilter<"Scenario">
    openingPrompt?: StringNullableFilter<"Scenario"> | string | null
    createdById?: StringFilter<"Scenario"> | string
    createdAt?: DateTimeFilter<"Scenario"> | Date | string
    updatedAt?: DateTimeFilter<"Scenario"> | Date | string
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    sessions?: SessionListRelationFilter
  }

  export type ScenarioOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    estimatedDuration?: SortOrder
    isActive?: SortOrder
    practiceCount?: SortOrder
    averageScore?: SortOrder
    buyerPersona?: SortOrder
    objections?: SortOrder
    idealResponses?: SortOrder
    maxTurns?: SortOrder
    scoringWeights?: SortOrderInput | SortOrder
    openingPrompt?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    sessions?: SessionOrderByRelationAggregateInput
  }

  export type ScenarioWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScenarioWhereInput | ScenarioWhereInput[]
    OR?: ScenarioWhereInput[]
    NOT?: ScenarioWhereInput | ScenarioWhereInput[]
    title?: StringFilter<"Scenario"> | string
    description?: StringFilter<"Scenario"> | string
    category?: StringFilter<"Scenario"> | string
    difficulty?: EnumDifficultyFilter<"Scenario"> | $Enums.Difficulty
    estimatedDuration?: IntFilter<"Scenario"> | number
    isActive?: BoolFilter<"Scenario"> | boolean
    practiceCount?: IntFilter<"Scenario"> | number
    averageScore?: FloatFilter<"Scenario"> | number
    buyerPersona?: JsonFilter<"Scenario">
    objections?: JsonFilter<"Scenario">
    idealResponses?: JsonFilter<"Scenario">
    maxTurns?: IntFilter<"Scenario"> | number
    scoringWeights?: JsonNullableFilter<"Scenario">
    openingPrompt?: StringNullableFilter<"Scenario"> | string | null
    createdById?: StringFilter<"Scenario"> | string
    createdAt?: DateTimeFilter<"Scenario"> | Date | string
    updatedAt?: DateTimeFilter<"Scenario"> | Date | string
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    sessions?: SessionListRelationFilter
  }, "id">

  export type ScenarioOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    estimatedDuration?: SortOrder
    isActive?: SortOrder
    practiceCount?: SortOrder
    averageScore?: SortOrder
    buyerPersona?: SortOrder
    objections?: SortOrder
    idealResponses?: SortOrder
    maxTurns?: SortOrder
    scoringWeights?: SortOrderInput | SortOrder
    openingPrompt?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ScenarioCountOrderByAggregateInput
    _avg?: ScenarioAvgOrderByAggregateInput
    _max?: ScenarioMaxOrderByAggregateInput
    _min?: ScenarioMinOrderByAggregateInput
    _sum?: ScenarioSumOrderByAggregateInput
  }

  export type ScenarioScalarWhereWithAggregatesInput = {
    AND?: ScenarioScalarWhereWithAggregatesInput | ScenarioScalarWhereWithAggregatesInput[]
    OR?: ScenarioScalarWhereWithAggregatesInput[]
    NOT?: ScenarioScalarWhereWithAggregatesInput | ScenarioScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Scenario"> | string
    title?: StringWithAggregatesFilter<"Scenario"> | string
    description?: StringWithAggregatesFilter<"Scenario"> | string
    category?: StringWithAggregatesFilter<"Scenario"> | string
    difficulty?: EnumDifficultyWithAggregatesFilter<"Scenario"> | $Enums.Difficulty
    estimatedDuration?: IntWithAggregatesFilter<"Scenario"> | number
    isActive?: BoolWithAggregatesFilter<"Scenario"> | boolean
    practiceCount?: IntWithAggregatesFilter<"Scenario"> | number
    averageScore?: FloatWithAggregatesFilter<"Scenario"> | number
    buyerPersona?: JsonWithAggregatesFilter<"Scenario">
    objections?: JsonWithAggregatesFilter<"Scenario">
    idealResponses?: JsonWithAggregatesFilter<"Scenario">
    maxTurns?: IntWithAggregatesFilter<"Scenario"> | number
    scoringWeights?: JsonNullableWithAggregatesFilter<"Scenario">
    openingPrompt?: StringNullableWithAggregatesFilter<"Scenario"> | string | null
    createdById?: StringWithAggregatesFilter<"Scenario"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Scenario"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Scenario"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    scenarioId?: StringFilter<"Session"> | string
    status?: EnumSessionStatusFilter<"Session"> | $Enums.SessionStatus
    startedAt?: DateTimeFilter<"Session"> | Date | string
    completedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    scenario?: XOR<ScenarioRelationFilter, ScenarioWhereInput>
    messages?: MessageListRelationFilter
    feedback?: XOR<FeedbackNullableRelationFilter, FeedbackWhereInput> | null
    email?: XOR<FollowUpEmailNullableRelationFilter, FollowUpEmailWhereInput> | null
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    scenarioId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    scenario?: ScenarioOrderByWithRelationInput
    messages?: MessageOrderByRelationAggregateInput
    feedback?: FeedbackOrderByWithRelationInput
    email?: FollowUpEmailOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    scenarioId?: StringFilter<"Session"> | string
    status?: EnumSessionStatusFilter<"Session"> | $Enums.SessionStatus
    startedAt?: DateTimeFilter<"Session"> | Date | string
    completedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    scenario?: XOR<ScenarioRelationFilter, ScenarioWhereInput>
    messages?: MessageListRelationFilter
    feedback?: XOR<FeedbackNullableRelationFilter, FeedbackWhereInput> | null
    email?: XOR<FollowUpEmailNullableRelationFilter, FollowUpEmailWhereInput> | null
  }, "id">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    scenarioId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    scenarioId?: StringWithAggregatesFilter<"Session"> | string
    status?: EnumSessionStatusWithAggregatesFilter<"Session"> | $Enums.SessionStatus
    startedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"Session"> | Date | string | null
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    sessionId?: StringFilter<"Message"> | string
    role?: EnumMessageRoleFilter<"Message"> | $Enums.MessageRole
    content?: StringFilter<"Message"> | string
    timestamp?: DateTimeFilter<"Message"> | Date | string
    session?: XOR<SessionRelationFilter, SessionWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
    session?: SessionOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    sessionId?: StringFilter<"Message"> | string
    role?: EnumMessageRoleFilter<"Message"> | $Enums.MessageRole
    content?: StringFilter<"Message"> | string
    timestamp?: DateTimeFilter<"Message"> | Date | string
    session?: XOR<SessionRelationFilter, SessionWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    sessionId?: StringWithAggregatesFilter<"Message"> | string
    role?: EnumMessageRoleWithAggregatesFilter<"Message"> | $Enums.MessageRole
    content?: StringWithAggregatesFilter<"Message"> | string
    timestamp?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type FeedbackWhereInput = {
    AND?: FeedbackWhereInput | FeedbackWhereInput[]
    OR?: FeedbackWhereInput[]
    NOT?: FeedbackWhereInput | FeedbackWhereInput[]
    id?: StringFilter<"Feedback"> | string
    sessionId?: StringFilter<"Feedback"> | string
    overallScore?: IntFilter<"Feedback"> | number
    dimensions?: JsonFilter<"Feedback">
    summary?: StringFilter<"Feedback"> | string
    recommendations?: JsonFilter<"Feedback">
    createdAt?: DateTimeFilter<"Feedback"> | Date | string
    session?: XOR<SessionRelationFilter, SessionWhereInput>
  }

  export type FeedbackOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    overallScore?: SortOrder
    dimensions?: SortOrder
    summary?: SortOrder
    recommendations?: SortOrder
    createdAt?: SortOrder
    session?: SessionOrderByWithRelationInput
  }

  export type FeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionId?: string
    AND?: FeedbackWhereInput | FeedbackWhereInput[]
    OR?: FeedbackWhereInput[]
    NOT?: FeedbackWhereInput | FeedbackWhereInput[]
    overallScore?: IntFilter<"Feedback"> | number
    dimensions?: JsonFilter<"Feedback">
    summary?: StringFilter<"Feedback"> | string
    recommendations?: JsonFilter<"Feedback">
    createdAt?: DateTimeFilter<"Feedback"> | Date | string
    session?: XOR<SessionRelationFilter, SessionWhereInput>
  }, "id" | "sessionId">

  export type FeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    overallScore?: SortOrder
    dimensions?: SortOrder
    summary?: SortOrder
    recommendations?: SortOrder
    createdAt?: SortOrder
    _count?: FeedbackCountOrderByAggregateInput
    _avg?: FeedbackAvgOrderByAggregateInput
    _max?: FeedbackMaxOrderByAggregateInput
    _min?: FeedbackMinOrderByAggregateInput
    _sum?: FeedbackSumOrderByAggregateInput
  }

  export type FeedbackScalarWhereWithAggregatesInput = {
    AND?: FeedbackScalarWhereWithAggregatesInput | FeedbackScalarWhereWithAggregatesInput[]
    OR?: FeedbackScalarWhereWithAggregatesInput[]
    NOT?: FeedbackScalarWhereWithAggregatesInput | FeedbackScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Feedback"> | string
    sessionId?: StringWithAggregatesFilter<"Feedback"> | string
    overallScore?: IntWithAggregatesFilter<"Feedback"> | number
    dimensions?: JsonWithAggregatesFilter<"Feedback">
    summary?: StringWithAggregatesFilter<"Feedback"> | string
    recommendations?: JsonWithAggregatesFilter<"Feedback">
    createdAt?: DateTimeWithAggregatesFilter<"Feedback"> | Date | string
  }

  export type FollowUpEmailWhereInput = {
    AND?: FollowUpEmailWhereInput | FollowUpEmailWhereInput[]
    OR?: FollowUpEmailWhereInput[]
    NOT?: FollowUpEmailWhereInput | FollowUpEmailWhereInput[]
    id?: StringFilter<"FollowUpEmail"> | string
    sessionId?: StringFilter<"FollowUpEmail"> | string
    userId?: StringFilter<"FollowUpEmail"> | string
    toAddress?: StringNullableFilter<"FollowUpEmail"> | string | null
    subject?: StringFilter<"FollowUpEmail"> | string
    body?: StringFilter<"FollowUpEmail"> | string
    isEdited?: BoolFilter<"FollowUpEmail"> | boolean
    createdAt?: DateTimeFilter<"FollowUpEmail"> | Date | string
    updatedAt?: DateTimeFilter<"FollowUpEmail"> | Date | string
    session?: XOR<SessionRelationFilter, SessionWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type FollowUpEmailOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    toAddress?: SortOrderInput | SortOrder
    subject?: SortOrder
    body?: SortOrder
    isEdited?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    session?: SessionOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type FollowUpEmailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionId?: string
    AND?: FollowUpEmailWhereInput | FollowUpEmailWhereInput[]
    OR?: FollowUpEmailWhereInput[]
    NOT?: FollowUpEmailWhereInput | FollowUpEmailWhereInput[]
    userId?: StringFilter<"FollowUpEmail"> | string
    toAddress?: StringNullableFilter<"FollowUpEmail"> | string | null
    subject?: StringFilter<"FollowUpEmail"> | string
    body?: StringFilter<"FollowUpEmail"> | string
    isEdited?: BoolFilter<"FollowUpEmail"> | boolean
    createdAt?: DateTimeFilter<"FollowUpEmail"> | Date | string
    updatedAt?: DateTimeFilter<"FollowUpEmail"> | Date | string
    session?: XOR<SessionRelationFilter, SessionWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "sessionId">

  export type FollowUpEmailOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    toAddress?: SortOrderInput | SortOrder
    subject?: SortOrder
    body?: SortOrder
    isEdited?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FollowUpEmailCountOrderByAggregateInput
    _max?: FollowUpEmailMaxOrderByAggregateInput
    _min?: FollowUpEmailMinOrderByAggregateInput
  }

  export type FollowUpEmailScalarWhereWithAggregatesInput = {
    AND?: FollowUpEmailScalarWhereWithAggregatesInput | FollowUpEmailScalarWhereWithAggregatesInput[]
    OR?: FollowUpEmailScalarWhereWithAggregatesInput[]
    NOT?: FollowUpEmailScalarWhereWithAggregatesInput | FollowUpEmailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FollowUpEmail"> | string
    sessionId?: StringWithAggregatesFilter<"FollowUpEmail"> | string
    userId?: StringWithAggregatesFilter<"FollowUpEmail"> | string
    toAddress?: StringNullableWithAggregatesFilter<"FollowUpEmail"> | string | null
    subject?: StringWithAggregatesFilter<"FollowUpEmail"> | string
    body?: StringWithAggregatesFilter<"FollowUpEmail"> | string
    isEdited?: BoolWithAggregatesFilter<"FollowUpEmail"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"FollowUpEmail"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FollowUpEmail"> | Date | string
  }

  export type AIModelWhereInput = {
    AND?: AIModelWhereInput | AIModelWhereInput[]
    OR?: AIModelWhereInput[]
    NOT?: AIModelWhereInput | AIModelWhereInput[]
    id?: StringFilter<"AIModel"> | string
    modelId?: StringFilter<"AIModel"> | string
    name?: StringFilter<"AIModel"> | string
    provider?: StringFilter<"AIModel"> | string
    description?: StringNullableFilter<"AIModel"> | string | null
    apiEndpoint?: StringNullableFilter<"AIModel"> | string | null
    apiKey?: StringNullableFilter<"AIModel"> | string | null
    isDefault?: BoolFilter<"AIModel"> | boolean
    isActive?: BoolFilter<"AIModel"> | boolean
    config?: JsonNullableFilter<"AIModel">
    createdAt?: DateTimeFilter<"AIModel"> | Date | string
    updatedAt?: DateTimeFilter<"AIModel"> | Date | string
  }

  export type AIModelOrderByWithRelationInput = {
    id?: SortOrder
    modelId?: SortOrder
    name?: SortOrder
    provider?: SortOrder
    description?: SortOrderInput | SortOrder
    apiEndpoint?: SortOrderInput | SortOrder
    apiKey?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    config?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIModelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    modelId?: string
    AND?: AIModelWhereInput | AIModelWhereInput[]
    OR?: AIModelWhereInput[]
    NOT?: AIModelWhereInput | AIModelWhereInput[]
    name?: StringFilter<"AIModel"> | string
    provider?: StringFilter<"AIModel"> | string
    description?: StringNullableFilter<"AIModel"> | string | null
    apiEndpoint?: StringNullableFilter<"AIModel"> | string | null
    apiKey?: StringNullableFilter<"AIModel"> | string | null
    isDefault?: BoolFilter<"AIModel"> | boolean
    isActive?: BoolFilter<"AIModel"> | boolean
    config?: JsonNullableFilter<"AIModel">
    createdAt?: DateTimeFilter<"AIModel"> | Date | string
    updatedAt?: DateTimeFilter<"AIModel"> | Date | string
  }, "id" | "modelId">

  export type AIModelOrderByWithAggregationInput = {
    id?: SortOrder
    modelId?: SortOrder
    name?: SortOrder
    provider?: SortOrder
    description?: SortOrderInput | SortOrder
    apiEndpoint?: SortOrderInput | SortOrder
    apiKey?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    config?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AIModelCountOrderByAggregateInput
    _max?: AIModelMaxOrderByAggregateInput
    _min?: AIModelMinOrderByAggregateInput
  }

  export type AIModelScalarWhereWithAggregatesInput = {
    AND?: AIModelScalarWhereWithAggregatesInput | AIModelScalarWhereWithAggregatesInput[]
    OR?: AIModelScalarWhereWithAggregatesInput[]
    NOT?: AIModelScalarWhereWithAggregatesInput | AIModelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIModel"> | string
    modelId?: StringWithAggregatesFilter<"AIModel"> | string
    name?: StringWithAggregatesFilter<"AIModel"> | string
    provider?: StringWithAggregatesFilter<"AIModel"> | string
    description?: StringNullableWithAggregatesFilter<"AIModel"> | string | null
    apiEndpoint?: StringNullableWithAggregatesFilter<"AIModel"> | string | null
    apiKey?: StringNullableWithAggregatesFilter<"AIModel"> | string | null
    isDefault?: BoolWithAggregatesFilter<"AIModel"> | boolean
    isActive?: BoolWithAggregatesFilter<"AIModel"> | boolean
    config?: JsonNullableWithAggregatesFilter<"AIModel">
    createdAt?: DateTimeWithAggregatesFilter<"AIModel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AIModel"> | Date | string
  }

  export type SystemSettingWhereInput = {
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[]
    OR?: SystemSettingWhereInput[]
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[]
    id?: StringFilter<"SystemSetting"> | string
    key?: StringFilter<"SystemSetting"> | string
    value?: JsonFilter<"SystemSetting">
    createdAt?: DateTimeFilter<"SystemSetting"> | Date | string
    updatedAt?: DateTimeFilter<"SystemSetting"> | Date | string
  }

  export type SystemSettingOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[]
    OR?: SystemSettingWhereInput[]
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[]
    value?: JsonFilter<"SystemSetting">
    createdAt?: DateTimeFilter<"SystemSetting"> | Date | string
    updatedAt?: DateTimeFilter<"SystemSetting"> | Date | string
  }, "id" | "key">

  export type SystemSettingOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SystemSettingCountOrderByAggregateInput
    _max?: SystemSettingMaxOrderByAggregateInput
    _min?: SystemSettingMinOrderByAggregateInput
  }

  export type SystemSettingScalarWhereWithAggregatesInput = {
    AND?: SystemSettingScalarWhereWithAggregatesInput | SystemSettingScalarWhereWithAggregatesInput[]
    OR?: SystemSettingScalarWhereWithAggregatesInput[]
    NOT?: SystemSettingScalarWhereWithAggregatesInput | SystemSettingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemSetting"> | string
    key?: StringWithAggregatesFilter<"SystemSetting"> | string
    value?: JsonWithAggregatesFilter<"SystemSetting">
    createdAt?: DateTimeWithAggregatesFilter<"SystemSetting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemSetting"> | Date | string
  }

  export type BuyerPersonaTemplateWhereInput = {
    AND?: BuyerPersonaTemplateWhereInput | BuyerPersonaTemplateWhereInput[]
    OR?: BuyerPersonaTemplateWhereInput[]
    NOT?: BuyerPersonaTemplateWhereInput | BuyerPersonaTemplateWhereInput[]
    id?: StringFilter<"BuyerPersonaTemplate"> | string
    name?: StringFilter<"BuyerPersonaTemplate"> | string
    role?: StringFilter<"BuyerPersonaTemplate"> | string
    company?: StringFilter<"BuyerPersonaTemplate"> | string
    background?: StringFilter<"BuyerPersonaTemplate"> | string
    concerns?: JsonFilter<"BuyerPersonaTemplate">
    personality?: StringFilter<"BuyerPersonaTemplate"> | string
    category?: StringFilter<"BuyerPersonaTemplate"> | string
    isDefault?: BoolFilter<"BuyerPersonaTemplate"> | boolean
    isActive?: BoolFilter<"BuyerPersonaTemplate"> | boolean
    createdById?: StringNullableFilter<"BuyerPersonaTemplate"> | string | null
    createdAt?: DateTimeFilter<"BuyerPersonaTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"BuyerPersonaTemplate"> | Date | string
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type BuyerPersonaTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    company?: SortOrder
    background?: SortOrder
    concerns?: SortOrder
    personality?: SortOrder
    category?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: UserOrderByWithRelationInput
  }

  export type BuyerPersonaTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BuyerPersonaTemplateWhereInput | BuyerPersonaTemplateWhereInput[]
    OR?: BuyerPersonaTemplateWhereInput[]
    NOT?: BuyerPersonaTemplateWhereInput | BuyerPersonaTemplateWhereInput[]
    name?: StringFilter<"BuyerPersonaTemplate"> | string
    role?: StringFilter<"BuyerPersonaTemplate"> | string
    company?: StringFilter<"BuyerPersonaTemplate"> | string
    background?: StringFilter<"BuyerPersonaTemplate"> | string
    concerns?: JsonFilter<"BuyerPersonaTemplate">
    personality?: StringFilter<"BuyerPersonaTemplate"> | string
    category?: StringFilter<"BuyerPersonaTemplate"> | string
    isDefault?: BoolFilter<"BuyerPersonaTemplate"> | boolean
    isActive?: BoolFilter<"BuyerPersonaTemplate"> | boolean
    createdById?: StringNullableFilter<"BuyerPersonaTemplate"> | string | null
    createdAt?: DateTimeFilter<"BuyerPersonaTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"BuyerPersonaTemplate"> | Date | string
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type BuyerPersonaTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    company?: SortOrder
    background?: SortOrder
    concerns?: SortOrder
    personality?: SortOrder
    category?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BuyerPersonaTemplateCountOrderByAggregateInput
    _max?: BuyerPersonaTemplateMaxOrderByAggregateInput
    _min?: BuyerPersonaTemplateMinOrderByAggregateInput
  }

  export type BuyerPersonaTemplateScalarWhereWithAggregatesInput = {
    AND?: BuyerPersonaTemplateScalarWhereWithAggregatesInput | BuyerPersonaTemplateScalarWhereWithAggregatesInput[]
    OR?: BuyerPersonaTemplateScalarWhereWithAggregatesInput[]
    NOT?: BuyerPersonaTemplateScalarWhereWithAggregatesInput | BuyerPersonaTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BuyerPersonaTemplate"> | string
    name?: StringWithAggregatesFilter<"BuyerPersonaTemplate"> | string
    role?: StringWithAggregatesFilter<"BuyerPersonaTemplate"> | string
    company?: StringWithAggregatesFilter<"BuyerPersonaTemplate"> | string
    background?: StringWithAggregatesFilter<"BuyerPersonaTemplate"> | string
    concerns?: JsonWithAggregatesFilter<"BuyerPersonaTemplate">
    personality?: StringWithAggregatesFilter<"BuyerPersonaTemplate"> | string
    category?: StringWithAggregatesFilter<"BuyerPersonaTemplate"> | string
    isDefault?: BoolWithAggregatesFilter<"BuyerPersonaTemplate"> | boolean
    isActive?: BoolWithAggregatesFilter<"BuyerPersonaTemplate"> | boolean
    createdById?: StringNullableWithAggregatesFilter<"BuyerPersonaTemplate"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BuyerPersonaTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BuyerPersonaTemplate"> | Date | string
  }

  export type OperationLogWhereInput = {
    AND?: OperationLogWhereInput | OperationLogWhereInput[]
    OR?: OperationLogWhereInput[]
    NOT?: OperationLogWhereInput | OperationLogWhereInput[]
    id?: StringFilter<"OperationLog"> | string
    userId?: StringFilter<"OperationLog"> | string
    operationType?: StringFilter<"OperationLog"> | string
    targetType?: StringFilter<"OperationLog"> | string
    targetId?: StringNullableFilter<"OperationLog"> | string | null
    description?: StringFilter<"OperationLog"> | string
    details?: JsonNullableFilter<"OperationLog">
    ipAddress?: StringNullableFilter<"OperationLog"> | string | null
    userAgent?: StringNullableFilter<"OperationLog"> | string | null
    createdAt?: DateTimeFilter<"OperationLog"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type OperationLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    operationType?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrderInput | SortOrder
    description?: SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type OperationLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OperationLogWhereInput | OperationLogWhereInput[]
    OR?: OperationLogWhereInput[]
    NOT?: OperationLogWhereInput | OperationLogWhereInput[]
    userId?: StringFilter<"OperationLog"> | string
    operationType?: StringFilter<"OperationLog"> | string
    targetType?: StringFilter<"OperationLog"> | string
    targetId?: StringNullableFilter<"OperationLog"> | string | null
    description?: StringFilter<"OperationLog"> | string
    details?: JsonNullableFilter<"OperationLog">
    ipAddress?: StringNullableFilter<"OperationLog"> | string | null
    userAgent?: StringNullableFilter<"OperationLog"> | string | null
    createdAt?: DateTimeFilter<"OperationLog"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type OperationLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    operationType?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrderInput | SortOrder
    description?: SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: OperationLogCountOrderByAggregateInput
    _max?: OperationLogMaxOrderByAggregateInput
    _min?: OperationLogMinOrderByAggregateInput
  }

  export type OperationLogScalarWhereWithAggregatesInput = {
    AND?: OperationLogScalarWhereWithAggregatesInput | OperationLogScalarWhereWithAggregatesInput[]
    OR?: OperationLogScalarWhereWithAggregatesInput[]
    NOT?: OperationLogScalarWhereWithAggregatesInput | OperationLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OperationLog"> | string
    userId?: StringWithAggregatesFilter<"OperationLog"> | string
    operationType?: StringWithAggregatesFilter<"OperationLog"> | string
    targetType?: StringWithAggregatesFilter<"OperationLog"> | string
    targetId?: StringNullableWithAggregatesFilter<"OperationLog"> | string | null
    description?: StringWithAggregatesFilter<"OperationLog"> | string
    details?: JsonNullableWithAggregatesFilter<"OperationLog">
    ipAddress?: StringNullableWithAggregatesFilter<"OperationLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"OperationLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OperationLog"> | Date | string
  }

  export type MediaWhereInput = {
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    id?: StringFilter<"Media"> | string
    name?: StringFilter<"Media"> | string
    originalName?: StringFilter<"Media"> | string
    path?: StringFilter<"Media"> | string
    url?: StringFilter<"Media"> | string
    mimeType?: StringFilter<"Media"> | string
    size?: IntFilter<"Media"> | number
    width?: IntNullableFilter<"Media"> | number | null
    height?: IntNullableFilter<"Media"> | number | null
    storageType?: EnumStorageTypeFilter<"Media"> | $Enums.StorageType
    bucket?: StringNullableFilter<"Media"> | string | null
    uploadedById?: StringFilter<"Media"> | string
    createdAt?: DateTimeFilter<"Media"> | Date | string
    updatedAt?: DateTimeFilter<"Media"> | Date | string
    uploadedBy?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MediaOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    originalName?: SortOrder
    path?: SortOrder
    url?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    storageType?: SortOrder
    bucket?: SortOrderInput | SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uploadedBy?: UserOrderByWithRelationInput
  }

  export type MediaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    name?: StringFilter<"Media"> | string
    originalName?: StringFilter<"Media"> | string
    path?: StringFilter<"Media"> | string
    url?: StringFilter<"Media"> | string
    mimeType?: StringFilter<"Media"> | string
    size?: IntFilter<"Media"> | number
    width?: IntNullableFilter<"Media"> | number | null
    height?: IntNullableFilter<"Media"> | number | null
    storageType?: EnumStorageTypeFilter<"Media"> | $Enums.StorageType
    bucket?: StringNullableFilter<"Media"> | string | null
    uploadedById?: StringFilter<"Media"> | string
    createdAt?: DateTimeFilter<"Media"> | Date | string
    updatedAt?: DateTimeFilter<"Media"> | Date | string
    uploadedBy?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type MediaOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    originalName?: SortOrder
    path?: SortOrder
    url?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    storageType?: SortOrder
    bucket?: SortOrderInput | SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MediaCountOrderByAggregateInput
    _avg?: MediaAvgOrderByAggregateInput
    _max?: MediaMaxOrderByAggregateInput
    _min?: MediaMinOrderByAggregateInput
    _sum?: MediaSumOrderByAggregateInput
  }

  export type MediaScalarWhereWithAggregatesInput = {
    AND?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    OR?: MediaScalarWhereWithAggregatesInput[]
    NOT?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Media"> | string
    name?: StringWithAggregatesFilter<"Media"> | string
    originalName?: StringWithAggregatesFilter<"Media"> | string
    path?: StringWithAggregatesFilter<"Media"> | string
    url?: StringWithAggregatesFilter<"Media"> | string
    mimeType?: StringWithAggregatesFilter<"Media"> | string
    size?: IntWithAggregatesFilter<"Media"> | number
    width?: IntNullableWithAggregatesFilter<"Media"> | number | null
    height?: IntNullableWithAggregatesFilter<"Media"> | number | null
    storageType?: EnumStorageTypeWithAggregatesFilter<"Media"> | $Enums.StorageType
    bucket?: StringNullableWithAggregatesFilter<"Media"> | string | null
    uploadedById?: StringWithAggregatesFilter<"Media"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Media"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Media"> | Date | string
  }

  export type StorageConfigWhereInput = {
    AND?: StorageConfigWhereInput | StorageConfigWhereInput[]
    OR?: StorageConfigWhereInput[]
    NOT?: StorageConfigWhereInput | StorageConfigWhereInput[]
    id?: StringFilter<"StorageConfig"> | string
    type?: EnumStorageTypeFilter<"StorageConfig"> | $Enums.StorageType
    name?: StringFilter<"StorageConfig"> | string
    isEnabled?: BoolFilter<"StorageConfig"> | boolean
    isDefault?: BoolFilter<"StorageConfig"> | boolean
    accessKeyId?: StringNullableFilter<"StorageConfig"> | string | null
    accessKeySecret?: StringNullableFilter<"StorageConfig"> | string | null
    endpoint?: StringNullableFilter<"StorageConfig"> | string | null
    bucket?: StringNullableFilter<"StorageConfig"> | string | null
    region?: StringNullableFilter<"StorageConfig"> | string | null
    awsAccessKeyId?: StringNullableFilter<"StorageConfig"> | string | null
    awsSecretAccessKey?: StringNullableFilter<"StorageConfig"> | string | null
    awsRegion?: StringNullableFilter<"StorageConfig"> | string | null
    awsBucket?: StringNullableFilter<"StorageConfig"> | string | null
    baseUrl?: StringNullableFilter<"StorageConfig"> | string | null
    maxFileSize?: IntFilter<"StorageConfig"> | number
    allowedMimeTypes?: JsonFilter<"StorageConfig">
    createdAt?: DateTimeFilter<"StorageConfig"> | Date | string
    updatedAt?: DateTimeFilter<"StorageConfig"> | Date | string
  }

  export type StorageConfigOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    isEnabled?: SortOrder
    isDefault?: SortOrder
    accessKeyId?: SortOrderInput | SortOrder
    accessKeySecret?: SortOrderInput | SortOrder
    endpoint?: SortOrderInput | SortOrder
    bucket?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    awsAccessKeyId?: SortOrderInput | SortOrder
    awsSecretAccessKey?: SortOrderInput | SortOrder
    awsRegion?: SortOrderInput | SortOrder
    awsBucket?: SortOrderInput | SortOrder
    baseUrl?: SortOrderInput | SortOrder
    maxFileSize?: SortOrder
    allowedMimeTypes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StorageConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    type?: $Enums.StorageType
    AND?: StorageConfigWhereInput | StorageConfigWhereInput[]
    OR?: StorageConfigWhereInput[]
    NOT?: StorageConfigWhereInput | StorageConfigWhereInput[]
    name?: StringFilter<"StorageConfig"> | string
    isEnabled?: BoolFilter<"StorageConfig"> | boolean
    isDefault?: BoolFilter<"StorageConfig"> | boolean
    accessKeyId?: StringNullableFilter<"StorageConfig"> | string | null
    accessKeySecret?: StringNullableFilter<"StorageConfig"> | string | null
    endpoint?: StringNullableFilter<"StorageConfig"> | string | null
    bucket?: StringNullableFilter<"StorageConfig"> | string | null
    region?: StringNullableFilter<"StorageConfig"> | string | null
    awsAccessKeyId?: StringNullableFilter<"StorageConfig"> | string | null
    awsSecretAccessKey?: StringNullableFilter<"StorageConfig"> | string | null
    awsRegion?: StringNullableFilter<"StorageConfig"> | string | null
    awsBucket?: StringNullableFilter<"StorageConfig"> | string | null
    baseUrl?: StringNullableFilter<"StorageConfig"> | string | null
    maxFileSize?: IntFilter<"StorageConfig"> | number
    allowedMimeTypes?: JsonFilter<"StorageConfig">
    createdAt?: DateTimeFilter<"StorageConfig"> | Date | string
    updatedAt?: DateTimeFilter<"StorageConfig"> | Date | string
  }, "id" | "type">

  export type StorageConfigOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    isEnabled?: SortOrder
    isDefault?: SortOrder
    accessKeyId?: SortOrderInput | SortOrder
    accessKeySecret?: SortOrderInput | SortOrder
    endpoint?: SortOrderInput | SortOrder
    bucket?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    awsAccessKeyId?: SortOrderInput | SortOrder
    awsSecretAccessKey?: SortOrderInput | SortOrder
    awsRegion?: SortOrderInput | SortOrder
    awsBucket?: SortOrderInput | SortOrder
    baseUrl?: SortOrderInput | SortOrder
    maxFileSize?: SortOrder
    allowedMimeTypes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StorageConfigCountOrderByAggregateInput
    _avg?: StorageConfigAvgOrderByAggregateInput
    _max?: StorageConfigMaxOrderByAggregateInput
    _min?: StorageConfigMinOrderByAggregateInput
    _sum?: StorageConfigSumOrderByAggregateInput
  }

  export type StorageConfigScalarWhereWithAggregatesInput = {
    AND?: StorageConfigScalarWhereWithAggregatesInput | StorageConfigScalarWhereWithAggregatesInput[]
    OR?: StorageConfigScalarWhereWithAggregatesInput[]
    NOT?: StorageConfigScalarWhereWithAggregatesInput | StorageConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StorageConfig"> | string
    type?: EnumStorageTypeWithAggregatesFilter<"StorageConfig"> | $Enums.StorageType
    name?: StringWithAggregatesFilter<"StorageConfig"> | string
    isEnabled?: BoolWithAggregatesFilter<"StorageConfig"> | boolean
    isDefault?: BoolWithAggregatesFilter<"StorageConfig"> | boolean
    accessKeyId?: StringNullableWithAggregatesFilter<"StorageConfig"> | string | null
    accessKeySecret?: StringNullableWithAggregatesFilter<"StorageConfig"> | string | null
    endpoint?: StringNullableWithAggregatesFilter<"StorageConfig"> | string | null
    bucket?: StringNullableWithAggregatesFilter<"StorageConfig"> | string | null
    region?: StringNullableWithAggregatesFilter<"StorageConfig"> | string | null
    awsAccessKeyId?: StringNullableWithAggregatesFilter<"StorageConfig"> | string | null
    awsSecretAccessKey?: StringNullableWithAggregatesFilter<"StorageConfig"> | string | null
    awsRegion?: StringNullableWithAggregatesFilter<"StorageConfig"> | string | null
    awsBucket?: StringNullableWithAggregatesFilter<"StorageConfig"> | string | null
    baseUrl?: StringNullableWithAggregatesFilter<"StorageConfig"> | string | null
    maxFileSize?: IntWithAggregatesFilter<"StorageConfig"> | number
    allowedMimeTypes?: JsonWithAggregatesFilter<"StorageConfig">
    createdAt?: DateTimeWithAggregatesFilter<"StorageConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StorageConfig"> | Date | string
  }

  export type PluginWhereInput = {
    AND?: PluginWhereInput | PluginWhereInput[]
    OR?: PluginWhereInput[]
    NOT?: PluginWhereInput | PluginWhereInput[]
    id?: StringFilter<"Plugin"> | string
    slug?: StringFilter<"Plugin"> | string
    name?: StringFilter<"Plugin"> | string
    description?: StringNullableFilter<"Plugin"> | string | null
    icon?: StringNullableFilter<"Plugin"> | string | null
    version?: StringFilter<"Plugin"> | string
    author?: StringNullableFilter<"Plugin"> | string | null
    category?: EnumPluginCategoryFilter<"Plugin"> | $Enums.PluginCategory
    price?: FloatFilter<"Plugin"> | number
    downloadCount?: IntFilter<"Plugin"> | number
    rating?: FloatFilter<"Plugin"> | number
    isActive?: BoolFilter<"Plugin"> | boolean
    isFeatured?: BoolFilter<"Plugin"> | boolean
    config?: JsonNullableFilter<"Plugin">
    permissions?: JsonFilter<"Plugin">
    dependencies?: JsonFilter<"Plugin">
    changelog?: JsonNullableFilter<"Plugin">
    screenshots?: JsonFilter<"Plugin">
    documentation?: StringNullableFilter<"Plugin"> | string | null
    createdAt?: DateTimeFilter<"Plugin"> | Date | string
    updatedAt?: DateTimeFilter<"Plugin"> | Date | string
    installations?: PluginInstallationListRelationFilter
  }

  export type PluginOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    version?: SortOrder
    author?: SortOrderInput | SortOrder
    category?: SortOrder
    price?: SortOrder
    downloadCount?: SortOrder
    rating?: SortOrder
    isActive?: SortOrder
    isFeatured?: SortOrder
    config?: SortOrderInput | SortOrder
    permissions?: SortOrder
    dependencies?: SortOrder
    changelog?: SortOrderInput | SortOrder
    screenshots?: SortOrder
    documentation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    installations?: PluginInstallationOrderByRelationAggregateInput
  }

  export type PluginWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: PluginWhereInput | PluginWhereInput[]
    OR?: PluginWhereInput[]
    NOT?: PluginWhereInput | PluginWhereInput[]
    name?: StringFilter<"Plugin"> | string
    description?: StringNullableFilter<"Plugin"> | string | null
    icon?: StringNullableFilter<"Plugin"> | string | null
    version?: StringFilter<"Plugin"> | string
    author?: StringNullableFilter<"Plugin"> | string | null
    category?: EnumPluginCategoryFilter<"Plugin"> | $Enums.PluginCategory
    price?: FloatFilter<"Plugin"> | number
    downloadCount?: IntFilter<"Plugin"> | number
    rating?: FloatFilter<"Plugin"> | number
    isActive?: BoolFilter<"Plugin"> | boolean
    isFeatured?: BoolFilter<"Plugin"> | boolean
    config?: JsonNullableFilter<"Plugin">
    permissions?: JsonFilter<"Plugin">
    dependencies?: JsonFilter<"Plugin">
    changelog?: JsonNullableFilter<"Plugin">
    screenshots?: JsonFilter<"Plugin">
    documentation?: StringNullableFilter<"Plugin"> | string | null
    createdAt?: DateTimeFilter<"Plugin"> | Date | string
    updatedAt?: DateTimeFilter<"Plugin"> | Date | string
    installations?: PluginInstallationListRelationFilter
  }, "id" | "slug">

  export type PluginOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    version?: SortOrder
    author?: SortOrderInput | SortOrder
    category?: SortOrder
    price?: SortOrder
    downloadCount?: SortOrder
    rating?: SortOrder
    isActive?: SortOrder
    isFeatured?: SortOrder
    config?: SortOrderInput | SortOrder
    permissions?: SortOrder
    dependencies?: SortOrder
    changelog?: SortOrderInput | SortOrder
    screenshots?: SortOrder
    documentation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PluginCountOrderByAggregateInput
    _avg?: PluginAvgOrderByAggregateInput
    _max?: PluginMaxOrderByAggregateInput
    _min?: PluginMinOrderByAggregateInput
    _sum?: PluginSumOrderByAggregateInput
  }

  export type PluginScalarWhereWithAggregatesInput = {
    AND?: PluginScalarWhereWithAggregatesInput | PluginScalarWhereWithAggregatesInput[]
    OR?: PluginScalarWhereWithAggregatesInput[]
    NOT?: PluginScalarWhereWithAggregatesInput | PluginScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Plugin"> | string
    slug?: StringWithAggregatesFilter<"Plugin"> | string
    name?: StringWithAggregatesFilter<"Plugin"> | string
    description?: StringNullableWithAggregatesFilter<"Plugin"> | string | null
    icon?: StringNullableWithAggregatesFilter<"Plugin"> | string | null
    version?: StringWithAggregatesFilter<"Plugin"> | string
    author?: StringNullableWithAggregatesFilter<"Plugin"> | string | null
    category?: EnumPluginCategoryWithAggregatesFilter<"Plugin"> | $Enums.PluginCategory
    price?: FloatWithAggregatesFilter<"Plugin"> | number
    downloadCount?: IntWithAggregatesFilter<"Plugin"> | number
    rating?: FloatWithAggregatesFilter<"Plugin"> | number
    isActive?: BoolWithAggregatesFilter<"Plugin"> | boolean
    isFeatured?: BoolWithAggregatesFilter<"Plugin"> | boolean
    config?: JsonNullableWithAggregatesFilter<"Plugin">
    permissions?: JsonWithAggregatesFilter<"Plugin">
    dependencies?: JsonWithAggregatesFilter<"Plugin">
    changelog?: JsonNullableWithAggregatesFilter<"Plugin">
    screenshots?: JsonWithAggregatesFilter<"Plugin">
    documentation?: StringNullableWithAggregatesFilter<"Plugin"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Plugin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Plugin"> | Date | string
  }

  export type PluginInstallationWhereInput = {
    AND?: PluginInstallationWhereInput | PluginInstallationWhereInput[]
    OR?: PluginInstallationWhereInput[]
    NOT?: PluginInstallationWhereInput | PluginInstallationWhereInput[]
    id?: StringFilter<"PluginInstallation"> | string
    pluginId?: StringFilter<"PluginInstallation"> | string
    isEnabled?: BoolFilter<"PluginInstallation"> | boolean
    config?: JsonNullableFilter<"PluginInstallation">
    installedAt?: DateTimeFilter<"PluginInstallation"> | Date | string
    updatedAt?: DateTimeFilter<"PluginInstallation"> | Date | string
    plugin?: XOR<PluginRelationFilter, PluginWhereInput>
  }

  export type PluginInstallationOrderByWithRelationInput = {
    id?: SortOrder
    pluginId?: SortOrder
    isEnabled?: SortOrder
    config?: SortOrderInput | SortOrder
    installedAt?: SortOrder
    updatedAt?: SortOrder
    plugin?: PluginOrderByWithRelationInput
  }

  export type PluginInstallationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    pluginId?: string
    AND?: PluginInstallationWhereInput | PluginInstallationWhereInput[]
    OR?: PluginInstallationWhereInput[]
    NOT?: PluginInstallationWhereInput | PluginInstallationWhereInput[]
    isEnabled?: BoolFilter<"PluginInstallation"> | boolean
    config?: JsonNullableFilter<"PluginInstallation">
    installedAt?: DateTimeFilter<"PluginInstallation"> | Date | string
    updatedAt?: DateTimeFilter<"PluginInstallation"> | Date | string
    plugin?: XOR<PluginRelationFilter, PluginWhereInput>
  }, "id" | "pluginId">

  export type PluginInstallationOrderByWithAggregationInput = {
    id?: SortOrder
    pluginId?: SortOrder
    isEnabled?: SortOrder
    config?: SortOrderInput | SortOrder
    installedAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PluginInstallationCountOrderByAggregateInput
    _max?: PluginInstallationMaxOrderByAggregateInput
    _min?: PluginInstallationMinOrderByAggregateInput
  }

  export type PluginInstallationScalarWhereWithAggregatesInput = {
    AND?: PluginInstallationScalarWhereWithAggregatesInput | PluginInstallationScalarWhereWithAggregatesInput[]
    OR?: PluginInstallationScalarWhereWithAggregatesInput[]
    NOT?: PluginInstallationScalarWhereWithAggregatesInput | PluginInstallationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PluginInstallation"> | string
    pluginId?: StringWithAggregatesFilter<"PluginInstallation"> | string
    isEnabled?: BoolWithAggregatesFilter<"PluginInstallation"> | boolean
    config?: JsonNullableWithAggregatesFilter<"PluginInstallation">
    installedAt?: DateTimeWithAggregatesFilter<"PluginInstallation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PluginInstallation"> | Date | string
  }

  export type ArticleCategoryWhereInput = {
    AND?: ArticleCategoryWhereInput | ArticleCategoryWhereInput[]
    OR?: ArticleCategoryWhereInput[]
    NOT?: ArticleCategoryWhereInput | ArticleCategoryWhereInput[]
    id?: StringFilter<"ArticleCategory"> | string
    name?: StringFilter<"ArticleCategory"> | string
    slug?: StringFilter<"ArticleCategory"> | string
    description?: StringNullableFilter<"ArticleCategory"> | string | null
    parentId?: StringNullableFilter<"ArticleCategory"> | string | null
    sortOrder?: IntFilter<"ArticleCategory"> | number
    isActive?: BoolFilter<"ArticleCategory"> | boolean
    createdAt?: DateTimeFilter<"ArticleCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ArticleCategory"> | Date | string
    parent?: XOR<ArticleCategoryNullableRelationFilter, ArticleCategoryWhereInput> | null
    children?: ArticleCategoryListRelationFilter
    articles?: ArticleListRelationFilter
  }

  export type ArticleCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parent?: ArticleCategoryOrderByWithRelationInput
    children?: ArticleCategoryOrderByRelationAggregateInput
    articles?: ArticleOrderByRelationAggregateInput
  }

  export type ArticleCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: ArticleCategoryWhereInput | ArticleCategoryWhereInput[]
    OR?: ArticleCategoryWhereInput[]
    NOT?: ArticleCategoryWhereInput | ArticleCategoryWhereInput[]
    name?: StringFilter<"ArticleCategory"> | string
    description?: StringNullableFilter<"ArticleCategory"> | string | null
    parentId?: StringNullableFilter<"ArticleCategory"> | string | null
    sortOrder?: IntFilter<"ArticleCategory"> | number
    isActive?: BoolFilter<"ArticleCategory"> | boolean
    createdAt?: DateTimeFilter<"ArticleCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ArticleCategory"> | Date | string
    parent?: XOR<ArticleCategoryNullableRelationFilter, ArticleCategoryWhereInput> | null
    children?: ArticleCategoryListRelationFilter
    articles?: ArticleListRelationFilter
  }, "id" | "slug">

  export type ArticleCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ArticleCategoryCountOrderByAggregateInput
    _avg?: ArticleCategoryAvgOrderByAggregateInput
    _max?: ArticleCategoryMaxOrderByAggregateInput
    _min?: ArticleCategoryMinOrderByAggregateInput
    _sum?: ArticleCategorySumOrderByAggregateInput
  }

  export type ArticleCategoryScalarWhereWithAggregatesInput = {
    AND?: ArticleCategoryScalarWhereWithAggregatesInput | ArticleCategoryScalarWhereWithAggregatesInput[]
    OR?: ArticleCategoryScalarWhereWithAggregatesInput[]
    NOT?: ArticleCategoryScalarWhereWithAggregatesInput | ArticleCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ArticleCategory"> | string
    name?: StringWithAggregatesFilter<"ArticleCategory"> | string
    slug?: StringWithAggregatesFilter<"ArticleCategory"> | string
    description?: StringNullableWithAggregatesFilter<"ArticleCategory"> | string | null
    parentId?: StringNullableWithAggregatesFilter<"ArticleCategory"> | string | null
    sortOrder?: IntWithAggregatesFilter<"ArticleCategory"> | number
    isActive?: BoolWithAggregatesFilter<"ArticleCategory"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ArticleCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ArticleCategory"> | Date | string
  }

  export type ArticleWhereInput = {
    AND?: ArticleWhereInput | ArticleWhereInput[]
    OR?: ArticleWhereInput[]
    NOT?: ArticleWhereInput | ArticleWhereInput[]
    id?: StringFilter<"Article"> | string
    title?: StringFilter<"Article"> | string
    slug?: StringFilter<"Article"> | string
    content?: StringFilter<"Article"> | string
    excerpt?: StringNullableFilter<"Article"> | string | null
    coverImage?: StringNullableFilter<"Article"> | string | null
    categoryId?: StringNullableFilter<"Article"> | string | null
    authorId?: StringFilter<"Article"> | string
    status?: EnumArticleStatusFilter<"Article"> | $Enums.ArticleStatus
    viewCount?: IntFilter<"Article"> | number
    tags?: JsonFilter<"Article">
    seoTitle?: StringNullableFilter<"Article"> | string | null
    seoDescription?: StringNullableFilter<"Article"> | string | null
    publishedAt?: DateTimeNullableFilter<"Article"> | Date | string | null
    createdAt?: DateTimeFilter<"Article"> | Date | string
    updatedAt?: DateTimeFilter<"Article"> | Date | string
    category?: XOR<ArticleCategoryNullableRelationFilter, ArticleCategoryWhereInput> | null
    author?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ArticleOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    coverImage?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    authorId?: SortOrder
    status?: SortOrder
    viewCount?: SortOrder
    tags?: SortOrder
    seoTitle?: SortOrderInput | SortOrder
    seoDescription?: SortOrderInput | SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: ArticleCategoryOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
  }

  export type ArticleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: ArticleWhereInput | ArticleWhereInput[]
    OR?: ArticleWhereInput[]
    NOT?: ArticleWhereInput | ArticleWhereInput[]
    title?: StringFilter<"Article"> | string
    content?: StringFilter<"Article"> | string
    excerpt?: StringNullableFilter<"Article"> | string | null
    coverImage?: StringNullableFilter<"Article"> | string | null
    categoryId?: StringNullableFilter<"Article"> | string | null
    authorId?: StringFilter<"Article"> | string
    status?: EnumArticleStatusFilter<"Article"> | $Enums.ArticleStatus
    viewCount?: IntFilter<"Article"> | number
    tags?: JsonFilter<"Article">
    seoTitle?: StringNullableFilter<"Article"> | string | null
    seoDescription?: StringNullableFilter<"Article"> | string | null
    publishedAt?: DateTimeNullableFilter<"Article"> | Date | string | null
    createdAt?: DateTimeFilter<"Article"> | Date | string
    updatedAt?: DateTimeFilter<"Article"> | Date | string
    category?: XOR<ArticleCategoryNullableRelationFilter, ArticleCategoryWhereInput> | null
    author?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "slug">

  export type ArticleOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    coverImage?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    authorId?: SortOrder
    status?: SortOrder
    viewCount?: SortOrder
    tags?: SortOrder
    seoTitle?: SortOrderInput | SortOrder
    seoDescription?: SortOrderInput | SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ArticleCountOrderByAggregateInput
    _avg?: ArticleAvgOrderByAggregateInput
    _max?: ArticleMaxOrderByAggregateInput
    _min?: ArticleMinOrderByAggregateInput
    _sum?: ArticleSumOrderByAggregateInput
  }

  export type ArticleScalarWhereWithAggregatesInput = {
    AND?: ArticleScalarWhereWithAggregatesInput | ArticleScalarWhereWithAggregatesInput[]
    OR?: ArticleScalarWhereWithAggregatesInput[]
    NOT?: ArticleScalarWhereWithAggregatesInput | ArticleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Article"> | string
    title?: StringWithAggregatesFilter<"Article"> | string
    slug?: StringWithAggregatesFilter<"Article"> | string
    content?: StringWithAggregatesFilter<"Article"> | string
    excerpt?: StringNullableWithAggregatesFilter<"Article"> | string | null
    coverImage?: StringNullableWithAggregatesFilter<"Article"> | string | null
    categoryId?: StringNullableWithAggregatesFilter<"Article"> | string | null
    authorId?: StringWithAggregatesFilter<"Article"> | string
    status?: EnumArticleStatusWithAggregatesFilter<"Article"> | $Enums.ArticleStatus
    viewCount?: IntWithAggregatesFilter<"Article"> | number
    tags?: JsonWithAggregatesFilter<"Article">
    seoTitle?: StringNullableWithAggregatesFilter<"Article"> | string | null
    seoDescription?: StringNullableWithAggregatesFilter<"Article"> | string | null
    publishedAt?: DateTimeNullableWithAggregatesFilter<"Article"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Article"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Article"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    targetType?: EnumNotificationTargetFilter<"Notification"> | $Enums.NotificationTarget
    targetIds?: JsonFilter<"Notification">
    isRead?: BoolFilter<"Notification"> | boolean
    sendAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdById?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    userNotifications?: UserNotificationListRelationFilter
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    targetType?: SortOrder
    targetIds?: SortOrder
    isRead?: SortOrder
    sendAt?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userNotifications?: UserNotificationOrderByRelationAggregateInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    title?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    targetType?: EnumNotificationTargetFilter<"Notification"> | $Enums.NotificationTarget
    targetIds?: JsonFilter<"Notification">
    isRead?: BoolFilter<"Notification"> | boolean
    sendAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdById?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    userNotifications?: UserNotificationListRelationFilter
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    targetType?: SortOrder
    targetIds?: SortOrder
    isRead?: SortOrder
    sendAt?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    content?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    targetType?: EnumNotificationTargetWithAggregatesFilter<"Notification"> | $Enums.NotificationTarget
    targetIds?: JsonWithAggregatesFilter<"Notification">
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    sendAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    sentAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    createdById?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Notification">
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type UserNotificationWhereInput = {
    AND?: UserNotificationWhereInput | UserNotificationWhereInput[]
    OR?: UserNotificationWhereInput[]
    NOT?: UserNotificationWhereInput | UserNotificationWhereInput[]
    id?: StringFilter<"UserNotification"> | string
    userId?: StringFilter<"UserNotification"> | string
    notificationId?: StringFilter<"UserNotification"> | string
    isRead?: BoolFilter<"UserNotification"> | boolean
    readAt?: DateTimeNullableFilter<"UserNotification"> | Date | string | null
    createdAt?: DateTimeFilter<"UserNotification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    notification?: XOR<NotificationRelationFilter, NotificationWhereInput>
  }

  export type UserNotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationId?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    notification?: NotificationOrderByWithRelationInput
  }

  export type UserNotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_notificationId?: UserNotificationUserIdNotificationIdCompoundUniqueInput
    AND?: UserNotificationWhereInput | UserNotificationWhereInput[]
    OR?: UserNotificationWhereInput[]
    NOT?: UserNotificationWhereInput | UserNotificationWhereInput[]
    userId?: StringFilter<"UserNotification"> | string
    notificationId?: StringFilter<"UserNotification"> | string
    isRead?: BoolFilter<"UserNotification"> | boolean
    readAt?: DateTimeNullableFilter<"UserNotification"> | Date | string | null
    createdAt?: DateTimeFilter<"UserNotification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    notification?: XOR<NotificationRelationFilter, NotificationWhereInput>
  }, "id" | "userId_notificationId">

  export type UserNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationId?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UserNotificationCountOrderByAggregateInput
    _max?: UserNotificationMaxOrderByAggregateInput
    _min?: UserNotificationMinOrderByAggregateInput
  }

  export type UserNotificationScalarWhereWithAggregatesInput = {
    AND?: UserNotificationScalarWhereWithAggregatesInput | UserNotificationScalarWhereWithAggregatesInput[]
    OR?: UserNotificationScalarWhereWithAggregatesInput[]
    NOT?: UserNotificationScalarWhereWithAggregatesInput | UserNotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserNotification"> | string
    userId?: StringWithAggregatesFilter<"UserNotification"> | string
    notificationId?: StringWithAggregatesFilter<"UserNotification"> | string
    isRead?: BoolWithAggregatesFilter<"UserNotification"> | boolean
    readAt?: DateTimeNullableWithAggregatesFilter<"UserNotification"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserNotification"> | Date | string
  }

  export type PaymentConfigWhereInput = {
    AND?: PaymentConfigWhereInput | PaymentConfigWhereInput[]
    OR?: PaymentConfigWhereInput[]
    NOT?: PaymentConfigWhereInput | PaymentConfigWhereInput[]
    id?: StringFilter<"PaymentConfig"> | string
    provider?: EnumPaymentProviderFilter<"PaymentConfig"> | $Enums.PaymentProvider
    name?: StringFilter<"PaymentConfig"> | string
    isEnabled?: BoolFilter<"PaymentConfig"> | boolean
    isSandbox?: BoolFilter<"PaymentConfig"> | boolean
    wechatAppId?: StringNullableFilter<"PaymentConfig"> | string | null
    wechatMchId?: StringNullableFilter<"PaymentConfig"> | string | null
    wechatApiKey?: StringNullableFilter<"PaymentConfig"> | string | null
    wechatCertPath?: StringNullableFilter<"PaymentConfig"> | string | null
    alipayAppId?: StringNullableFilter<"PaymentConfig"> | string | null
    alipayPrivateKey?: StringNullableFilter<"PaymentConfig"> | string | null
    alipayPublicKey?: StringNullableFilter<"PaymentConfig"> | string | null
    paypalClientId?: StringNullableFilter<"PaymentConfig"> | string | null
    paypalSecret?: StringNullableFilter<"PaymentConfig"> | string | null
    stripePublicKey?: StringNullableFilter<"PaymentConfig"> | string | null
    stripeSecretKey?: StringNullableFilter<"PaymentConfig"> | string | null
    stripeWebhookSecret?: StringNullableFilter<"PaymentConfig"> | string | null
    epayUrl?: StringNullableFilter<"PaymentConfig"> | string | null
    epayPid?: StringNullableFilter<"PaymentConfig"> | string | null
    epayKey?: StringNullableFilter<"PaymentConfig"> | string | null
    notifyUrl?: StringNullableFilter<"PaymentConfig"> | string | null
    returnUrl?: StringNullableFilter<"PaymentConfig"> | string | null
    sortOrder?: IntFilter<"PaymentConfig"> | number
    createdAt?: DateTimeFilter<"PaymentConfig"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentConfig"> | Date | string
  }

  export type PaymentConfigOrderByWithRelationInput = {
    id?: SortOrder
    provider?: SortOrder
    name?: SortOrder
    isEnabled?: SortOrder
    isSandbox?: SortOrder
    wechatAppId?: SortOrderInput | SortOrder
    wechatMchId?: SortOrderInput | SortOrder
    wechatApiKey?: SortOrderInput | SortOrder
    wechatCertPath?: SortOrderInput | SortOrder
    alipayAppId?: SortOrderInput | SortOrder
    alipayPrivateKey?: SortOrderInput | SortOrder
    alipayPublicKey?: SortOrderInput | SortOrder
    paypalClientId?: SortOrderInput | SortOrder
    paypalSecret?: SortOrderInput | SortOrder
    stripePublicKey?: SortOrderInput | SortOrder
    stripeSecretKey?: SortOrderInput | SortOrder
    stripeWebhookSecret?: SortOrderInput | SortOrder
    epayUrl?: SortOrderInput | SortOrder
    epayPid?: SortOrderInput | SortOrder
    epayKey?: SortOrderInput | SortOrder
    notifyUrl?: SortOrderInput | SortOrder
    returnUrl?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider?: $Enums.PaymentProvider
    AND?: PaymentConfigWhereInput | PaymentConfigWhereInput[]
    OR?: PaymentConfigWhereInput[]
    NOT?: PaymentConfigWhereInput | PaymentConfigWhereInput[]
    name?: StringFilter<"PaymentConfig"> | string
    isEnabled?: BoolFilter<"PaymentConfig"> | boolean
    isSandbox?: BoolFilter<"PaymentConfig"> | boolean
    wechatAppId?: StringNullableFilter<"PaymentConfig"> | string | null
    wechatMchId?: StringNullableFilter<"PaymentConfig"> | string | null
    wechatApiKey?: StringNullableFilter<"PaymentConfig"> | string | null
    wechatCertPath?: StringNullableFilter<"PaymentConfig"> | string | null
    alipayAppId?: StringNullableFilter<"PaymentConfig"> | string | null
    alipayPrivateKey?: StringNullableFilter<"PaymentConfig"> | string | null
    alipayPublicKey?: StringNullableFilter<"PaymentConfig"> | string | null
    paypalClientId?: StringNullableFilter<"PaymentConfig"> | string | null
    paypalSecret?: StringNullableFilter<"PaymentConfig"> | string | null
    stripePublicKey?: StringNullableFilter<"PaymentConfig"> | string | null
    stripeSecretKey?: StringNullableFilter<"PaymentConfig"> | string | null
    stripeWebhookSecret?: StringNullableFilter<"PaymentConfig"> | string | null
    epayUrl?: StringNullableFilter<"PaymentConfig"> | string | null
    epayPid?: StringNullableFilter<"PaymentConfig"> | string | null
    epayKey?: StringNullableFilter<"PaymentConfig"> | string | null
    notifyUrl?: StringNullableFilter<"PaymentConfig"> | string | null
    returnUrl?: StringNullableFilter<"PaymentConfig"> | string | null
    sortOrder?: IntFilter<"PaymentConfig"> | number
    createdAt?: DateTimeFilter<"PaymentConfig"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentConfig"> | Date | string
  }, "id" | "provider">

  export type PaymentConfigOrderByWithAggregationInput = {
    id?: SortOrder
    provider?: SortOrder
    name?: SortOrder
    isEnabled?: SortOrder
    isSandbox?: SortOrder
    wechatAppId?: SortOrderInput | SortOrder
    wechatMchId?: SortOrderInput | SortOrder
    wechatApiKey?: SortOrderInput | SortOrder
    wechatCertPath?: SortOrderInput | SortOrder
    alipayAppId?: SortOrderInput | SortOrder
    alipayPrivateKey?: SortOrderInput | SortOrder
    alipayPublicKey?: SortOrderInput | SortOrder
    paypalClientId?: SortOrderInput | SortOrder
    paypalSecret?: SortOrderInput | SortOrder
    stripePublicKey?: SortOrderInput | SortOrder
    stripeSecretKey?: SortOrderInput | SortOrder
    stripeWebhookSecret?: SortOrderInput | SortOrder
    epayUrl?: SortOrderInput | SortOrder
    epayPid?: SortOrderInput | SortOrder
    epayKey?: SortOrderInput | SortOrder
    notifyUrl?: SortOrderInput | SortOrder
    returnUrl?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentConfigCountOrderByAggregateInput
    _avg?: PaymentConfigAvgOrderByAggregateInput
    _max?: PaymentConfigMaxOrderByAggregateInput
    _min?: PaymentConfigMinOrderByAggregateInput
    _sum?: PaymentConfigSumOrderByAggregateInput
  }

  export type PaymentConfigScalarWhereWithAggregatesInput = {
    AND?: PaymentConfigScalarWhereWithAggregatesInput | PaymentConfigScalarWhereWithAggregatesInput[]
    OR?: PaymentConfigScalarWhereWithAggregatesInput[]
    NOT?: PaymentConfigScalarWhereWithAggregatesInput | PaymentConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentConfig"> | string
    provider?: EnumPaymentProviderWithAggregatesFilter<"PaymentConfig"> | $Enums.PaymentProvider
    name?: StringWithAggregatesFilter<"PaymentConfig"> | string
    isEnabled?: BoolWithAggregatesFilter<"PaymentConfig"> | boolean
    isSandbox?: BoolWithAggregatesFilter<"PaymentConfig"> | boolean
    wechatAppId?: StringNullableWithAggregatesFilter<"PaymentConfig"> | string | null
    wechatMchId?: StringNullableWithAggregatesFilter<"PaymentConfig"> | string | null
    wechatApiKey?: StringNullableWithAggregatesFilter<"PaymentConfig"> | string | null
    wechatCertPath?: StringNullableWithAggregatesFilter<"PaymentConfig"> | string | null
    alipayAppId?: StringNullableWithAggregatesFilter<"PaymentConfig"> | string | null
    alipayPrivateKey?: StringNullableWithAggregatesFilter<"PaymentConfig"> | string | null
    alipayPublicKey?: StringNullableWithAggregatesFilter<"PaymentConfig"> | string | null
    paypalClientId?: StringNullableWithAggregatesFilter<"PaymentConfig"> | string | null
    paypalSecret?: StringNullableWithAggregatesFilter<"PaymentConfig"> | string | null
    stripePublicKey?: StringNullableWithAggregatesFilter<"PaymentConfig"> | string | null
    stripeSecretKey?: StringNullableWithAggregatesFilter<"PaymentConfig"> | string | null
    stripeWebhookSecret?: StringNullableWithAggregatesFilter<"PaymentConfig"> | string | null
    epayUrl?: StringNullableWithAggregatesFilter<"PaymentConfig"> | string | null
    epayPid?: StringNullableWithAggregatesFilter<"PaymentConfig"> | string | null
    epayKey?: StringNullableWithAggregatesFilter<"PaymentConfig"> | string | null
    notifyUrl?: StringNullableWithAggregatesFilter<"PaymentConfig"> | string | null
    returnUrl?: StringNullableWithAggregatesFilter<"PaymentConfig"> | string | null
    sortOrder?: IntWithAggregatesFilter<"PaymentConfig"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PaymentConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentConfig"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    orderNo?: StringFilter<"Order"> | string
    userId?: StringFilter<"Order"> | string
    orderType?: EnumOrderTypeFilter<"Order"> | $Enums.OrderType
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    amount?: FloatFilter<"Order"> | number
    currency?: StringFilter<"Order"> | string
    paymentMethod?: EnumPaymentProviderNullableFilter<"Order"> | $Enums.PaymentProvider | null
    transactionId?: StringNullableFilter<"Order"> | string | null
    productId?: StringNullableFilter<"Order"> | string | null
    productName?: StringFilter<"Order"> | string
    productDesc?: StringNullableFilter<"Order"> | string | null
    metadata?: JsonNullableFilter<"Order">
    paidAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    refundedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    expiredAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    orderNo?: SortOrder
    userId?: SortOrder
    orderType?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    productName?: SortOrder
    productDesc?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    refundedAt?: SortOrderInput | SortOrder
    expiredAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderNo?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    userId?: StringFilter<"Order"> | string
    orderType?: EnumOrderTypeFilter<"Order"> | $Enums.OrderType
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    amount?: FloatFilter<"Order"> | number
    currency?: StringFilter<"Order"> | string
    paymentMethod?: EnumPaymentProviderNullableFilter<"Order"> | $Enums.PaymentProvider | null
    transactionId?: StringNullableFilter<"Order"> | string | null
    productId?: StringNullableFilter<"Order"> | string | null
    productName?: StringFilter<"Order"> | string
    productDesc?: StringNullableFilter<"Order"> | string | null
    metadata?: JsonNullableFilter<"Order">
    paidAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    refundedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    expiredAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "orderNo">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    orderNo?: SortOrder
    userId?: SortOrder
    orderType?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    productName?: SortOrder
    productDesc?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    refundedAt?: SortOrderInput | SortOrder
    expiredAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    orderNo?: StringWithAggregatesFilter<"Order"> | string
    userId?: StringWithAggregatesFilter<"Order"> | string
    orderType?: EnumOrderTypeWithAggregatesFilter<"Order"> | $Enums.OrderType
    status?: EnumOrderStatusWithAggregatesFilter<"Order"> | $Enums.OrderStatus
    amount?: FloatWithAggregatesFilter<"Order"> | number
    currency?: StringWithAggregatesFilter<"Order"> | string
    paymentMethod?: EnumPaymentProviderNullableWithAggregatesFilter<"Order"> | $Enums.PaymentProvider | null
    transactionId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    productId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    productName?: StringWithAggregatesFilter<"Order"> | string
    productDesc?: StringNullableWithAggregatesFilter<"Order"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Order">
    paidAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    refundedAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    expiredAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
  }

  export type MembershipPlanWhereInput = {
    AND?: MembershipPlanWhereInput | MembershipPlanWhereInput[]
    OR?: MembershipPlanWhereInput[]
    NOT?: MembershipPlanWhereInput | MembershipPlanWhereInput[]
    id?: StringFilter<"MembershipPlan"> | string
    name?: StringFilter<"MembershipPlan"> | string
    slug?: StringFilter<"MembershipPlan"> | string
    description?: StringNullableFilter<"MembershipPlan"> | string | null
    price?: FloatFilter<"MembershipPlan"> | number
    originalPrice?: FloatNullableFilter<"MembershipPlan"> | number | null
    currency?: StringFilter<"MembershipPlan"> | string
    duration?: IntFilter<"MembershipPlan"> | number
    features?: JsonFilter<"MembershipPlan">
    limits?: JsonNullableFilter<"MembershipPlan">
    isActive?: BoolFilter<"MembershipPlan"> | boolean
    isFeatured?: BoolFilter<"MembershipPlan"> | boolean
    sortOrder?: IntFilter<"MembershipPlan"> | number
    createdAt?: DateTimeFilter<"MembershipPlan"> | Date | string
    updatedAt?: DateTimeFilter<"MembershipPlan"> | Date | string
    users?: UserListRelationFilter
  }

  export type MembershipPlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    originalPrice?: SortOrderInput | SortOrder
    currency?: SortOrder
    duration?: SortOrder
    features?: SortOrder
    limits?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isFeatured?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
  }

  export type MembershipPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: MembershipPlanWhereInput | MembershipPlanWhereInput[]
    OR?: MembershipPlanWhereInput[]
    NOT?: MembershipPlanWhereInput | MembershipPlanWhereInput[]
    name?: StringFilter<"MembershipPlan"> | string
    description?: StringNullableFilter<"MembershipPlan"> | string | null
    price?: FloatFilter<"MembershipPlan"> | number
    originalPrice?: FloatNullableFilter<"MembershipPlan"> | number | null
    currency?: StringFilter<"MembershipPlan"> | string
    duration?: IntFilter<"MembershipPlan"> | number
    features?: JsonFilter<"MembershipPlan">
    limits?: JsonNullableFilter<"MembershipPlan">
    isActive?: BoolFilter<"MembershipPlan"> | boolean
    isFeatured?: BoolFilter<"MembershipPlan"> | boolean
    sortOrder?: IntFilter<"MembershipPlan"> | number
    createdAt?: DateTimeFilter<"MembershipPlan"> | Date | string
    updatedAt?: DateTimeFilter<"MembershipPlan"> | Date | string
    users?: UserListRelationFilter
  }, "id" | "slug">

  export type MembershipPlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    originalPrice?: SortOrderInput | SortOrder
    currency?: SortOrder
    duration?: SortOrder
    features?: SortOrder
    limits?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isFeatured?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MembershipPlanCountOrderByAggregateInput
    _avg?: MembershipPlanAvgOrderByAggregateInput
    _max?: MembershipPlanMaxOrderByAggregateInput
    _min?: MembershipPlanMinOrderByAggregateInput
    _sum?: MembershipPlanSumOrderByAggregateInput
  }

  export type MembershipPlanScalarWhereWithAggregatesInput = {
    AND?: MembershipPlanScalarWhereWithAggregatesInput | MembershipPlanScalarWhereWithAggregatesInput[]
    OR?: MembershipPlanScalarWhereWithAggregatesInput[]
    NOT?: MembershipPlanScalarWhereWithAggregatesInput | MembershipPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MembershipPlan"> | string
    name?: StringWithAggregatesFilter<"MembershipPlan"> | string
    slug?: StringWithAggregatesFilter<"MembershipPlan"> | string
    description?: StringNullableWithAggregatesFilter<"MembershipPlan"> | string | null
    price?: FloatWithAggregatesFilter<"MembershipPlan"> | number
    originalPrice?: FloatNullableWithAggregatesFilter<"MembershipPlan"> | number | null
    currency?: StringWithAggregatesFilter<"MembershipPlan"> | string
    duration?: IntWithAggregatesFilter<"MembershipPlan"> | number
    features?: JsonWithAggregatesFilter<"MembershipPlan">
    limits?: JsonNullableWithAggregatesFilter<"MembershipPlan">
    isActive?: BoolWithAggregatesFilter<"MembershipPlan"> | boolean
    isFeatured?: BoolWithAggregatesFilter<"MembershipPlan"> | boolean
    sortOrder?: IntWithAggregatesFilter<"MembershipPlan"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MembershipPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MembershipPlan"> | Date | string
  }

  export type PointsConfigWhereInput = {
    AND?: PointsConfigWhereInput | PointsConfigWhereInput[]
    OR?: PointsConfigWhereInput[]
    NOT?: PointsConfigWhereInput | PointsConfigWhereInput[]
    id?: StringFilter<"PointsConfig"> | string
    key?: StringFilter<"PointsConfig"> | string
    name?: StringFilter<"PointsConfig"> | string
    description?: StringNullableFilter<"PointsConfig"> | string | null
    points?: IntFilter<"PointsConfig"> | number
    isEnabled?: BoolFilter<"PointsConfig"> | boolean
    dailyLimit?: IntNullableFilter<"PointsConfig"> | number | null
    totalLimit?: IntNullableFilter<"PointsConfig"> | number | null
    createdAt?: DateTimeFilter<"PointsConfig"> | Date | string
    updatedAt?: DateTimeFilter<"PointsConfig"> | Date | string
  }

  export type PointsConfigOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    points?: SortOrder
    isEnabled?: SortOrder
    dailyLimit?: SortOrderInput | SortOrder
    totalLimit?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PointsConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: PointsConfigWhereInput | PointsConfigWhereInput[]
    OR?: PointsConfigWhereInput[]
    NOT?: PointsConfigWhereInput | PointsConfigWhereInput[]
    name?: StringFilter<"PointsConfig"> | string
    description?: StringNullableFilter<"PointsConfig"> | string | null
    points?: IntFilter<"PointsConfig"> | number
    isEnabled?: BoolFilter<"PointsConfig"> | boolean
    dailyLimit?: IntNullableFilter<"PointsConfig"> | number | null
    totalLimit?: IntNullableFilter<"PointsConfig"> | number | null
    createdAt?: DateTimeFilter<"PointsConfig"> | Date | string
    updatedAt?: DateTimeFilter<"PointsConfig"> | Date | string
  }, "id" | "key">

  export type PointsConfigOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    points?: SortOrder
    isEnabled?: SortOrder
    dailyLimit?: SortOrderInput | SortOrder
    totalLimit?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PointsConfigCountOrderByAggregateInput
    _avg?: PointsConfigAvgOrderByAggregateInput
    _max?: PointsConfigMaxOrderByAggregateInput
    _min?: PointsConfigMinOrderByAggregateInput
    _sum?: PointsConfigSumOrderByAggregateInput
  }

  export type PointsConfigScalarWhereWithAggregatesInput = {
    AND?: PointsConfigScalarWhereWithAggregatesInput | PointsConfigScalarWhereWithAggregatesInput[]
    OR?: PointsConfigScalarWhereWithAggregatesInput[]
    NOT?: PointsConfigScalarWhereWithAggregatesInput | PointsConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PointsConfig"> | string
    key?: StringWithAggregatesFilter<"PointsConfig"> | string
    name?: StringWithAggregatesFilter<"PointsConfig"> | string
    description?: StringNullableWithAggregatesFilter<"PointsConfig"> | string | null
    points?: IntWithAggregatesFilter<"PointsConfig"> | number
    isEnabled?: BoolWithAggregatesFilter<"PointsConfig"> | boolean
    dailyLimit?: IntNullableWithAggregatesFilter<"PointsConfig"> | number | null
    totalLimit?: IntNullableWithAggregatesFilter<"PointsConfig"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"PointsConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PointsConfig"> | Date | string
  }

  export type PointRecordWhereInput = {
    AND?: PointRecordWhereInput | PointRecordWhereInput[]
    OR?: PointRecordWhereInput[]
    NOT?: PointRecordWhereInput | PointRecordWhereInput[]
    id?: StringFilter<"PointRecord"> | string
    userId?: StringFilter<"PointRecord"> | string
    points?: IntFilter<"PointRecord"> | number
    balance?: IntFilter<"PointRecord"> | number
    type?: EnumPointTypeFilter<"PointRecord"> | $Enums.PointType
    description?: StringFilter<"PointRecord"> | string
    relatedId?: StringNullableFilter<"PointRecord"> | string | null
    createdAt?: DateTimeFilter<"PointRecord"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PointRecordOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    points?: SortOrder
    balance?: SortOrder
    type?: SortOrder
    description?: SortOrder
    relatedId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PointRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PointRecordWhereInput | PointRecordWhereInput[]
    OR?: PointRecordWhereInput[]
    NOT?: PointRecordWhereInput | PointRecordWhereInput[]
    userId?: StringFilter<"PointRecord"> | string
    points?: IntFilter<"PointRecord"> | number
    balance?: IntFilter<"PointRecord"> | number
    type?: EnumPointTypeFilter<"PointRecord"> | $Enums.PointType
    description?: StringFilter<"PointRecord"> | string
    relatedId?: StringNullableFilter<"PointRecord"> | string | null
    createdAt?: DateTimeFilter<"PointRecord"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type PointRecordOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    points?: SortOrder
    balance?: SortOrder
    type?: SortOrder
    description?: SortOrder
    relatedId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PointRecordCountOrderByAggregateInput
    _avg?: PointRecordAvgOrderByAggregateInput
    _max?: PointRecordMaxOrderByAggregateInput
    _min?: PointRecordMinOrderByAggregateInput
    _sum?: PointRecordSumOrderByAggregateInput
  }

  export type PointRecordScalarWhereWithAggregatesInput = {
    AND?: PointRecordScalarWhereWithAggregatesInput | PointRecordScalarWhereWithAggregatesInput[]
    OR?: PointRecordScalarWhereWithAggregatesInput[]
    NOT?: PointRecordScalarWhereWithAggregatesInput | PointRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PointRecord"> | string
    userId?: StringWithAggregatesFilter<"PointRecord"> | string
    points?: IntWithAggregatesFilter<"PointRecord"> | number
    balance?: IntWithAggregatesFilter<"PointRecord"> | number
    type?: EnumPointTypeWithAggregatesFilter<"PointRecord"> | $Enums.PointType
    description?: StringWithAggregatesFilter<"PointRecord"> | string
    relatedId?: StringNullableWithAggregatesFilter<"PointRecord"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PointRecord"> | Date | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: StringFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    displayName?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    isSystem?: BoolFilter<"Role"> | boolean
    permissions?: JsonFilter<"Role">
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    userAssignments?: UserRoleAssignmentListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    isSystem?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userAssignments?: UserRoleAssignmentOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    displayName?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    isSystem?: BoolFilter<"Role"> | boolean
    permissions?: JsonFilter<"Role">
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    userAssignments?: UserRoleAssignmentListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    isSystem?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Role"> | string
    name?: StringWithAggregatesFilter<"Role"> | string
    displayName?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
    isSystem?: BoolWithAggregatesFilter<"Role"> | boolean
    permissions?: JsonWithAggregatesFilter<"Role">
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type UserRoleAssignmentWhereInput = {
    AND?: UserRoleAssignmentWhereInput | UserRoleAssignmentWhereInput[]
    OR?: UserRoleAssignmentWhereInput[]
    NOT?: UserRoleAssignmentWhereInput | UserRoleAssignmentWhereInput[]
    id?: StringFilter<"UserRoleAssignment"> | string
    userId?: StringFilter<"UserRoleAssignment"> | string
    roleId?: StringFilter<"UserRoleAssignment"> | string
    createdAt?: DateTimeFilter<"UserRoleAssignment"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    role?: XOR<RoleRelationFilter, RoleWhereInput>
  }

  export type UserRoleAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
  }

  export type UserRoleAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_roleId?: UserRoleAssignmentUserIdRoleIdCompoundUniqueInput
    AND?: UserRoleAssignmentWhereInput | UserRoleAssignmentWhereInput[]
    OR?: UserRoleAssignmentWhereInput[]
    NOT?: UserRoleAssignmentWhereInput | UserRoleAssignmentWhereInput[]
    userId?: StringFilter<"UserRoleAssignment"> | string
    roleId?: StringFilter<"UserRoleAssignment"> | string
    createdAt?: DateTimeFilter<"UserRoleAssignment"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    role?: XOR<RoleRelationFilter, RoleWhereInput>
  }, "id" | "userId_roleId">

  export type UserRoleAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    _count?: UserRoleAssignmentCountOrderByAggregateInput
    _max?: UserRoleAssignmentMaxOrderByAggregateInput
    _min?: UserRoleAssignmentMinOrderByAggregateInput
  }

  export type UserRoleAssignmentScalarWhereWithAggregatesInput = {
    AND?: UserRoleAssignmentScalarWhereWithAggregatesInput | UserRoleAssignmentScalarWhereWithAggregatesInput[]
    OR?: UserRoleAssignmentScalarWhereWithAggregatesInput[]
    NOT?: UserRoleAssignmentScalarWhereWithAggregatesInput | UserRoleAssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserRoleAssignment"> | string
    userId?: StringWithAggregatesFilter<"UserRoleAssignment"> | string
    roleId?: StringWithAggregatesFilter<"UserRoleAssignment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserRoleAssignment"> | Date | string
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: StringFilter<"Permission"> | string
    key?: StringFilter<"Permission"> | string
    name?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    module?: StringFilter<"Permission"> | string
    sortOrder?: IntFilter<"Permission"> | number
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    updatedAt?: DateTimeFilter<"Permission"> | Date | string
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    module?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    name?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    module?: StringFilter<"Permission"> | string
    sortOrder?: IntFilter<"Permission"> | number
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    updatedAt?: DateTimeFilter<"Permission"> | Date | string
  }, "id" | "key">

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    module?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _avg?: PermissionAvgOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
    _sum?: PermissionSumOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Permission"> | string
    key?: StringWithAggregatesFilter<"Permission"> | string
    name?: StringWithAggregatesFilter<"Permission"> | string
    description?: StringNullableWithAggregatesFilter<"Permission"> | string | null
    module?: StringWithAggregatesFilter<"Permission"> | string
    sortOrder?: IntWithAggregatesFilter<"Permission"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
  }

  export type LanguageWhereInput = {
    AND?: LanguageWhereInput | LanguageWhereInput[]
    OR?: LanguageWhereInput[]
    NOT?: LanguageWhereInput | LanguageWhereInput[]
    id?: StringFilter<"Language"> | string
    code?: StringFilter<"Language"> | string
    name?: StringFilter<"Language"> | string
    nativeName?: StringFilter<"Language"> | string
    isEnabled?: BoolFilter<"Language"> | boolean
    isDefault?: BoolFilter<"Language"> | boolean
    sortOrder?: IntFilter<"Language"> | number
    createdAt?: DateTimeFilter<"Language"> | Date | string
    updatedAt?: DateTimeFilter<"Language"> | Date | string
    translations?: TranslationListRelationFilter
  }

  export type LanguageOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    nativeName?: SortOrder
    isEnabled?: SortOrder
    isDefault?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    translations?: TranslationOrderByRelationAggregateInput
  }

  export type LanguageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: LanguageWhereInput | LanguageWhereInput[]
    OR?: LanguageWhereInput[]
    NOT?: LanguageWhereInput | LanguageWhereInput[]
    name?: StringFilter<"Language"> | string
    nativeName?: StringFilter<"Language"> | string
    isEnabled?: BoolFilter<"Language"> | boolean
    isDefault?: BoolFilter<"Language"> | boolean
    sortOrder?: IntFilter<"Language"> | number
    createdAt?: DateTimeFilter<"Language"> | Date | string
    updatedAt?: DateTimeFilter<"Language"> | Date | string
    translations?: TranslationListRelationFilter
  }, "id" | "code">

  export type LanguageOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    nativeName?: SortOrder
    isEnabled?: SortOrder
    isDefault?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LanguageCountOrderByAggregateInput
    _avg?: LanguageAvgOrderByAggregateInput
    _max?: LanguageMaxOrderByAggregateInput
    _min?: LanguageMinOrderByAggregateInput
    _sum?: LanguageSumOrderByAggregateInput
  }

  export type LanguageScalarWhereWithAggregatesInput = {
    AND?: LanguageScalarWhereWithAggregatesInput | LanguageScalarWhereWithAggregatesInput[]
    OR?: LanguageScalarWhereWithAggregatesInput[]
    NOT?: LanguageScalarWhereWithAggregatesInput | LanguageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Language"> | string
    code?: StringWithAggregatesFilter<"Language"> | string
    name?: StringWithAggregatesFilter<"Language"> | string
    nativeName?: StringWithAggregatesFilter<"Language"> | string
    isEnabled?: BoolWithAggregatesFilter<"Language"> | boolean
    isDefault?: BoolWithAggregatesFilter<"Language"> | boolean
    sortOrder?: IntWithAggregatesFilter<"Language"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Language"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Language"> | Date | string
  }

  export type TranslationWhereInput = {
    AND?: TranslationWhereInput | TranslationWhereInput[]
    OR?: TranslationWhereInput[]
    NOT?: TranslationWhereInput | TranslationWhereInput[]
    id?: StringFilter<"Translation"> | string
    languageId?: StringFilter<"Translation"> | string
    key?: StringFilter<"Translation"> | string
    value?: StringFilter<"Translation"> | string
    namespace?: StringFilter<"Translation"> | string
    createdAt?: DateTimeFilter<"Translation"> | Date | string
    updatedAt?: DateTimeFilter<"Translation"> | Date | string
    language?: XOR<LanguageRelationFilter, LanguageWhereInput>
  }

  export type TranslationOrderByWithRelationInput = {
    id?: SortOrder
    languageId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    namespace?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    language?: LanguageOrderByWithRelationInput
  }

  export type TranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    languageId_key_namespace?: TranslationLanguageIdKeyNamespaceCompoundUniqueInput
    AND?: TranslationWhereInput | TranslationWhereInput[]
    OR?: TranslationWhereInput[]
    NOT?: TranslationWhereInput | TranslationWhereInput[]
    languageId?: StringFilter<"Translation"> | string
    key?: StringFilter<"Translation"> | string
    value?: StringFilter<"Translation"> | string
    namespace?: StringFilter<"Translation"> | string
    createdAt?: DateTimeFilter<"Translation"> | Date | string
    updatedAt?: DateTimeFilter<"Translation"> | Date | string
    language?: XOR<LanguageRelationFilter, LanguageWhereInput>
  }, "id" | "languageId_key_namespace">

  export type TranslationOrderByWithAggregationInput = {
    id?: SortOrder
    languageId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    namespace?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TranslationCountOrderByAggregateInput
    _max?: TranslationMaxOrderByAggregateInput
    _min?: TranslationMinOrderByAggregateInput
  }

  export type TranslationScalarWhereWithAggregatesInput = {
    AND?: TranslationScalarWhereWithAggregatesInput | TranslationScalarWhereWithAggregatesInput[]
    OR?: TranslationScalarWhereWithAggregatesInput[]
    NOT?: TranslationScalarWhereWithAggregatesInput | TranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Translation"> | string
    languageId?: StringWithAggregatesFilter<"Translation"> | string
    key?: StringWithAggregatesFilter<"Translation"> | string
    value?: StringWithAggregatesFilter<"Translation"> | string
    namespace?: StringWithAggregatesFilter<"Translation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Translation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Translation"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    avatar?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    department?: string | null
    isActive?: boolean
    language?: string
    membershipExpireAt?: Date | string | null
    points?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    membership?: MembershipPlanCreateNestedOneWithoutUsersInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    scenarios?: ScenarioCreateNestedManyWithoutCreatedByInput
    emails?: FollowUpEmailCreateNestedManyWithoutUserInput
    personaTemplates?: BuyerPersonaTemplateCreateNestedManyWithoutCreatedByInput
    operationLogs?: OperationLogCreateNestedManyWithoutUserInput
    oauthAccounts?: OAuthAccountCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    pointRecords?: PointRecordCreateNestedManyWithoutUserInput
    notifications?: UserNotificationCreateNestedManyWithoutUserInput
    articles?: ArticleCreateNestedManyWithoutAuthorInput
    media?: MediaCreateNestedManyWithoutUploadedByInput
    roleAssignments?: UserRoleAssignmentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    avatar?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    department?: string | null
    isActive?: boolean
    language?: string
    membershipId?: string | null
    membershipExpireAt?: Date | string | null
    points?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutCreatedByInput
    emails?: FollowUpEmailUncheckedCreateNestedManyWithoutUserInput
    personaTemplates?: BuyerPersonaTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    operationLogs?: OperationLogUncheckedCreateNestedManyWithoutUserInput
    oauthAccounts?: OAuthAccountUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    pointRecords?: PointRecordUncheckedCreateNestedManyWithoutUserInput
    notifications?: UserNotificationUncheckedCreateNestedManyWithoutUserInput
    articles?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    media?: MediaUncheckedCreateNestedManyWithoutUploadedByInput
    roleAssignments?: UserRoleAssignmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    membershipExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    membership?: MembershipPlanUpdateOneWithoutUsersNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUpdateManyWithoutCreatedByNestedInput
    emails?: FollowUpEmailUpdateManyWithoutUserNestedInput
    personaTemplates?: BuyerPersonaTemplateUpdateManyWithoutCreatedByNestedInput
    operationLogs?: OperationLogUpdateManyWithoutUserNestedInput
    oauthAccounts?: OAuthAccountUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    pointRecords?: PointRecordUpdateManyWithoutUserNestedInput
    notifications?: UserNotificationUpdateManyWithoutUserNestedInput
    articles?: ArticleUpdateManyWithoutAuthorNestedInput
    media?: MediaUpdateManyWithoutUploadedByNestedInput
    roleAssignments?: UserRoleAssignmentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    membershipId?: NullableStringFieldUpdateOperationsInput | string | null
    membershipExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutCreatedByNestedInput
    emails?: FollowUpEmailUncheckedUpdateManyWithoutUserNestedInput
    personaTemplates?: BuyerPersonaTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    operationLogs?: OperationLogUncheckedUpdateManyWithoutUserNestedInput
    oauthAccounts?: OAuthAccountUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    pointRecords?: PointRecordUncheckedUpdateManyWithoutUserNestedInput
    notifications?: UserNotificationUncheckedUpdateManyWithoutUserNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    media?: MediaUncheckedUpdateManyWithoutUploadedByNestedInput
    roleAssignments?: UserRoleAssignmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    avatar?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    department?: string | null
    isActive?: boolean
    language?: string
    membershipId?: string | null
    membershipExpireAt?: Date | string | null
    points?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    membershipExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    membershipId?: NullableStringFieldUpdateOperationsInput | string | null
    membershipExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthAccountCreateInput = {
    id?: string
    provider: $Enums.OAuthProvider
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpireAt?: Date | string | null
    profile?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOauthAccountsInput
  }

  export type OAuthAccountUncheckedCreateInput = {
    id?: string
    userId: string
    provider: $Enums.OAuthProvider
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpireAt?: Date | string | null
    profile?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OAuthAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumOAuthProviderFieldUpdateOperationsInput | $Enums.OAuthProvider
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOauthAccountsNestedInput
  }

  export type OAuthAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: EnumOAuthProviderFieldUpdateOperationsInput | $Enums.OAuthProvider
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthAccountCreateManyInput = {
    id?: string
    userId: string
    provider: $Enums.OAuthProvider
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpireAt?: Date | string | null
    profile?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OAuthAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumOAuthProviderFieldUpdateOperationsInput | $Enums.OAuthProvider
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: EnumOAuthProviderFieldUpdateOperationsInput | $Enums.OAuthProvider
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginConfigCreateInput = {
    id?: string
    provider: $Enums.OAuthProvider
    name: string
    isEnabled?: boolean
    appId?: string | null
    appSecret?: string | null
    redirectUri?: string | null
    scope?: string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoginConfigUncheckedCreateInput = {
    id?: string
    provider: $Enums.OAuthProvider
    name: string
    isEnabled?: boolean
    appId?: string | null
    appSecret?: string | null
    redirectUri?: string | null
    scope?: string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoginConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumOAuthProviderFieldUpdateOperationsInput | $Enums.OAuthProvider
    name?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    appId?: NullableStringFieldUpdateOperationsInput | string | null
    appSecret?: NullableStringFieldUpdateOperationsInput | string | null
    redirectUri?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumOAuthProviderFieldUpdateOperationsInput | $Enums.OAuthProvider
    name?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    appId?: NullableStringFieldUpdateOperationsInput | string | null
    appSecret?: NullableStringFieldUpdateOperationsInput | string | null
    redirectUri?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginConfigCreateManyInput = {
    id?: string
    provider: $Enums.OAuthProvider
    name: string
    isEnabled?: boolean
    appId?: string | null
    appSecret?: string | null
    redirectUri?: string | null
    scope?: string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoginConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumOAuthProviderFieldUpdateOperationsInput | $Enums.OAuthProvider
    name?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    appId?: NullableStringFieldUpdateOperationsInput | string | null
    appSecret?: NullableStringFieldUpdateOperationsInput | string | null
    redirectUri?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumOAuthProviderFieldUpdateOperationsInput | $Enums.OAuthProvider
    name?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    appId?: NullableStringFieldUpdateOperationsInput | string | null
    appSecret?: NullableStringFieldUpdateOperationsInput | string | null
    redirectUri?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScenarioCreateInput = {
    id?: string
    title: string
    description: string
    category: string
    difficulty?: $Enums.Difficulty
    estimatedDuration?: number
    isActive?: boolean
    practiceCount?: number
    averageScore?: number
    buyerPersona: JsonNullValueInput | InputJsonValue
    objections: JsonNullValueInput | InputJsonValue
    idealResponses: JsonNullValueInput | InputJsonValue
    maxTurns?: number
    scoringWeights?: NullableJsonNullValueInput | InputJsonValue
    openingPrompt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutScenariosInput
    sessions?: SessionCreateNestedManyWithoutScenarioInput
  }

  export type ScenarioUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    category: string
    difficulty?: $Enums.Difficulty
    estimatedDuration?: number
    isActive?: boolean
    practiceCount?: number
    averageScore?: number
    buyerPersona: JsonNullValueInput | InputJsonValue
    objections: JsonNullValueInput | InputJsonValue
    idealResponses: JsonNullValueInput | InputJsonValue
    maxTurns?: number
    scoringWeights?: NullableJsonNullValueInput | InputJsonValue
    openingPrompt?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutScenarioInput
  }

  export type ScenarioUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    practiceCount?: IntFieldUpdateOperationsInput | number
    averageScore?: FloatFieldUpdateOperationsInput | number
    buyerPersona?: JsonNullValueInput | InputJsonValue
    objections?: JsonNullValueInput | InputJsonValue
    idealResponses?: JsonNullValueInput | InputJsonValue
    maxTurns?: IntFieldUpdateOperationsInput | number
    scoringWeights?: NullableJsonNullValueInput | InputJsonValue
    openingPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutScenariosNestedInput
    sessions?: SessionUpdateManyWithoutScenarioNestedInput
  }

  export type ScenarioUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    practiceCount?: IntFieldUpdateOperationsInput | number
    averageScore?: FloatFieldUpdateOperationsInput | number
    buyerPersona?: JsonNullValueInput | InputJsonValue
    objections?: JsonNullValueInput | InputJsonValue
    idealResponses?: JsonNullValueInput | InputJsonValue
    maxTurns?: IntFieldUpdateOperationsInput | number
    scoringWeights?: NullableJsonNullValueInput | InputJsonValue
    openingPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutScenarioNestedInput
  }

  export type ScenarioCreateManyInput = {
    id?: string
    title: string
    description: string
    category: string
    difficulty?: $Enums.Difficulty
    estimatedDuration?: number
    isActive?: boolean
    practiceCount?: number
    averageScore?: number
    buyerPersona: JsonNullValueInput | InputJsonValue
    objections: JsonNullValueInput | InputJsonValue
    idealResponses: JsonNullValueInput | InputJsonValue
    maxTurns?: number
    scoringWeights?: NullableJsonNullValueInput | InputJsonValue
    openingPrompt?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScenarioUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    practiceCount?: IntFieldUpdateOperationsInput | number
    averageScore?: FloatFieldUpdateOperationsInput | number
    buyerPersona?: JsonNullValueInput | InputJsonValue
    objections?: JsonNullValueInput | InputJsonValue
    idealResponses?: JsonNullValueInput | InputJsonValue
    maxTurns?: IntFieldUpdateOperationsInput | number
    scoringWeights?: NullableJsonNullValueInput | InputJsonValue
    openingPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScenarioUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    practiceCount?: IntFieldUpdateOperationsInput | number
    averageScore?: FloatFieldUpdateOperationsInput | number
    buyerPersona?: JsonNullValueInput | InputJsonValue
    objections?: JsonNullValueInput | InputJsonValue
    idealResponses?: JsonNullValueInput | InputJsonValue
    maxTurns?: IntFieldUpdateOperationsInput | number
    scoringWeights?: NullableJsonNullValueInput | InputJsonValue
    openingPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    status?: $Enums.SessionStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutSessionsInput
    scenario: ScenarioCreateNestedOneWithoutSessionsInput
    messages?: MessageCreateNestedManyWithoutSessionInput
    feedback?: FeedbackCreateNestedOneWithoutSessionInput
    email?: FollowUpEmailCreateNestedOneWithoutSessionInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    scenarioId: string
    status?: $Enums.SessionStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutSessionInput
    feedback?: FeedbackUncheckedCreateNestedOneWithoutSessionInput
    email?: FollowUpEmailUncheckedCreateNestedOneWithoutSessionInput
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
    scenario?: ScenarioUpdateOneRequiredWithoutSessionsNestedInput
    messages?: MessageUpdateManyWithoutSessionNestedInput
    feedback?: FeedbackUpdateOneWithoutSessionNestedInput
    email?: FollowUpEmailUpdateOneWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    scenarioId?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutSessionNestedInput
    feedback?: FeedbackUncheckedUpdateOneWithoutSessionNestedInput
    email?: FollowUpEmailUncheckedUpdateOneWithoutSessionNestedInput
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    scenarioId: string
    status?: $Enums.SessionStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    scenarioId?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageCreateInput = {
    id?: string
    role: $Enums.MessageRole
    content: string
    timestamp?: Date | string
    session: SessionCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    sessionId: string
    role: $Enums.MessageRole
    content: string
    timestamp?: Date | string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SessionUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: string
    sessionId: string
    role: $Enums.MessageRole
    content: string
    timestamp?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackCreateInput = {
    id?: string
    overallScore: number
    dimensions: JsonNullValueInput | InputJsonValue
    summary: string
    recommendations: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    session: SessionCreateNestedOneWithoutFeedbackInput
  }

  export type FeedbackUncheckedCreateInput = {
    id?: string
    sessionId: string
    overallScore: number
    dimensions: JsonNullValueInput | InputJsonValue
    summary: string
    recommendations: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type FeedbackUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    dimensions?: JsonNullValueInput | InputJsonValue
    summary?: StringFieldUpdateOperationsInput | string
    recommendations?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SessionUpdateOneRequiredWithoutFeedbackNestedInput
  }

  export type FeedbackUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    dimensions?: JsonNullValueInput | InputJsonValue
    summary?: StringFieldUpdateOperationsInput | string
    recommendations?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackCreateManyInput = {
    id?: string
    sessionId: string
    overallScore: number
    dimensions: JsonNullValueInput | InputJsonValue
    summary: string
    recommendations: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type FeedbackUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    dimensions?: JsonNullValueInput | InputJsonValue
    summary?: StringFieldUpdateOperationsInput | string
    recommendations?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    dimensions?: JsonNullValueInput | InputJsonValue
    summary?: StringFieldUpdateOperationsInput | string
    recommendations?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUpEmailCreateInput = {
    id?: string
    toAddress?: string | null
    subject: string
    body: string
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    session: SessionCreateNestedOneWithoutEmailInput
    user: UserCreateNestedOneWithoutEmailsInput
  }

  export type FollowUpEmailUncheckedCreateInput = {
    id?: string
    sessionId: string
    userId: string
    toAddress?: string | null
    subject: string
    body: string
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FollowUpEmailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    toAddress?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SessionUpdateOneRequiredWithoutEmailNestedInput
    user?: UserUpdateOneRequiredWithoutEmailsNestedInput
  }

  export type FollowUpEmailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    toAddress?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUpEmailCreateManyInput = {
    id?: string
    sessionId: string
    userId: string
    toAddress?: string | null
    subject: string
    body: string
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FollowUpEmailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    toAddress?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUpEmailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    toAddress?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIModelCreateInput = {
    id?: string
    modelId: string
    name: string
    provider: string
    description?: string | null
    apiEndpoint?: string | null
    apiKey?: string | null
    isDefault?: boolean
    isActive?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIModelUncheckedCreateInput = {
    id?: string
    modelId: string
    name: string
    provider: string
    description?: string | null
    apiEndpoint?: string | null
    apiKey?: string | null
    isDefault?: boolean
    isActive?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIModelCreateManyInput = {
    id?: string
    modelId: string
    name: string
    provider: string
    description?: string | null
    apiEndpoint?: string | null
    apiKey?: string | null
    isDefault?: boolean
    isActive?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingCreateInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSettingUncheckedCreateInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingCreateManyInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuyerPersonaTemplateCreateInput = {
    id?: string
    name: string
    role: string
    company: string
    background: string
    concerns: JsonNullValueInput | InputJsonValue
    personality: string
    category: string
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutPersonaTemplatesInput
  }

  export type BuyerPersonaTemplateUncheckedCreateInput = {
    id?: string
    name: string
    role: string
    company: string
    background: string
    concerns: JsonNullValueInput | InputJsonValue
    personality: string
    category: string
    isDefault?: boolean
    isActive?: boolean
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuyerPersonaTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    concerns?: JsonNullValueInput | InputJsonValue
    personality?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutPersonaTemplatesNestedInput
  }

  export type BuyerPersonaTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    concerns?: JsonNullValueInput | InputJsonValue
    personality?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuyerPersonaTemplateCreateManyInput = {
    id?: string
    name: string
    role: string
    company: string
    background: string
    concerns: JsonNullValueInput | InputJsonValue
    personality: string
    category: string
    isDefault?: boolean
    isActive?: boolean
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuyerPersonaTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    concerns?: JsonNullValueInput | InputJsonValue
    personality?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuyerPersonaTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    concerns?: JsonNullValueInput | InputJsonValue
    personality?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperationLogCreateInput = {
    id?: string
    operationType: string
    targetType: string
    targetId?: string | null
    description: string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutOperationLogsInput
  }

  export type OperationLogUncheckedCreateInput = {
    id?: string
    userId: string
    operationType: string
    targetType: string
    targetId?: string | null
    description: string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type OperationLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOperationLogsNestedInput
  }

  export type OperationLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperationLogCreateManyInput = {
    id?: string
    userId: string
    operationType: string
    targetType: string
    targetId?: string | null
    description: string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type OperationLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperationLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaCreateInput = {
    id?: string
    name: string
    originalName: string
    path: string
    url: string
    mimeType: string
    size: number
    width?: number | null
    height?: number | null
    storageType?: $Enums.StorageType
    bucket?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedBy: UserCreateNestedOneWithoutMediaInput
  }

  export type MediaUncheckedCreateInput = {
    id?: string
    name: string
    originalName: string
    path: string
    url: string
    mimeType: string
    size: number
    width?: number | null
    height?: number | null
    storageType?: $Enums.StorageType
    bucket?: string | null
    uploadedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    storageType?: EnumStorageTypeFieldUpdateOperationsInput | $Enums.StorageType
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: UserUpdateOneRequiredWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    storageType?: EnumStorageTypeFieldUpdateOperationsInput | $Enums.StorageType
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaCreateManyInput = {
    id?: string
    name: string
    originalName: string
    path: string
    url: string
    mimeType: string
    size: number
    width?: number | null
    height?: number | null
    storageType?: $Enums.StorageType
    bucket?: string | null
    uploadedById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    storageType?: EnumStorageTypeFieldUpdateOperationsInput | $Enums.StorageType
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    storageType?: EnumStorageTypeFieldUpdateOperationsInput | $Enums.StorageType
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorageConfigCreateInput = {
    id?: string
    type: $Enums.StorageType
    name: string
    isEnabled?: boolean
    isDefault?: boolean
    accessKeyId?: string | null
    accessKeySecret?: string | null
    endpoint?: string | null
    bucket?: string | null
    region?: string | null
    awsAccessKeyId?: string | null
    awsSecretAccessKey?: string | null
    awsRegion?: string | null
    awsBucket?: string | null
    baseUrl?: string | null
    maxFileSize?: number
    allowedMimeTypes: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StorageConfigUncheckedCreateInput = {
    id?: string
    type: $Enums.StorageType
    name: string
    isEnabled?: boolean
    isDefault?: boolean
    accessKeyId?: string | null
    accessKeySecret?: string | null
    endpoint?: string | null
    bucket?: string | null
    region?: string | null
    awsAccessKeyId?: string | null
    awsSecretAccessKey?: string | null
    awsRegion?: string | null
    awsBucket?: string | null
    baseUrl?: string | null
    maxFileSize?: number
    allowedMimeTypes: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StorageConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStorageTypeFieldUpdateOperationsInput | $Enums.StorageType
    name?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    accessKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    accessKeySecret?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    awsAccessKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    awsSecretAccessKey?: NullableStringFieldUpdateOperationsInput | string | null
    awsRegion?: NullableStringFieldUpdateOperationsInput | string | null
    awsBucket?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    maxFileSize?: IntFieldUpdateOperationsInput | number
    allowedMimeTypes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorageConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStorageTypeFieldUpdateOperationsInput | $Enums.StorageType
    name?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    accessKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    accessKeySecret?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    awsAccessKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    awsSecretAccessKey?: NullableStringFieldUpdateOperationsInput | string | null
    awsRegion?: NullableStringFieldUpdateOperationsInput | string | null
    awsBucket?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    maxFileSize?: IntFieldUpdateOperationsInput | number
    allowedMimeTypes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorageConfigCreateManyInput = {
    id?: string
    type: $Enums.StorageType
    name: string
    isEnabled?: boolean
    isDefault?: boolean
    accessKeyId?: string | null
    accessKeySecret?: string | null
    endpoint?: string | null
    bucket?: string | null
    region?: string | null
    awsAccessKeyId?: string | null
    awsSecretAccessKey?: string | null
    awsRegion?: string | null
    awsBucket?: string | null
    baseUrl?: string | null
    maxFileSize?: number
    allowedMimeTypes: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StorageConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStorageTypeFieldUpdateOperationsInput | $Enums.StorageType
    name?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    accessKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    accessKeySecret?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    awsAccessKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    awsSecretAccessKey?: NullableStringFieldUpdateOperationsInput | string | null
    awsRegion?: NullableStringFieldUpdateOperationsInput | string | null
    awsBucket?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    maxFileSize?: IntFieldUpdateOperationsInput | number
    allowedMimeTypes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorageConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStorageTypeFieldUpdateOperationsInput | $Enums.StorageType
    name?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    accessKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    accessKeySecret?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    awsAccessKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    awsSecretAccessKey?: NullableStringFieldUpdateOperationsInput | string | null
    awsRegion?: NullableStringFieldUpdateOperationsInput | string | null
    awsBucket?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    maxFileSize?: IntFieldUpdateOperationsInput | number
    allowedMimeTypes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PluginCreateInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    icon?: string | null
    version?: string
    author?: string | null
    category: $Enums.PluginCategory
    price?: number
    downloadCount?: number
    rating?: number
    isActive?: boolean
    isFeatured?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    permissions: JsonNullValueInput | InputJsonValue
    dependencies: JsonNullValueInput | InputJsonValue
    changelog?: NullableJsonNullValueInput | InputJsonValue
    screenshots: JsonNullValueInput | InputJsonValue
    documentation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    installations?: PluginInstallationCreateNestedManyWithoutPluginInput
  }

  export type PluginUncheckedCreateInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    icon?: string | null
    version?: string
    author?: string | null
    category: $Enums.PluginCategory
    price?: number
    downloadCount?: number
    rating?: number
    isActive?: boolean
    isFeatured?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    permissions: JsonNullValueInput | InputJsonValue
    dependencies: JsonNullValueInput | InputJsonValue
    changelog?: NullableJsonNullValueInput | InputJsonValue
    screenshots: JsonNullValueInput | InputJsonValue
    documentation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    installations?: PluginInstallationUncheckedCreateNestedManyWithoutPluginInput
  }

  export type PluginUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumPluginCategoryFieldUpdateOperationsInput | $Enums.PluginCategory
    price?: FloatFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    permissions?: JsonNullValueInput | InputJsonValue
    dependencies?: JsonNullValueInput | InputJsonValue
    changelog?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: JsonNullValueInput | InputJsonValue
    documentation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    installations?: PluginInstallationUpdateManyWithoutPluginNestedInput
  }

  export type PluginUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumPluginCategoryFieldUpdateOperationsInput | $Enums.PluginCategory
    price?: FloatFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    permissions?: JsonNullValueInput | InputJsonValue
    dependencies?: JsonNullValueInput | InputJsonValue
    changelog?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: JsonNullValueInput | InputJsonValue
    documentation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    installations?: PluginInstallationUncheckedUpdateManyWithoutPluginNestedInput
  }

  export type PluginCreateManyInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    icon?: string | null
    version?: string
    author?: string | null
    category: $Enums.PluginCategory
    price?: number
    downloadCount?: number
    rating?: number
    isActive?: boolean
    isFeatured?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    permissions: JsonNullValueInput | InputJsonValue
    dependencies: JsonNullValueInput | InputJsonValue
    changelog?: NullableJsonNullValueInput | InputJsonValue
    screenshots: JsonNullValueInput | InputJsonValue
    documentation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PluginUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumPluginCategoryFieldUpdateOperationsInput | $Enums.PluginCategory
    price?: FloatFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    permissions?: JsonNullValueInput | InputJsonValue
    dependencies?: JsonNullValueInput | InputJsonValue
    changelog?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: JsonNullValueInput | InputJsonValue
    documentation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PluginUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumPluginCategoryFieldUpdateOperationsInput | $Enums.PluginCategory
    price?: FloatFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    permissions?: JsonNullValueInput | InputJsonValue
    dependencies?: JsonNullValueInput | InputJsonValue
    changelog?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: JsonNullValueInput | InputJsonValue
    documentation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PluginInstallationCreateInput = {
    id?: string
    isEnabled?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    installedAt?: Date | string
    updatedAt?: Date | string
    plugin: PluginCreateNestedOneWithoutInstallationsInput
  }

  export type PluginInstallationUncheckedCreateInput = {
    id?: string
    pluginId: string
    isEnabled?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    installedAt?: Date | string
    updatedAt?: Date | string
  }

  export type PluginInstallationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    installedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plugin?: PluginUpdateOneRequiredWithoutInstallationsNestedInput
  }

  export type PluginInstallationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pluginId?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    installedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PluginInstallationCreateManyInput = {
    id?: string
    pluginId: string
    isEnabled?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    installedAt?: Date | string
    updatedAt?: Date | string
  }

  export type PluginInstallationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    installedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PluginInstallationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    pluginId?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    installedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleCategoryCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: ArticleCategoryCreateNestedOneWithoutChildrenInput
    children?: ArticleCategoryCreateNestedManyWithoutParentInput
    articles?: ArticleCreateNestedManyWithoutCategoryInput
  }

  export type ArticleCategoryUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    parentId?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ArticleCategoryUncheckedCreateNestedManyWithoutParentInput
    articles?: ArticleUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ArticleCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: ArticleCategoryUpdateOneWithoutChildrenNestedInput
    children?: ArticleCategoryUpdateManyWithoutParentNestedInput
    articles?: ArticleUpdateManyWithoutCategoryNestedInput
  }

  export type ArticleCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ArticleCategoryUncheckedUpdateManyWithoutParentNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ArticleCategoryCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    parentId?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ArticleCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleCreateInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    coverImage?: string | null
    status?: $Enums.ArticleStatus
    viewCount?: number
    tags: JsonNullValueInput | InputJsonValue
    seoTitle?: string | null
    seoDescription?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: ArticleCategoryCreateNestedOneWithoutArticlesInput
    author: UserCreateNestedOneWithoutArticlesInput
  }

  export type ArticleUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    coverImage?: string | null
    categoryId?: string | null
    authorId: string
    status?: $Enums.ArticleStatus
    viewCount?: number
    tags: JsonNullValueInput | InputJsonValue
    seoTitle?: string | null
    seoDescription?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ArticleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumArticleStatusFieldUpdateOperationsInput | $Enums.ArticleStatus
    viewCount?: IntFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ArticleCategoryUpdateOneWithoutArticlesNestedInput
    author?: UserUpdateOneRequiredWithoutArticlesNestedInput
  }

  export type ArticleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    status?: EnumArticleStatusFieldUpdateOperationsInput | $Enums.ArticleStatus
    viewCount?: IntFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleCreateManyInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    coverImage?: string | null
    categoryId?: string | null
    authorId: string
    status?: $Enums.ArticleStatus
    viewCount?: number
    tags: JsonNullValueInput | InputJsonValue
    seoTitle?: string | null
    seoDescription?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ArticleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumArticleStatusFieldUpdateOperationsInput | $Enums.ArticleStatus
    viewCount?: IntFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    status?: EnumArticleStatusFieldUpdateOperationsInput | $Enums.ArticleStatus
    viewCount?: IntFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    content: string
    type: $Enums.NotificationType
    targetType: $Enums.NotificationTarget
    targetIds: JsonNullValueInput | InputJsonValue
    isRead?: boolean
    sendAt?: Date | string | null
    sentAt?: Date | string | null
    createdById?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userNotifications?: UserNotificationCreateNestedManyWithoutNotificationInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    title: string
    content: string
    type: $Enums.NotificationType
    targetType: $Enums.NotificationTarget
    targetIds: JsonNullValueInput | InputJsonValue
    isRead?: boolean
    sendAt?: Date | string | null
    sentAt?: Date | string | null
    createdById?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userNotifications?: UserNotificationUncheckedCreateNestedManyWithoutNotificationInput
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    targetType?: EnumNotificationTargetFieldUpdateOperationsInput | $Enums.NotificationTarget
    targetIds?: JsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userNotifications?: UserNotificationUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    targetType?: EnumNotificationTargetFieldUpdateOperationsInput | $Enums.NotificationTarget
    targetIds?: JsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userNotifications?: UserNotificationUncheckedUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationCreateManyInput = {
    id?: string
    title: string
    content: string
    type: $Enums.NotificationType
    targetType: $Enums.NotificationTarget
    targetIds: JsonNullValueInput | InputJsonValue
    isRead?: boolean
    sendAt?: Date | string | null
    sentAt?: Date | string | null
    createdById?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    targetType?: EnumNotificationTargetFieldUpdateOperationsInput | $Enums.NotificationTarget
    targetIds?: JsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    targetType?: EnumNotificationTargetFieldUpdateOperationsInput | $Enums.NotificationTarget
    targetIds?: JsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNotificationCreateInput = {
    id?: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
    notification: NotificationCreateNestedOneWithoutUserNotificationsInput
  }

  export type UserNotificationUncheckedCreateInput = {
    id?: string
    userId: string
    notificationId: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserNotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
    notification?: NotificationUpdateOneRequiredWithoutUserNotificationsNestedInput
  }

  export type UserNotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    notificationId?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNotificationCreateManyInput = {
    id?: string
    userId: string
    notificationId: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserNotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    notificationId?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentConfigCreateInput = {
    id?: string
    provider: $Enums.PaymentProvider
    name: string
    isEnabled?: boolean
    isSandbox?: boolean
    wechatAppId?: string | null
    wechatMchId?: string | null
    wechatApiKey?: string | null
    wechatCertPath?: string | null
    alipayAppId?: string | null
    alipayPrivateKey?: string | null
    alipayPublicKey?: string | null
    paypalClientId?: string | null
    paypalSecret?: string | null
    stripePublicKey?: string | null
    stripeSecretKey?: string | null
    stripeWebhookSecret?: string | null
    epayUrl?: string | null
    epayPid?: string | null
    epayKey?: string | null
    notifyUrl?: string | null
    returnUrl?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentConfigUncheckedCreateInput = {
    id?: string
    provider: $Enums.PaymentProvider
    name: string
    isEnabled?: boolean
    isSandbox?: boolean
    wechatAppId?: string | null
    wechatMchId?: string | null
    wechatApiKey?: string | null
    wechatCertPath?: string | null
    alipayAppId?: string | null
    alipayPrivateKey?: string | null
    alipayPublicKey?: string | null
    paypalClientId?: string | null
    paypalSecret?: string | null
    stripePublicKey?: string | null
    stripeSecretKey?: string | null
    stripeWebhookSecret?: string | null
    epayUrl?: string | null
    epayPid?: string | null
    epayKey?: string | null
    notifyUrl?: string | null
    returnUrl?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    name?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isSandbox?: BoolFieldUpdateOperationsInput | boolean
    wechatAppId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatMchId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    wechatCertPath?: NullableStringFieldUpdateOperationsInput | string | null
    alipayAppId?: NullableStringFieldUpdateOperationsInput | string | null
    alipayPrivateKey?: NullableStringFieldUpdateOperationsInput | string | null
    alipayPublicKey?: NullableStringFieldUpdateOperationsInput | string | null
    paypalClientId?: NullableStringFieldUpdateOperationsInput | string | null
    paypalSecret?: NullableStringFieldUpdateOperationsInput | string | null
    stripePublicKey?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSecretKey?: NullableStringFieldUpdateOperationsInput | string | null
    stripeWebhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    epayUrl?: NullableStringFieldUpdateOperationsInput | string | null
    epayPid?: NullableStringFieldUpdateOperationsInput | string | null
    epayKey?: NullableStringFieldUpdateOperationsInput | string | null
    notifyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    returnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    name?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isSandbox?: BoolFieldUpdateOperationsInput | boolean
    wechatAppId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatMchId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    wechatCertPath?: NullableStringFieldUpdateOperationsInput | string | null
    alipayAppId?: NullableStringFieldUpdateOperationsInput | string | null
    alipayPrivateKey?: NullableStringFieldUpdateOperationsInput | string | null
    alipayPublicKey?: NullableStringFieldUpdateOperationsInput | string | null
    paypalClientId?: NullableStringFieldUpdateOperationsInput | string | null
    paypalSecret?: NullableStringFieldUpdateOperationsInput | string | null
    stripePublicKey?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSecretKey?: NullableStringFieldUpdateOperationsInput | string | null
    stripeWebhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    epayUrl?: NullableStringFieldUpdateOperationsInput | string | null
    epayPid?: NullableStringFieldUpdateOperationsInput | string | null
    epayKey?: NullableStringFieldUpdateOperationsInput | string | null
    notifyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    returnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentConfigCreateManyInput = {
    id?: string
    provider: $Enums.PaymentProvider
    name: string
    isEnabled?: boolean
    isSandbox?: boolean
    wechatAppId?: string | null
    wechatMchId?: string | null
    wechatApiKey?: string | null
    wechatCertPath?: string | null
    alipayAppId?: string | null
    alipayPrivateKey?: string | null
    alipayPublicKey?: string | null
    paypalClientId?: string | null
    paypalSecret?: string | null
    stripePublicKey?: string | null
    stripeSecretKey?: string | null
    stripeWebhookSecret?: string | null
    epayUrl?: string | null
    epayPid?: string | null
    epayKey?: string | null
    notifyUrl?: string | null
    returnUrl?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    name?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isSandbox?: BoolFieldUpdateOperationsInput | boolean
    wechatAppId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatMchId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    wechatCertPath?: NullableStringFieldUpdateOperationsInput | string | null
    alipayAppId?: NullableStringFieldUpdateOperationsInput | string | null
    alipayPrivateKey?: NullableStringFieldUpdateOperationsInput | string | null
    alipayPublicKey?: NullableStringFieldUpdateOperationsInput | string | null
    paypalClientId?: NullableStringFieldUpdateOperationsInput | string | null
    paypalSecret?: NullableStringFieldUpdateOperationsInput | string | null
    stripePublicKey?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSecretKey?: NullableStringFieldUpdateOperationsInput | string | null
    stripeWebhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    epayUrl?: NullableStringFieldUpdateOperationsInput | string | null
    epayPid?: NullableStringFieldUpdateOperationsInput | string | null
    epayKey?: NullableStringFieldUpdateOperationsInput | string | null
    notifyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    returnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    name?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isSandbox?: BoolFieldUpdateOperationsInput | boolean
    wechatAppId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatMchId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    wechatCertPath?: NullableStringFieldUpdateOperationsInput | string | null
    alipayAppId?: NullableStringFieldUpdateOperationsInput | string | null
    alipayPrivateKey?: NullableStringFieldUpdateOperationsInput | string | null
    alipayPublicKey?: NullableStringFieldUpdateOperationsInput | string | null
    paypalClientId?: NullableStringFieldUpdateOperationsInput | string | null
    paypalSecret?: NullableStringFieldUpdateOperationsInput | string | null
    stripePublicKey?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSecretKey?: NullableStringFieldUpdateOperationsInput | string | null
    stripeWebhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    epayUrl?: NullableStringFieldUpdateOperationsInput | string | null
    epayPid?: NullableStringFieldUpdateOperationsInput | string | null
    epayKey?: NullableStringFieldUpdateOperationsInput | string | null
    notifyUrl?: NullableStringFieldUpdateOperationsInput | string | null
    returnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    id?: string
    orderNo: string
    orderType: $Enums.OrderType
    status?: $Enums.OrderStatus
    amount: number
    currency?: string
    paymentMethod?: $Enums.PaymentProvider | null
    transactionId?: string | null
    productId?: string | null
    productName: string
    productDesc?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    paidAt?: Date | string | null
    refundedAt?: Date | string | null
    expiredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    orderNo: string
    userId: string
    orderType: $Enums.OrderType
    status?: $Enums.OrderStatus
    amount: number
    currency?: string
    paymentMethod?: $Enums.PaymentProvider | null
    transactionId?: string | null
    productId?: string | null
    productName: string
    productDesc?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    paidAt?: Date | string | null
    refundedAt?: Date | string | null
    expiredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    orderType?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    productName?: StringFieldUpdateOperationsInput | string
    productDesc?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orderType?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    productName?: StringFieldUpdateOperationsInput | string
    productDesc?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyInput = {
    id?: string
    orderNo: string
    userId: string
    orderType: $Enums.OrderType
    status?: $Enums.OrderStatus
    amount: number
    currency?: string
    paymentMethod?: $Enums.PaymentProvider | null
    transactionId?: string | null
    productId?: string | null
    productName: string
    productDesc?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    paidAt?: Date | string | null
    refundedAt?: Date | string | null
    expiredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    orderType?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    productName?: StringFieldUpdateOperationsInput | string
    productDesc?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orderType?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    productName?: StringFieldUpdateOperationsInput | string
    productDesc?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipPlanCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price: number
    originalPrice?: number | null
    currency?: string
    duration: number
    features: JsonNullValueInput | InputJsonValue
    limits?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isFeatured?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutMembershipInput
  }

  export type MembershipPlanUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price: number
    originalPrice?: number | null
    currency?: string
    duration: number
    features: JsonNullValueInput | InputJsonValue
    limits?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isFeatured?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutMembershipInput
  }

  export type MembershipPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    originalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    limits?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutMembershipNestedInput
  }

  export type MembershipPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    originalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    limits?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutMembershipNestedInput
  }

  export type MembershipPlanCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price: number
    originalPrice?: number | null
    currency?: string
    duration: number
    features: JsonNullValueInput | InputJsonValue
    limits?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isFeatured?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    originalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    limits?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    originalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    limits?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointsConfigCreateInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    points: number
    isEnabled?: boolean
    dailyLimit?: number | null
    totalLimit?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PointsConfigUncheckedCreateInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    points: number
    isEnabled?: boolean
    dailyLimit?: number | null
    totalLimit?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PointsConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    dailyLimit?: NullableIntFieldUpdateOperationsInput | number | null
    totalLimit?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointsConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    dailyLimit?: NullableIntFieldUpdateOperationsInput | number | null
    totalLimit?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointsConfigCreateManyInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    points: number
    isEnabled?: boolean
    dailyLimit?: number | null
    totalLimit?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PointsConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    dailyLimit?: NullableIntFieldUpdateOperationsInput | number | null
    totalLimit?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointsConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    dailyLimit?: NullableIntFieldUpdateOperationsInput | number | null
    totalLimit?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointRecordCreateInput = {
    id?: string
    points: number
    balance: number
    type: $Enums.PointType
    description: string
    relatedId?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPointRecordsInput
  }

  export type PointRecordUncheckedCreateInput = {
    id?: string
    userId: string
    points: number
    balance: number
    type: $Enums.PointType
    description: string
    relatedId?: string | null
    createdAt?: Date | string
  }

  export type PointRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    type?: EnumPointTypeFieldUpdateOperationsInput | $Enums.PointType
    description?: StringFieldUpdateOperationsInput | string
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPointRecordsNestedInput
  }

  export type PointRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    type?: EnumPointTypeFieldUpdateOperationsInput | $Enums.PointType
    description?: StringFieldUpdateOperationsInput | string
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointRecordCreateManyInput = {
    id?: string
    userId: string
    points: number
    balance: number
    type: $Enums.PointType
    description: string
    relatedId?: string | null
    createdAt?: Date | string
  }

  export type PointRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    type?: EnumPointTypeFieldUpdateOperationsInput | $Enums.PointType
    description?: StringFieldUpdateOperationsInput | string
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    type?: EnumPointTypeFieldUpdateOperationsInput | $Enums.PointType
    description?: StringFieldUpdateOperationsInput | string
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    isSystem?: boolean
    permissions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userAssignments?: UserRoleAssignmentCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    isSystem?: boolean
    permissions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userAssignments?: UserRoleAssignmentUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAssignments?: UserRoleAssignmentUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAssignments?: UserRoleAssignmentUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    isSystem?: boolean
    permissions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleAssignmentCreateInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutRoleAssignmentsInput
    role: RoleCreateNestedOneWithoutUserAssignmentsInput
  }

  export type UserRoleAssignmentUncheckedCreateInput = {
    id?: string
    userId: string
    roleId: string
    createdAt?: Date | string
  }

  export type UserRoleAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRoleAssignmentsNestedInput
    role?: RoleUpdateOneRequiredWithoutUserAssignmentsNestedInput
  }

  export type UserRoleAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleAssignmentCreateManyInput = {
    id?: string
    userId: string
    roleId: string
    createdAt?: Date | string
  }

  export type UserRoleAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionCreateInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    module: string
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionUncheckedCreateInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    module: string
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    module?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    module?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionCreateManyInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    module: string
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    module?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    module?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageCreateInput = {
    id?: string
    code: string
    name: string
    nativeName: string
    isEnabled?: boolean
    isDefault?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    nativeName: string
    isEnabled?: boolean
    isDefault?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: TranslationUncheckedCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: TranslationUncheckedUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageCreateManyInput = {
    id?: string
    code: string
    name: string
    nativeName: string
    isEnabled?: boolean
    isDefault?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LanguageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranslationCreateInput = {
    id?: string
    key: string
    value: string
    namespace?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    language: LanguageCreateNestedOneWithoutTranslationsInput
  }

  export type TranslationUncheckedCreateInput = {
    id?: string
    languageId: string
    key: string
    value: string
    namespace?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    namespace?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    language?: LanguageUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type TranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    languageId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    namespace?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranslationCreateManyInput = {
    id?: string
    languageId: string
    key: string
    value: string
    namespace?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    namespace?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    languageId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    namespace?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type MembershipPlanNullableRelationFilter = {
    is?: MembershipPlanWhereInput | null
    isNot?: MembershipPlanWhereInput | null
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type ScenarioListRelationFilter = {
    every?: ScenarioWhereInput
    some?: ScenarioWhereInput
    none?: ScenarioWhereInput
  }

  export type FollowUpEmailListRelationFilter = {
    every?: FollowUpEmailWhereInput
    some?: FollowUpEmailWhereInput
    none?: FollowUpEmailWhereInput
  }

  export type BuyerPersonaTemplateListRelationFilter = {
    every?: BuyerPersonaTemplateWhereInput
    some?: BuyerPersonaTemplateWhereInput
    none?: BuyerPersonaTemplateWhereInput
  }

  export type OperationLogListRelationFilter = {
    every?: OperationLogWhereInput
    some?: OperationLogWhereInput
    none?: OperationLogWhereInput
  }

  export type OAuthAccountListRelationFilter = {
    every?: OAuthAccountWhereInput
    some?: OAuthAccountWhereInput
    none?: OAuthAccountWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type PointRecordListRelationFilter = {
    every?: PointRecordWhereInput
    some?: PointRecordWhereInput
    none?: PointRecordWhereInput
  }

  export type UserNotificationListRelationFilter = {
    every?: UserNotificationWhereInput
    some?: UserNotificationWhereInput
    none?: UserNotificationWhereInput
  }

  export type ArticleListRelationFilter = {
    every?: ArticleWhereInput
    some?: ArticleWhereInput
    none?: ArticleWhereInput
  }

  export type MediaListRelationFilter = {
    every?: MediaWhereInput
    some?: MediaWhereInput
    none?: MediaWhereInput
  }

  export type UserRoleAssignmentListRelationFilter = {
    every?: UserRoleAssignmentWhereInput
    some?: UserRoleAssignmentWhereInput
    none?: UserRoleAssignmentWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScenarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FollowUpEmailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BuyerPersonaTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OperationLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OAuthAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PointRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserNotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArticleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserRoleAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    department?: SortOrder
    isActive?: SortOrder
    language?: SortOrder
    membershipId?: SortOrder
    membershipExpireAt?: SortOrder
    points?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    department?: SortOrder
    isActive?: SortOrder
    language?: SortOrder
    membershipId?: SortOrder
    membershipExpireAt?: SortOrder
    points?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    department?: SortOrder
    isActive?: SortOrder
    language?: SortOrder
    membershipId?: SortOrder
    membershipExpireAt?: SortOrder
    points?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumOAuthProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.OAuthProvider | EnumOAuthProviderFieldRefInput<$PrismaModel>
    in?: $Enums.OAuthProvider[]
    notIn?: $Enums.OAuthProvider[]
    not?: NestedEnumOAuthProviderFilter<$PrismaModel> | $Enums.OAuthProvider
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type OAuthAccountProviderProviderIdCompoundUniqueInput = {
    provider: $Enums.OAuthProvider
    providerId: string
  }

  export type OAuthAccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    tokenExpireAt?: SortOrder
    profile?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OAuthAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    tokenExpireAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OAuthAccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    tokenExpireAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumOAuthProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OAuthProvider | EnumOAuthProviderFieldRefInput<$PrismaModel>
    in?: $Enums.OAuthProvider[]
    notIn?: $Enums.OAuthProvider[]
    not?: NestedEnumOAuthProviderWithAggregatesFilter<$PrismaModel> | $Enums.OAuthProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOAuthProviderFilter<$PrismaModel>
    _max?: NestedEnumOAuthProviderFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type LoginConfigCountOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    name?: SortOrder
    isEnabled?: SortOrder
    appId?: SortOrder
    appSecret?: SortOrder
    redirectUri?: SortOrder
    scope?: SortOrder
    config?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoginConfigAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type LoginConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    name?: SortOrder
    isEnabled?: SortOrder
    appId?: SortOrder
    appSecret?: SortOrder
    redirectUri?: SortOrder
    scope?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoginConfigMinOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    name?: SortOrder
    isEnabled?: SortOrder
    appId?: SortOrder
    appSecret?: SortOrder
    redirectUri?: SortOrder
    scope?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoginConfigSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type EnumDifficultyFilter<$PrismaModel = never> = {
    equals?: $Enums.Difficulty | EnumDifficultyFieldRefInput<$PrismaModel>
    in?: $Enums.Difficulty[]
    notIn?: $Enums.Difficulty[]
    not?: NestedEnumDifficultyFilter<$PrismaModel> | $Enums.Difficulty
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ScenarioCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    estimatedDuration?: SortOrder
    isActive?: SortOrder
    practiceCount?: SortOrder
    averageScore?: SortOrder
    buyerPersona?: SortOrder
    objections?: SortOrder
    idealResponses?: SortOrder
    maxTurns?: SortOrder
    scoringWeights?: SortOrder
    openingPrompt?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScenarioAvgOrderByAggregateInput = {
    estimatedDuration?: SortOrder
    practiceCount?: SortOrder
    averageScore?: SortOrder
    maxTurns?: SortOrder
  }

  export type ScenarioMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    estimatedDuration?: SortOrder
    isActive?: SortOrder
    practiceCount?: SortOrder
    averageScore?: SortOrder
    maxTurns?: SortOrder
    openingPrompt?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScenarioMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    estimatedDuration?: SortOrder
    isActive?: SortOrder
    practiceCount?: SortOrder
    averageScore?: SortOrder
    maxTurns?: SortOrder
    openingPrompt?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScenarioSumOrderByAggregateInput = {
    estimatedDuration?: SortOrder
    practiceCount?: SortOrder
    averageScore?: SortOrder
    maxTurns?: SortOrder
  }

  export type EnumDifficultyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Difficulty | EnumDifficultyFieldRefInput<$PrismaModel>
    in?: $Enums.Difficulty[]
    notIn?: $Enums.Difficulty[]
    not?: NestedEnumDifficultyWithAggregatesFilter<$PrismaModel> | $Enums.Difficulty
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDifficultyFilter<$PrismaModel>
    _max?: NestedEnumDifficultyFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[]
    notIn?: $Enums.SessionStatus[]
    not?: NestedEnumSessionStatusFilter<$PrismaModel> | $Enums.SessionStatus
  }

  export type ScenarioRelationFilter = {
    is?: ScenarioWhereInput
    isNot?: ScenarioWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type FeedbackNullableRelationFilter = {
    is?: FeedbackWhereInput | null
    isNot?: FeedbackWhereInput | null
  }

  export type FollowUpEmailNullableRelationFilter = {
    is?: FollowUpEmailWhereInput | null
    isNot?: FollowUpEmailWhereInput | null
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    scenarioId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    scenarioId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    scenarioId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type EnumSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[]
    notIn?: $Enums.SessionStatus[]
    not?: NestedEnumSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumSessionStatusFilter<$PrismaModel>
  }

  export type EnumMessageRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageRole | EnumMessageRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MessageRole[]
    notIn?: $Enums.MessageRole[]
    not?: NestedEnumMessageRoleFilter<$PrismaModel> | $Enums.MessageRole
  }

  export type SessionRelationFilter = {
    is?: SessionWhereInput
    isNot?: SessionWhereInput
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
  }

  export type EnumMessageRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageRole | EnumMessageRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MessageRole[]
    notIn?: $Enums.MessageRole[]
    not?: NestedEnumMessageRoleWithAggregatesFilter<$PrismaModel> | $Enums.MessageRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageRoleFilter<$PrismaModel>
    _max?: NestedEnumMessageRoleFilter<$PrismaModel>
  }

  export type FeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    overallScore?: SortOrder
    dimensions?: SortOrder
    summary?: SortOrder
    recommendations?: SortOrder
    createdAt?: SortOrder
  }

  export type FeedbackAvgOrderByAggregateInput = {
    overallScore?: SortOrder
  }

  export type FeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    overallScore?: SortOrder
    summary?: SortOrder
    createdAt?: SortOrder
  }

  export type FeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    overallScore?: SortOrder
    summary?: SortOrder
    createdAt?: SortOrder
  }

  export type FeedbackSumOrderByAggregateInput = {
    overallScore?: SortOrder
  }

  export type FollowUpEmailCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    toAddress?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    isEdited?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FollowUpEmailMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    toAddress?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    isEdited?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FollowUpEmailMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    toAddress?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    isEdited?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIModelCountOrderByAggregateInput = {
    id?: SortOrder
    modelId?: SortOrder
    name?: SortOrder
    provider?: SortOrder
    description?: SortOrder
    apiEndpoint?: SortOrder
    apiKey?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIModelMaxOrderByAggregateInput = {
    id?: SortOrder
    modelId?: SortOrder
    name?: SortOrder
    provider?: SortOrder
    description?: SortOrder
    apiEndpoint?: SortOrder
    apiKey?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIModelMinOrderByAggregateInput = {
    id?: SortOrder
    modelId?: SortOrder
    name?: SortOrder
    provider?: SortOrder
    description?: SortOrder
    apiEndpoint?: SortOrder
    apiKey?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type BuyerPersonaTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    company?: SortOrder
    background?: SortOrder
    concerns?: SortOrder
    personality?: SortOrder
    category?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuyerPersonaTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    company?: SortOrder
    background?: SortOrder
    personality?: SortOrder
    category?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuyerPersonaTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    company?: SortOrder
    background?: SortOrder
    personality?: SortOrder
    category?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OperationLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    operationType?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    description?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type OperationLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    operationType?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    description?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type OperationLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    operationType?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    description?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumStorageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StorageType | EnumStorageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StorageType[]
    notIn?: $Enums.StorageType[]
    not?: NestedEnumStorageTypeFilter<$PrismaModel> | $Enums.StorageType
  }

  export type MediaCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    originalName?: SortOrder
    path?: SortOrder
    url?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
    storageType?: SortOrder
    bucket?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaAvgOrderByAggregateInput = {
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
  }

  export type MediaMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    originalName?: SortOrder
    path?: SortOrder
    url?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
    storageType?: SortOrder
    bucket?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    originalName?: SortOrder
    path?: SortOrder
    url?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
    storageType?: SortOrder
    bucket?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaSumOrderByAggregateInput = {
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumStorageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StorageType | EnumStorageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StorageType[]
    notIn?: $Enums.StorageType[]
    not?: NestedEnumStorageTypeWithAggregatesFilter<$PrismaModel> | $Enums.StorageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStorageTypeFilter<$PrismaModel>
    _max?: NestedEnumStorageTypeFilter<$PrismaModel>
  }

  export type StorageConfigCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    isEnabled?: SortOrder
    isDefault?: SortOrder
    accessKeyId?: SortOrder
    accessKeySecret?: SortOrder
    endpoint?: SortOrder
    bucket?: SortOrder
    region?: SortOrder
    awsAccessKeyId?: SortOrder
    awsSecretAccessKey?: SortOrder
    awsRegion?: SortOrder
    awsBucket?: SortOrder
    baseUrl?: SortOrder
    maxFileSize?: SortOrder
    allowedMimeTypes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StorageConfigAvgOrderByAggregateInput = {
    maxFileSize?: SortOrder
  }

  export type StorageConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    isEnabled?: SortOrder
    isDefault?: SortOrder
    accessKeyId?: SortOrder
    accessKeySecret?: SortOrder
    endpoint?: SortOrder
    bucket?: SortOrder
    region?: SortOrder
    awsAccessKeyId?: SortOrder
    awsSecretAccessKey?: SortOrder
    awsRegion?: SortOrder
    awsBucket?: SortOrder
    baseUrl?: SortOrder
    maxFileSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StorageConfigMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    isEnabled?: SortOrder
    isDefault?: SortOrder
    accessKeyId?: SortOrder
    accessKeySecret?: SortOrder
    endpoint?: SortOrder
    bucket?: SortOrder
    region?: SortOrder
    awsAccessKeyId?: SortOrder
    awsSecretAccessKey?: SortOrder
    awsRegion?: SortOrder
    awsBucket?: SortOrder
    baseUrl?: SortOrder
    maxFileSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StorageConfigSumOrderByAggregateInput = {
    maxFileSize?: SortOrder
  }

  export type EnumPluginCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.PluginCategory | EnumPluginCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PluginCategory[]
    notIn?: $Enums.PluginCategory[]
    not?: NestedEnumPluginCategoryFilter<$PrismaModel> | $Enums.PluginCategory
  }

  export type PluginInstallationListRelationFilter = {
    every?: PluginInstallationWhereInput
    some?: PluginInstallationWhereInput
    none?: PluginInstallationWhereInput
  }

  export type PluginInstallationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PluginCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    version?: SortOrder
    author?: SortOrder
    category?: SortOrder
    price?: SortOrder
    downloadCount?: SortOrder
    rating?: SortOrder
    isActive?: SortOrder
    isFeatured?: SortOrder
    config?: SortOrder
    permissions?: SortOrder
    dependencies?: SortOrder
    changelog?: SortOrder
    screenshots?: SortOrder
    documentation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PluginAvgOrderByAggregateInput = {
    price?: SortOrder
    downloadCount?: SortOrder
    rating?: SortOrder
  }

  export type PluginMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    version?: SortOrder
    author?: SortOrder
    category?: SortOrder
    price?: SortOrder
    downloadCount?: SortOrder
    rating?: SortOrder
    isActive?: SortOrder
    isFeatured?: SortOrder
    documentation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PluginMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    version?: SortOrder
    author?: SortOrder
    category?: SortOrder
    price?: SortOrder
    downloadCount?: SortOrder
    rating?: SortOrder
    isActive?: SortOrder
    isFeatured?: SortOrder
    documentation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PluginSumOrderByAggregateInput = {
    price?: SortOrder
    downloadCount?: SortOrder
    rating?: SortOrder
  }

  export type EnumPluginCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PluginCategory | EnumPluginCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PluginCategory[]
    notIn?: $Enums.PluginCategory[]
    not?: NestedEnumPluginCategoryWithAggregatesFilter<$PrismaModel> | $Enums.PluginCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPluginCategoryFilter<$PrismaModel>
    _max?: NestedEnumPluginCategoryFilter<$PrismaModel>
  }

  export type PluginRelationFilter = {
    is?: PluginWhereInput
    isNot?: PluginWhereInput
  }

  export type PluginInstallationCountOrderByAggregateInput = {
    id?: SortOrder
    pluginId?: SortOrder
    isEnabled?: SortOrder
    config?: SortOrder
    installedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PluginInstallationMaxOrderByAggregateInput = {
    id?: SortOrder
    pluginId?: SortOrder
    isEnabled?: SortOrder
    installedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PluginInstallationMinOrderByAggregateInput = {
    id?: SortOrder
    pluginId?: SortOrder
    isEnabled?: SortOrder
    installedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArticleCategoryNullableRelationFilter = {
    is?: ArticleCategoryWhereInput | null
    isNot?: ArticleCategoryWhereInput | null
  }

  export type ArticleCategoryListRelationFilter = {
    every?: ArticleCategoryWhereInput
    some?: ArticleCategoryWhereInput
    none?: ArticleCategoryWhereInput
  }

  export type ArticleCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArticleCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArticleCategoryAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type ArticleCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArticleCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArticleCategorySumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type EnumArticleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ArticleStatus | EnumArticleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ArticleStatus[]
    notIn?: $Enums.ArticleStatus[]
    not?: NestedEnumArticleStatusFilter<$PrismaModel> | $Enums.ArticleStatus
  }

  export type ArticleCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    coverImage?: SortOrder
    categoryId?: SortOrder
    authorId?: SortOrder
    status?: SortOrder
    viewCount?: SortOrder
    tags?: SortOrder
    seoTitle?: SortOrder
    seoDescription?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArticleAvgOrderByAggregateInput = {
    viewCount?: SortOrder
  }

  export type ArticleMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    coverImage?: SortOrder
    categoryId?: SortOrder
    authorId?: SortOrder
    status?: SortOrder
    viewCount?: SortOrder
    seoTitle?: SortOrder
    seoDescription?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArticleMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    coverImage?: SortOrder
    categoryId?: SortOrder
    authorId?: SortOrder
    status?: SortOrder
    viewCount?: SortOrder
    seoTitle?: SortOrder
    seoDescription?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArticleSumOrderByAggregateInput = {
    viewCount?: SortOrder
  }

  export type EnumArticleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ArticleStatus | EnumArticleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ArticleStatus[]
    notIn?: $Enums.ArticleStatus[]
    not?: NestedEnumArticleStatusWithAggregatesFilter<$PrismaModel> | $Enums.ArticleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumArticleStatusFilter<$PrismaModel>
    _max?: NestedEnumArticleStatusFilter<$PrismaModel>
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[]
    notIn?: $Enums.NotificationType[]
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type EnumNotificationTargetFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationTarget | EnumNotificationTargetFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationTarget[]
    notIn?: $Enums.NotificationTarget[]
    not?: NestedEnumNotificationTargetFilter<$PrismaModel> | $Enums.NotificationTarget
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    targetType?: SortOrder
    targetIds?: SortOrder
    isRead?: SortOrder
    sendAt?: SortOrder
    sentAt?: SortOrder
    createdById?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    targetType?: SortOrder
    isRead?: SortOrder
    sendAt?: SortOrder
    sentAt?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    targetType?: SortOrder
    isRead?: SortOrder
    sendAt?: SortOrder
    sentAt?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[]
    notIn?: $Enums.NotificationType[]
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumNotificationTargetWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationTarget | EnumNotificationTargetFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationTarget[]
    notIn?: $Enums.NotificationTarget[]
    not?: NestedEnumNotificationTargetWithAggregatesFilter<$PrismaModel> | $Enums.NotificationTarget
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTargetFilter<$PrismaModel>
    _max?: NestedEnumNotificationTargetFilter<$PrismaModel>
  }

  export type NotificationRelationFilter = {
    is?: NotificationWhereInput
    isNot?: NotificationWhereInput
  }

  export type UserNotificationUserIdNotificationIdCompoundUniqueInput = {
    userId: string
    notificationId: string
  }

  export type UserNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationId?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationId?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    notificationId?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumPaymentProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentProvider | EnumPaymentProviderFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentProvider[]
    notIn?: $Enums.PaymentProvider[]
    not?: NestedEnumPaymentProviderFilter<$PrismaModel> | $Enums.PaymentProvider
  }

  export type PaymentConfigCountOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    name?: SortOrder
    isEnabled?: SortOrder
    isSandbox?: SortOrder
    wechatAppId?: SortOrder
    wechatMchId?: SortOrder
    wechatApiKey?: SortOrder
    wechatCertPath?: SortOrder
    alipayAppId?: SortOrder
    alipayPrivateKey?: SortOrder
    alipayPublicKey?: SortOrder
    paypalClientId?: SortOrder
    paypalSecret?: SortOrder
    stripePublicKey?: SortOrder
    stripeSecretKey?: SortOrder
    stripeWebhookSecret?: SortOrder
    epayUrl?: SortOrder
    epayPid?: SortOrder
    epayKey?: SortOrder
    notifyUrl?: SortOrder
    returnUrl?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentConfigAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type PaymentConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    name?: SortOrder
    isEnabled?: SortOrder
    isSandbox?: SortOrder
    wechatAppId?: SortOrder
    wechatMchId?: SortOrder
    wechatApiKey?: SortOrder
    wechatCertPath?: SortOrder
    alipayAppId?: SortOrder
    alipayPrivateKey?: SortOrder
    alipayPublicKey?: SortOrder
    paypalClientId?: SortOrder
    paypalSecret?: SortOrder
    stripePublicKey?: SortOrder
    stripeSecretKey?: SortOrder
    stripeWebhookSecret?: SortOrder
    epayUrl?: SortOrder
    epayPid?: SortOrder
    epayKey?: SortOrder
    notifyUrl?: SortOrder
    returnUrl?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentConfigMinOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    name?: SortOrder
    isEnabled?: SortOrder
    isSandbox?: SortOrder
    wechatAppId?: SortOrder
    wechatMchId?: SortOrder
    wechatApiKey?: SortOrder
    wechatCertPath?: SortOrder
    alipayAppId?: SortOrder
    alipayPrivateKey?: SortOrder
    alipayPublicKey?: SortOrder
    paypalClientId?: SortOrder
    paypalSecret?: SortOrder
    stripePublicKey?: SortOrder
    stripeSecretKey?: SortOrder
    stripeWebhookSecret?: SortOrder
    epayUrl?: SortOrder
    epayPid?: SortOrder
    epayKey?: SortOrder
    notifyUrl?: SortOrder
    returnUrl?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentConfigSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type EnumPaymentProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentProvider | EnumPaymentProviderFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentProvider[]
    notIn?: $Enums.PaymentProvider[]
    not?: NestedEnumPaymentProviderWithAggregatesFilter<$PrismaModel> | $Enums.PaymentProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentProviderFilter<$PrismaModel>
    _max?: NestedEnumPaymentProviderFilter<$PrismaModel>
  }

  export type EnumOrderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderType | EnumOrderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderType[]
    notIn?: $Enums.OrderType[]
    not?: NestedEnumOrderTypeFilter<$PrismaModel> | $Enums.OrderType
  }

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[]
    notIn?: $Enums.OrderStatus[]
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type EnumPaymentProviderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentProvider | EnumPaymentProviderFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentProvider[] | null
    notIn?: $Enums.PaymentProvider[] | null
    not?: NestedEnumPaymentProviderNullableFilter<$PrismaModel> | $Enums.PaymentProvider | null
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    orderNo?: SortOrder
    userId?: SortOrder
    orderType?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    productId?: SortOrder
    productName?: SortOrder
    productDesc?: SortOrder
    metadata?: SortOrder
    paidAt?: SortOrder
    refundedAt?: SortOrder
    expiredAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    orderNo?: SortOrder
    userId?: SortOrder
    orderType?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    productId?: SortOrder
    productName?: SortOrder
    productDesc?: SortOrder
    paidAt?: SortOrder
    refundedAt?: SortOrder
    expiredAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    orderNo?: SortOrder
    userId?: SortOrder
    orderType?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    productId?: SortOrder
    productName?: SortOrder
    productDesc?: SortOrder
    paidAt?: SortOrder
    refundedAt?: SortOrder
    expiredAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumOrderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderType | EnumOrderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderType[]
    notIn?: $Enums.OrderType[]
    not?: NestedEnumOrderTypeWithAggregatesFilter<$PrismaModel> | $Enums.OrderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderTypeFilter<$PrismaModel>
    _max?: NestedEnumOrderTypeFilter<$PrismaModel>
  }

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[]
    notIn?: $Enums.OrderStatus[]
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type EnumPaymentProviderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentProvider | EnumPaymentProviderFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentProvider[] | null
    notIn?: $Enums.PaymentProvider[] | null
    not?: NestedEnumPaymentProviderNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentProvider | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentProviderNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentProviderNullableFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MembershipPlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrder
    currency?: SortOrder
    duration?: SortOrder
    features?: SortOrder
    limits?: SortOrder
    isActive?: SortOrder
    isFeatured?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MembershipPlanAvgOrderByAggregateInput = {
    price?: SortOrder
    originalPrice?: SortOrder
    duration?: SortOrder
    sortOrder?: SortOrder
  }

  export type MembershipPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrder
    currency?: SortOrder
    duration?: SortOrder
    isActive?: SortOrder
    isFeatured?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MembershipPlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrder
    currency?: SortOrder
    duration?: SortOrder
    isActive?: SortOrder
    isFeatured?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MembershipPlanSumOrderByAggregateInput = {
    price?: SortOrder
    originalPrice?: SortOrder
    duration?: SortOrder
    sortOrder?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type PointsConfigCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrder
    points?: SortOrder
    isEnabled?: SortOrder
    dailyLimit?: SortOrder
    totalLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PointsConfigAvgOrderByAggregateInput = {
    points?: SortOrder
    dailyLimit?: SortOrder
    totalLimit?: SortOrder
  }

  export type PointsConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrder
    points?: SortOrder
    isEnabled?: SortOrder
    dailyLimit?: SortOrder
    totalLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PointsConfigMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrder
    points?: SortOrder
    isEnabled?: SortOrder
    dailyLimit?: SortOrder
    totalLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PointsConfigSumOrderByAggregateInput = {
    points?: SortOrder
    dailyLimit?: SortOrder
    totalLimit?: SortOrder
  }

  export type EnumPointTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PointType | EnumPointTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PointType[]
    notIn?: $Enums.PointType[]
    not?: NestedEnumPointTypeFilter<$PrismaModel> | $Enums.PointType
  }

  export type PointRecordCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    points?: SortOrder
    balance?: SortOrder
    type?: SortOrder
    description?: SortOrder
    relatedId?: SortOrder
    createdAt?: SortOrder
  }

  export type PointRecordAvgOrderByAggregateInput = {
    points?: SortOrder
    balance?: SortOrder
  }

  export type PointRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    points?: SortOrder
    balance?: SortOrder
    type?: SortOrder
    description?: SortOrder
    relatedId?: SortOrder
    createdAt?: SortOrder
  }

  export type PointRecordMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    points?: SortOrder
    balance?: SortOrder
    type?: SortOrder
    description?: SortOrder
    relatedId?: SortOrder
    createdAt?: SortOrder
  }

  export type PointRecordSumOrderByAggregateInput = {
    points?: SortOrder
    balance?: SortOrder
  }

  export type EnumPointTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PointType | EnumPointTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PointType[]
    notIn?: $Enums.PointType[]
    not?: NestedEnumPointTypeWithAggregatesFilter<$PrismaModel> | $Enums.PointType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPointTypeFilter<$PrismaModel>
    _max?: NestedEnumPointTypeFilter<$PrismaModel>
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    isSystem?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type UserRoleAssignmentUserIdRoleIdCompoundUniqueInput = {
    userId: string
    roleId: string
  }

  export type UserRoleAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserRoleAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserRoleAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrder
    module?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrder
    module?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrder
    module?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type TranslationListRelationFilter = {
    every?: TranslationWhereInput
    some?: TranslationWhereInput
    none?: TranslationWhereInput
  }

  export type TranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LanguageCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    nativeName?: SortOrder
    isEnabled?: SortOrder
    isDefault?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LanguageAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type LanguageMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    nativeName?: SortOrder
    isEnabled?: SortOrder
    isDefault?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LanguageMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    nativeName?: SortOrder
    isEnabled?: SortOrder
    isDefault?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LanguageSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type LanguageRelationFilter = {
    is?: LanguageWhereInput
    isNot?: LanguageWhereInput
  }

  export type TranslationLanguageIdKeyNamespaceCompoundUniqueInput = {
    languageId: string
    key: string
    namespace: string
  }

  export type TranslationCountOrderByAggregateInput = {
    id?: SortOrder
    languageId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    namespace?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    languageId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    namespace?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TranslationMinOrderByAggregateInput = {
    id?: SortOrder
    languageId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    namespace?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MembershipPlanCreateNestedOneWithoutUsersInput = {
    create?: XOR<MembershipPlanCreateWithoutUsersInput, MembershipPlanUncheckedCreateWithoutUsersInput>
    connectOrCreate?: MembershipPlanCreateOrConnectWithoutUsersInput
    connect?: MembershipPlanWhereUniqueInput
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type ScenarioCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ScenarioCreateWithoutCreatedByInput, ScenarioUncheckedCreateWithoutCreatedByInput> | ScenarioCreateWithoutCreatedByInput[] | ScenarioUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ScenarioCreateOrConnectWithoutCreatedByInput | ScenarioCreateOrConnectWithoutCreatedByInput[]
    createMany?: ScenarioCreateManyCreatedByInputEnvelope
    connect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
  }

  export type FollowUpEmailCreateNestedManyWithoutUserInput = {
    create?: XOR<FollowUpEmailCreateWithoutUserInput, FollowUpEmailUncheckedCreateWithoutUserInput> | FollowUpEmailCreateWithoutUserInput[] | FollowUpEmailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FollowUpEmailCreateOrConnectWithoutUserInput | FollowUpEmailCreateOrConnectWithoutUserInput[]
    createMany?: FollowUpEmailCreateManyUserInputEnvelope
    connect?: FollowUpEmailWhereUniqueInput | FollowUpEmailWhereUniqueInput[]
  }

  export type BuyerPersonaTemplateCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<BuyerPersonaTemplateCreateWithoutCreatedByInput, BuyerPersonaTemplateUncheckedCreateWithoutCreatedByInput> | BuyerPersonaTemplateCreateWithoutCreatedByInput[] | BuyerPersonaTemplateUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BuyerPersonaTemplateCreateOrConnectWithoutCreatedByInput | BuyerPersonaTemplateCreateOrConnectWithoutCreatedByInput[]
    createMany?: BuyerPersonaTemplateCreateManyCreatedByInputEnvelope
    connect?: BuyerPersonaTemplateWhereUniqueInput | BuyerPersonaTemplateWhereUniqueInput[]
  }

  export type OperationLogCreateNestedManyWithoutUserInput = {
    create?: XOR<OperationLogCreateWithoutUserInput, OperationLogUncheckedCreateWithoutUserInput> | OperationLogCreateWithoutUserInput[] | OperationLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OperationLogCreateOrConnectWithoutUserInput | OperationLogCreateOrConnectWithoutUserInput[]
    createMany?: OperationLogCreateManyUserInputEnvelope
    connect?: OperationLogWhereUniqueInput | OperationLogWhereUniqueInput[]
  }

  export type OAuthAccountCreateNestedManyWithoutUserInput = {
    create?: XOR<OAuthAccountCreateWithoutUserInput, OAuthAccountUncheckedCreateWithoutUserInput> | OAuthAccountCreateWithoutUserInput[] | OAuthAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OAuthAccountCreateOrConnectWithoutUserInput | OAuthAccountCreateOrConnectWithoutUserInput[]
    createMany?: OAuthAccountCreateManyUserInputEnvelope
    connect?: OAuthAccountWhereUniqueInput | OAuthAccountWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type PointRecordCreateNestedManyWithoutUserInput = {
    create?: XOR<PointRecordCreateWithoutUserInput, PointRecordUncheckedCreateWithoutUserInput> | PointRecordCreateWithoutUserInput[] | PointRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PointRecordCreateOrConnectWithoutUserInput | PointRecordCreateOrConnectWithoutUserInput[]
    createMany?: PointRecordCreateManyUserInputEnvelope
    connect?: PointRecordWhereUniqueInput | PointRecordWhereUniqueInput[]
  }

  export type UserNotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<UserNotificationCreateWithoutUserInput, UserNotificationUncheckedCreateWithoutUserInput> | UserNotificationCreateWithoutUserInput[] | UserNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserNotificationCreateOrConnectWithoutUserInput | UserNotificationCreateOrConnectWithoutUserInput[]
    createMany?: UserNotificationCreateManyUserInputEnvelope
    connect?: UserNotificationWhereUniqueInput | UserNotificationWhereUniqueInput[]
  }

  export type ArticleCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ArticleCreateWithoutAuthorInput, ArticleUncheckedCreateWithoutAuthorInput> | ArticleCreateWithoutAuthorInput[] | ArticleUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ArticleCreateOrConnectWithoutAuthorInput | ArticleCreateOrConnectWithoutAuthorInput[]
    createMany?: ArticleCreateManyAuthorInputEnvelope
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
  }

  export type MediaCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<MediaCreateWithoutUploadedByInput, MediaUncheckedCreateWithoutUploadedByInput> | MediaCreateWithoutUploadedByInput[] | MediaUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutUploadedByInput | MediaCreateOrConnectWithoutUploadedByInput[]
    createMany?: MediaCreateManyUploadedByInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type UserRoleAssignmentCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleAssignmentCreateWithoutUserInput, UserRoleAssignmentUncheckedCreateWithoutUserInput> | UserRoleAssignmentCreateWithoutUserInput[] | UserRoleAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleAssignmentCreateOrConnectWithoutUserInput | UserRoleAssignmentCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleAssignmentCreateManyUserInputEnvelope
    connect?: UserRoleAssignmentWhereUniqueInput | UserRoleAssignmentWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type ScenarioUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ScenarioCreateWithoutCreatedByInput, ScenarioUncheckedCreateWithoutCreatedByInput> | ScenarioCreateWithoutCreatedByInput[] | ScenarioUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ScenarioCreateOrConnectWithoutCreatedByInput | ScenarioCreateOrConnectWithoutCreatedByInput[]
    createMany?: ScenarioCreateManyCreatedByInputEnvelope
    connect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
  }

  export type FollowUpEmailUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FollowUpEmailCreateWithoutUserInput, FollowUpEmailUncheckedCreateWithoutUserInput> | FollowUpEmailCreateWithoutUserInput[] | FollowUpEmailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FollowUpEmailCreateOrConnectWithoutUserInput | FollowUpEmailCreateOrConnectWithoutUserInput[]
    createMany?: FollowUpEmailCreateManyUserInputEnvelope
    connect?: FollowUpEmailWhereUniqueInput | FollowUpEmailWhereUniqueInput[]
  }

  export type BuyerPersonaTemplateUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<BuyerPersonaTemplateCreateWithoutCreatedByInput, BuyerPersonaTemplateUncheckedCreateWithoutCreatedByInput> | BuyerPersonaTemplateCreateWithoutCreatedByInput[] | BuyerPersonaTemplateUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BuyerPersonaTemplateCreateOrConnectWithoutCreatedByInput | BuyerPersonaTemplateCreateOrConnectWithoutCreatedByInput[]
    createMany?: BuyerPersonaTemplateCreateManyCreatedByInputEnvelope
    connect?: BuyerPersonaTemplateWhereUniqueInput | BuyerPersonaTemplateWhereUniqueInput[]
  }

  export type OperationLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OperationLogCreateWithoutUserInput, OperationLogUncheckedCreateWithoutUserInput> | OperationLogCreateWithoutUserInput[] | OperationLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OperationLogCreateOrConnectWithoutUserInput | OperationLogCreateOrConnectWithoutUserInput[]
    createMany?: OperationLogCreateManyUserInputEnvelope
    connect?: OperationLogWhereUniqueInput | OperationLogWhereUniqueInput[]
  }

  export type OAuthAccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OAuthAccountCreateWithoutUserInput, OAuthAccountUncheckedCreateWithoutUserInput> | OAuthAccountCreateWithoutUserInput[] | OAuthAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OAuthAccountCreateOrConnectWithoutUserInput | OAuthAccountCreateOrConnectWithoutUserInput[]
    createMany?: OAuthAccountCreateManyUserInputEnvelope
    connect?: OAuthAccountWhereUniqueInput | OAuthAccountWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type PointRecordUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PointRecordCreateWithoutUserInput, PointRecordUncheckedCreateWithoutUserInput> | PointRecordCreateWithoutUserInput[] | PointRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PointRecordCreateOrConnectWithoutUserInput | PointRecordCreateOrConnectWithoutUserInput[]
    createMany?: PointRecordCreateManyUserInputEnvelope
    connect?: PointRecordWhereUniqueInput | PointRecordWhereUniqueInput[]
  }

  export type UserNotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserNotificationCreateWithoutUserInput, UserNotificationUncheckedCreateWithoutUserInput> | UserNotificationCreateWithoutUserInput[] | UserNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserNotificationCreateOrConnectWithoutUserInput | UserNotificationCreateOrConnectWithoutUserInput[]
    createMany?: UserNotificationCreateManyUserInputEnvelope
    connect?: UserNotificationWhereUniqueInput | UserNotificationWhereUniqueInput[]
  }

  export type ArticleUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ArticleCreateWithoutAuthorInput, ArticleUncheckedCreateWithoutAuthorInput> | ArticleCreateWithoutAuthorInput[] | ArticleUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ArticleCreateOrConnectWithoutAuthorInput | ArticleCreateOrConnectWithoutAuthorInput[]
    createMany?: ArticleCreateManyAuthorInputEnvelope
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
  }

  export type MediaUncheckedCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<MediaCreateWithoutUploadedByInput, MediaUncheckedCreateWithoutUploadedByInput> | MediaCreateWithoutUploadedByInput[] | MediaUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutUploadedByInput | MediaCreateOrConnectWithoutUploadedByInput[]
    createMany?: MediaCreateManyUploadedByInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type UserRoleAssignmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleAssignmentCreateWithoutUserInput, UserRoleAssignmentUncheckedCreateWithoutUserInput> | UserRoleAssignmentCreateWithoutUserInput[] | UserRoleAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleAssignmentCreateOrConnectWithoutUserInput | UserRoleAssignmentCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleAssignmentCreateManyUserInputEnvelope
    connect?: UserRoleAssignmentWhereUniqueInput | UserRoleAssignmentWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type MembershipPlanUpdateOneWithoutUsersNestedInput = {
    create?: XOR<MembershipPlanCreateWithoutUsersInput, MembershipPlanUncheckedCreateWithoutUsersInput>
    connectOrCreate?: MembershipPlanCreateOrConnectWithoutUsersInput
    upsert?: MembershipPlanUpsertWithoutUsersInput
    disconnect?: MembershipPlanWhereInput | boolean
    delete?: MembershipPlanWhereInput | boolean
    connect?: MembershipPlanWhereUniqueInput
    update?: XOR<XOR<MembershipPlanUpdateToOneWithWhereWithoutUsersInput, MembershipPlanUpdateWithoutUsersInput>, MembershipPlanUncheckedUpdateWithoutUsersInput>
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type ScenarioUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ScenarioCreateWithoutCreatedByInput, ScenarioUncheckedCreateWithoutCreatedByInput> | ScenarioCreateWithoutCreatedByInput[] | ScenarioUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ScenarioCreateOrConnectWithoutCreatedByInput | ScenarioCreateOrConnectWithoutCreatedByInput[]
    upsert?: ScenarioUpsertWithWhereUniqueWithoutCreatedByInput | ScenarioUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ScenarioCreateManyCreatedByInputEnvelope
    set?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    disconnect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    delete?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    connect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    update?: ScenarioUpdateWithWhereUniqueWithoutCreatedByInput | ScenarioUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ScenarioUpdateManyWithWhereWithoutCreatedByInput | ScenarioUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ScenarioScalarWhereInput | ScenarioScalarWhereInput[]
  }

  export type FollowUpEmailUpdateManyWithoutUserNestedInput = {
    create?: XOR<FollowUpEmailCreateWithoutUserInput, FollowUpEmailUncheckedCreateWithoutUserInput> | FollowUpEmailCreateWithoutUserInput[] | FollowUpEmailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FollowUpEmailCreateOrConnectWithoutUserInput | FollowUpEmailCreateOrConnectWithoutUserInput[]
    upsert?: FollowUpEmailUpsertWithWhereUniqueWithoutUserInput | FollowUpEmailUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FollowUpEmailCreateManyUserInputEnvelope
    set?: FollowUpEmailWhereUniqueInput | FollowUpEmailWhereUniqueInput[]
    disconnect?: FollowUpEmailWhereUniqueInput | FollowUpEmailWhereUniqueInput[]
    delete?: FollowUpEmailWhereUniqueInput | FollowUpEmailWhereUniqueInput[]
    connect?: FollowUpEmailWhereUniqueInput | FollowUpEmailWhereUniqueInput[]
    update?: FollowUpEmailUpdateWithWhereUniqueWithoutUserInput | FollowUpEmailUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FollowUpEmailUpdateManyWithWhereWithoutUserInput | FollowUpEmailUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FollowUpEmailScalarWhereInput | FollowUpEmailScalarWhereInput[]
  }

  export type BuyerPersonaTemplateUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<BuyerPersonaTemplateCreateWithoutCreatedByInput, BuyerPersonaTemplateUncheckedCreateWithoutCreatedByInput> | BuyerPersonaTemplateCreateWithoutCreatedByInput[] | BuyerPersonaTemplateUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BuyerPersonaTemplateCreateOrConnectWithoutCreatedByInput | BuyerPersonaTemplateCreateOrConnectWithoutCreatedByInput[]
    upsert?: BuyerPersonaTemplateUpsertWithWhereUniqueWithoutCreatedByInput | BuyerPersonaTemplateUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: BuyerPersonaTemplateCreateManyCreatedByInputEnvelope
    set?: BuyerPersonaTemplateWhereUniqueInput | BuyerPersonaTemplateWhereUniqueInput[]
    disconnect?: BuyerPersonaTemplateWhereUniqueInput | BuyerPersonaTemplateWhereUniqueInput[]
    delete?: BuyerPersonaTemplateWhereUniqueInput | BuyerPersonaTemplateWhereUniqueInput[]
    connect?: BuyerPersonaTemplateWhereUniqueInput | BuyerPersonaTemplateWhereUniqueInput[]
    update?: BuyerPersonaTemplateUpdateWithWhereUniqueWithoutCreatedByInput | BuyerPersonaTemplateUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: BuyerPersonaTemplateUpdateManyWithWhereWithoutCreatedByInput | BuyerPersonaTemplateUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: BuyerPersonaTemplateScalarWhereInput | BuyerPersonaTemplateScalarWhereInput[]
  }

  export type OperationLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<OperationLogCreateWithoutUserInput, OperationLogUncheckedCreateWithoutUserInput> | OperationLogCreateWithoutUserInput[] | OperationLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OperationLogCreateOrConnectWithoutUserInput | OperationLogCreateOrConnectWithoutUserInput[]
    upsert?: OperationLogUpsertWithWhereUniqueWithoutUserInput | OperationLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OperationLogCreateManyUserInputEnvelope
    set?: OperationLogWhereUniqueInput | OperationLogWhereUniqueInput[]
    disconnect?: OperationLogWhereUniqueInput | OperationLogWhereUniqueInput[]
    delete?: OperationLogWhereUniqueInput | OperationLogWhereUniqueInput[]
    connect?: OperationLogWhereUniqueInput | OperationLogWhereUniqueInput[]
    update?: OperationLogUpdateWithWhereUniqueWithoutUserInput | OperationLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OperationLogUpdateManyWithWhereWithoutUserInput | OperationLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OperationLogScalarWhereInput | OperationLogScalarWhereInput[]
  }

  export type OAuthAccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<OAuthAccountCreateWithoutUserInput, OAuthAccountUncheckedCreateWithoutUserInput> | OAuthAccountCreateWithoutUserInput[] | OAuthAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OAuthAccountCreateOrConnectWithoutUserInput | OAuthAccountCreateOrConnectWithoutUserInput[]
    upsert?: OAuthAccountUpsertWithWhereUniqueWithoutUserInput | OAuthAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OAuthAccountCreateManyUserInputEnvelope
    set?: OAuthAccountWhereUniqueInput | OAuthAccountWhereUniqueInput[]
    disconnect?: OAuthAccountWhereUniqueInput | OAuthAccountWhereUniqueInput[]
    delete?: OAuthAccountWhereUniqueInput | OAuthAccountWhereUniqueInput[]
    connect?: OAuthAccountWhereUniqueInput | OAuthAccountWhereUniqueInput[]
    update?: OAuthAccountUpdateWithWhereUniqueWithoutUserInput | OAuthAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OAuthAccountUpdateManyWithWhereWithoutUserInput | OAuthAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OAuthAccountScalarWhereInput | OAuthAccountScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type PointRecordUpdateManyWithoutUserNestedInput = {
    create?: XOR<PointRecordCreateWithoutUserInput, PointRecordUncheckedCreateWithoutUserInput> | PointRecordCreateWithoutUserInput[] | PointRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PointRecordCreateOrConnectWithoutUserInput | PointRecordCreateOrConnectWithoutUserInput[]
    upsert?: PointRecordUpsertWithWhereUniqueWithoutUserInput | PointRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PointRecordCreateManyUserInputEnvelope
    set?: PointRecordWhereUniqueInput | PointRecordWhereUniqueInput[]
    disconnect?: PointRecordWhereUniqueInput | PointRecordWhereUniqueInput[]
    delete?: PointRecordWhereUniqueInput | PointRecordWhereUniqueInput[]
    connect?: PointRecordWhereUniqueInput | PointRecordWhereUniqueInput[]
    update?: PointRecordUpdateWithWhereUniqueWithoutUserInput | PointRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PointRecordUpdateManyWithWhereWithoutUserInput | PointRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PointRecordScalarWhereInput | PointRecordScalarWhereInput[]
  }

  export type UserNotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserNotificationCreateWithoutUserInput, UserNotificationUncheckedCreateWithoutUserInput> | UserNotificationCreateWithoutUserInput[] | UserNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserNotificationCreateOrConnectWithoutUserInput | UserNotificationCreateOrConnectWithoutUserInput[]
    upsert?: UserNotificationUpsertWithWhereUniqueWithoutUserInput | UserNotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserNotificationCreateManyUserInputEnvelope
    set?: UserNotificationWhereUniqueInput | UserNotificationWhereUniqueInput[]
    disconnect?: UserNotificationWhereUniqueInput | UserNotificationWhereUniqueInput[]
    delete?: UserNotificationWhereUniqueInput | UserNotificationWhereUniqueInput[]
    connect?: UserNotificationWhereUniqueInput | UserNotificationWhereUniqueInput[]
    update?: UserNotificationUpdateWithWhereUniqueWithoutUserInput | UserNotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserNotificationUpdateManyWithWhereWithoutUserInput | UserNotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserNotificationScalarWhereInput | UserNotificationScalarWhereInput[]
  }

  export type ArticleUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ArticleCreateWithoutAuthorInput, ArticleUncheckedCreateWithoutAuthorInput> | ArticleCreateWithoutAuthorInput[] | ArticleUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ArticleCreateOrConnectWithoutAuthorInput | ArticleCreateOrConnectWithoutAuthorInput[]
    upsert?: ArticleUpsertWithWhereUniqueWithoutAuthorInput | ArticleUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ArticleCreateManyAuthorInputEnvelope
    set?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    disconnect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    delete?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    update?: ArticleUpdateWithWhereUniqueWithoutAuthorInput | ArticleUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ArticleUpdateManyWithWhereWithoutAuthorInput | ArticleUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ArticleScalarWhereInput | ArticleScalarWhereInput[]
  }

  export type MediaUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<MediaCreateWithoutUploadedByInput, MediaUncheckedCreateWithoutUploadedByInput> | MediaCreateWithoutUploadedByInput[] | MediaUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutUploadedByInput | MediaCreateOrConnectWithoutUploadedByInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutUploadedByInput | MediaUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: MediaCreateManyUploadedByInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutUploadedByInput | MediaUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutUploadedByInput | MediaUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type UserRoleAssignmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleAssignmentCreateWithoutUserInput, UserRoleAssignmentUncheckedCreateWithoutUserInput> | UserRoleAssignmentCreateWithoutUserInput[] | UserRoleAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleAssignmentCreateOrConnectWithoutUserInput | UserRoleAssignmentCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleAssignmentUpsertWithWhereUniqueWithoutUserInput | UserRoleAssignmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleAssignmentCreateManyUserInputEnvelope
    set?: UserRoleAssignmentWhereUniqueInput | UserRoleAssignmentWhereUniqueInput[]
    disconnect?: UserRoleAssignmentWhereUniqueInput | UserRoleAssignmentWhereUniqueInput[]
    delete?: UserRoleAssignmentWhereUniqueInput | UserRoleAssignmentWhereUniqueInput[]
    connect?: UserRoleAssignmentWhereUniqueInput | UserRoleAssignmentWhereUniqueInput[]
    update?: UserRoleAssignmentUpdateWithWhereUniqueWithoutUserInput | UserRoleAssignmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleAssignmentUpdateManyWithWhereWithoutUserInput | UserRoleAssignmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleAssignmentScalarWhereInput | UserRoleAssignmentScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type ScenarioUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ScenarioCreateWithoutCreatedByInput, ScenarioUncheckedCreateWithoutCreatedByInput> | ScenarioCreateWithoutCreatedByInput[] | ScenarioUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ScenarioCreateOrConnectWithoutCreatedByInput | ScenarioCreateOrConnectWithoutCreatedByInput[]
    upsert?: ScenarioUpsertWithWhereUniqueWithoutCreatedByInput | ScenarioUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ScenarioCreateManyCreatedByInputEnvelope
    set?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    disconnect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    delete?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    connect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    update?: ScenarioUpdateWithWhereUniqueWithoutCreatedByInput | ScenarioUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ScenarioUpdateManyWithWhereWithoutCreatedByInput | ScenarioUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ScenarioScalarWhereInput | ScenarioScalarWhereInput[]
  }

  export type FollowUpEmailUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FollowUpEmailCreateWithoutUserInput, FollowUpEmailUncheckedCreateWithoutUserInput> | FollowUpEmailCreateWithoutUserInput[] | FollowUpEmailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FollowUpEmailCreateOrConnectWithoutUserInput | FollowUpEmailCreateOrConnectWithoutUserInput[]
    upsert?: FollowUpEmailUpsertWithWhereUniqueWithoutUserInput | FollowUpEmailUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FollowUpEmailCreateManyUserInputEnvelope
    set?: FollowUpEmailWhereUniqueInput | FollowUpEmailWhereUniqueInput[]
    disconnect?: FollowUpEmailWhereUniqueInput | FollowUpEmailWhereUniqueInput[]
    delete?: FollowUpEmailWhereUniqueInput | FollowUpEmailWhereUniqueInput[]
    connect?: FollowUpEmailWhereUniqueInput | FollowUpEmailWhereUniqueInput[]
    update?: FollowUpEmailUpdateWithWhereUniqueWithoutUserInput | FollowUpEmailUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FollowUpEmailUpdateManyWithWhereWithoutUserInput | FollowUpEmailUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FollowUpEmailScalarWhereInput | FollowUpEmailScalarWhereInput[]
  }

  export type BuyerPersonaTemplateUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<BuyerPersonaTemplateCreateWithoutCreatedByInput, BuyerPersonaTemplateUncheckedCreateWithoutCreatedByInput> | BuyerPersonaTemplateCreateWithoutCreatedByInput[] | BuyerPersonaTemplateUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BuyerPersonaTemplateCreateOrConnectWithoutCreatedByInput | BuyerPersonaTemplateCreateOrConnectWithoutCreatedByInput[]
    upsert?: BuyerPersonaTemplateUpsertWithWhereUniqueWithoutCreatedByInput | BuyerPersonaTemplateUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: BuyerPersonaTemplateCreateManyCreatedByInputEnvelope
    set?: BuyerPersonaTemplateWhereUniqueInput | BuyerPersonaTemplateWhereUniqueInput[]
    disconnect?: BuyerPersonaTemplateWhereUniqueInput | BuyerPersonaTemplateWhereUniqueInput[]
    delete?: BuyerPersonaTemplateWhereUniqueInput | BuyerPersonaTemplateWhereUniqueInput[]
    connect?: BuyerPersonaTemplateWhereUniqueInput | BuyerPersonaTemplateWhereUniqueInput[]
    update?: BuyerPersonaTemplateUpdateWithWhereUniqueWithoutCreatedByInput | BuyerPersonaTemplateUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: BuyerPersonaTemplateUpdateManyWithWhereWithoutCreatedByInput | BuyerPersonaTemplateUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: BuyerPersonaTemplateScalarWhereInput | BuyerPersonaTemplateScalarWhereInput[]
  }

  export type OperationLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OperationLogCreateWithoutUserInput, OperationLogUncheckedCreateWithoutUserInput> | OperationLogCreateWithoutUserInput[] | OperationLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OperationLogCreateOrConnectWithoutUserInput | OperationLogCreateOrConnectWithoutUserInput[]
    upsert?: OperationLogUpsertWithWhereUniqueWithoutUserInput | OperationLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OperationLogCreateManyUserInputEnvelope
    set?: OperationLogWhereUniqueInput | OperationLogWhereUniqueInput[]
    disconnect?: OperationLogWhereUniqueInput | OperationLogWhereUniqueInput[]
    delete?: OperationLogWhereUniqueInput | OperationLogWhereUniqueInput[]
    connect?: OperationLogWhereUniqueInput | OperationLogWhereUniqueInput[]
    update?: OperationLogUpdateWithWhereUniqueWithoutUserInput | OperationLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OperationLogUpdateManyWithWhereWithoutUserInput | OperationLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OperationLogScalarWhereInput | OperationLogScalarWhereInput[]
  }

  export type OAuthAccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OAuthAccountCreateWithoutUserInput, OAuthAccountUncheckedCreateWithoutUserInput> | OAuthAccountCreateWithoutUserInput[] | OAuthAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OAuthAccountCreateOrConnectWithoutUserInput | OAuthAccountCreateOrConnectWithoutUserInput[]
    upsert?: OAuthAccountUpsertWithWhereUniqueWithoutUserInput | OAuthAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OAuthAccountCreateManyUserInputEnvelope
    set?: OAuthAccountWhereUniqueInput | OAuthAccountWhereUniqueInput[]
    disconnect?: OAuthAccountWhereUniqueInput | OAuthAccountWhereUniqueInput[]
    delete?: OAuthAccountWhereUniqueInput | OAuthAccountWhereUniqueInput[]
    connect?: OAuthAccountWhereUniqueInput | OAuthAccountWhereUniqueInput[]
    update?: OAuthAccountUpdateWithWhereUniqueWithoutUserInput | OAuthAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OAuthAccountUpdateManyWithWhereWithoutUserInput | OAuthAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OAuthAccountScalarWhereInput | OAuthAccountScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type PointRecordUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PointRecordCreateWithoutUserInput, PointRecordUncheckedCreateWithoutUserInput> | PointRecordCreateWithoutUserInput[] | PointRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PointRecordCreateOrConnectWithoutUserInput | PointRecordCreateOrConnectWithoutUserInput[]
    upsert?: PointRecordUpsertWithWhereUniqueWithoutUserInput | PointRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PointRecordCreateManyUserInputEnvelope
    set?: PointRecordWhereUniqueInput | PointRecordWhereUniqueInput[]
    disconnect?: PointRecordWhereUniqueInput | PointRecordWhereUniqueInput[]
    delete?: PointRecordWhereUniqueInput | PointRecordWhereUniqueInput[]
    connect?: PointRecordWhereUniqueInput | PointRecordWhereUniqueInput[]
    update?: PointRecordUpdateWithWhereUniqueWithoutUserInput | PointRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PointRecordUpdateManyWithWhereWithoutUserInput | PointRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PointRecordScalarWhereInput | PointRecordScalarWhereInput[]
  }

  export type UserNotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserNotificationCreateWithoutUserInput, UserNotificationUncheckedCreateWithoutUserInput> | UserNotificationCreateWithoutUserInput[] | UserNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserNotificationCreateOrConnectWithoutUserInput | UserNotificationCreateOrConnectWithoutUserInput[]
    upsert?: UserNotificationUpsertWithWhereUniqueWithoutUserInput | UserNotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserNotificationCreateManyUserInputEnvelope
    set?: UserNotificationWhereUniqueInput | UserNotificationWhereUniqueInput[]
    disconnect?: UserNotificationWhereUniqueInput | UserNotificationWhereUniqueInput[]
    delete?: UserNotificationWhereUniqueInput | UserNotificationWhereUniqueInput[]
    connect?: UserNotificationWhereUniqueInput | UserNotificationWhereUniqueInput[]
    update?: UserNotificationUpdateWithWhereUniqueWithoutUserInput | UserNotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserNotificationUpdateManyWithWhereWithoutUserInput | UserNotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserNotificationScalarWhereInput | UserNotificationScalarWhereInput[]
  }

  export type ArticleUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ArticleCreateWithoutAuthorInput, ArticleUncheckedCreateWithoutAuthorInput> | ArticleCreateWithoutAuthorInput[] | ArticleUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ArticleCreateOrConnectWithoutAuthorInput | ArticleCreateOrConnectWithoutAuthorInput[]
    upsert?: ArticleUpsertWithWhereUniqueWithoutAuthorInput | ArticleUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ArticleCreateManyAuthorInputEnvelope
    set?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    disconnect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    delete?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    update?: ArticleUpdateWithWhereUniqueWithoutAuthorInput | ArticleUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ArticleUpdateManyWithWhereWithoutAuthorInput | ArticleUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ArticleScalarWhereInput | ArticleScalarWhereInput[]
  }

  export type MediaUncheckedUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<MediaCreateWithoutUploadedByInput, MediaUncheckedCreateWithoutUploadedByInput> | MediaCreateWithoutUploadedByInput[] | MediaUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutUploadedByInput | MediaCreateOrConnectWithoutUploadedByInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutUploadedByInput | MediaUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: MediaCreateManyUploadedByInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutUploadedByInput | MediaUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutUploadedByInput | MediaUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type UserRoleAssignmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleAssignmentCreateWithoutUserInput, UserRoleAssignmentUncheckedCreateWithoutUserInput> | UserRoleAssignmentCreateWithoutUserInput[] | UserRoleAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleAssignmentCreateOrConnectWithoutUserInput | UserRoleAssignmentCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleAssignmentUpsertWithWhereUniqueWithoutUserInput | UserRoleAssignmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleAssignmentCreateManyUserInputEnvelope
    set?: UserRoleAssignmentWhereUniqueInput | UserRoleAssignmentWhereUniqueInput[]
    disconnect?: UserRoleAssignmentWhereUniqueInput | UserRoleAssignmentWhereUniqueInput[]
    delete?: UserRoleAssignmentWhereUniqueInput | UserRoleAssignmentWhereUniqueInput[]
    connect?: UserRoleAssignmentWhereUniqueInput | UserRoleAssignmentWhereUniqueInput[]
    update?: UserRoleAssignmentUpdateWithWhereUniqueWithoutUserInput | UserRoleAssignmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleAssignmentUpdateManyWithWhereWithoutUserInput | UserRoleAssignmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleAssignmentScalarWhereInput | UserRoleAssignmentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutOauthAccountsInput = {
    create?: XOR<UserCreateWithoutOauthAccountsInput, UserUncheckedCreateWithoutOauthAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOauthAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumOAuthProviderFieldUpdateOperationsInput = {
    set?: $Enums.OAuthProvider
  }

  export type UserUpdateOneRequiredWithoutOauthAccountsNestedInput = {
    create?: XOR<UserCreateWithoutOauthAccountsInput, UserUncheckedCreateWithoutOauthAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOauthAccountsInput
    upsert?: UserUpsertWithoutOauthAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOauthAccountsInput, UserUpdateWithoutOauthAccountsInput>, UserUncheckedUpdateWithoutOauthAccountsInput>
  }

  export type UserCreateNestedOneWithoutScenariosInput = {
    create?: XOR<UserCreateWithoutScenariosInput, UserUncheckedCreateWithoutScenariosInput>
    connectOrCreate?: UserCreateOrConnectWithoutScenariosInput
    connect?: UserWhereUniqueInput
  }

  export type SessionCreateNestedManyWithoutScenarioInput = {
    create?: XOR<SessionCreateWithoutScenarioInput, SessionUncheckedCreateWithoutScenarioInput> | SessionCreateWithoutScenarioInput[] | SessionUncheckedCreateWithoutScenarioInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutScenarioInput | SessionCreateOrConnectWithoutScenarioInput[]
    createMany?: SessionCreateManyScenarioInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutScenarioInput = {
    create?: XOR<SessionCreateWithoutScenarioInput, SessionUncheckedCreateWithoutScenarioInput> | SessionCreateWithoutScenarioInput[] | SessionUncheckedCreateWithoutScenarioInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutScenarioInput | SessionCreateOrConnectWithoutScenarioInput[]
    createMany?: SessionCreateManyScenarioInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type EnumDifficultyFieldUpdateOperationsInput = {
    set?: $Enums.Difficulty
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutScenariosNestedInput = {
    create?: XOR<UserCreateWithoutScenariosInput, UserUncheckedCreateWithoutScenariosInput>
    connectOrCreate?: UserCreateOrConnectWithoutScenariosInput
    upsert?: UserUpsertWithoutScenariosInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutScenariosInput, UserUpdateWithoutScenariosInput>, UserUncheckedUpdateWithoutScenariosInput>
  }

  export type SessionUpdateManyWithoutScenarioNestedInput = {
    create?: XOR<SessionCreateWithoutScenarioInput, SessionUncheckedCreateWithoutScenarioInput> | SessionCreateWithoutScenarioInput[] | SessionUncheckedCreateWithoutScenarioInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutScenarioInput | SessionCreateOrConnectWithoutScenarioInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutScenarioInput | SessionUpsertWithWhereUniqueWithoutScenarioInput[]
    createMany?: SessionCreateManyScenarioInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutScenarioInput | SessionUpdateWithWhereUniqueWithoutScenarioInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutScenarioInput | SessionUpdateManyWithWhereWithoutScenarioInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutScenarioNestedInput = {
    create?: XOR<SessionCreateWithoutScenarioInput, SessionUncheckedCreateWithoutScenarioInput> | SessionCreateWithoutScenarioInput[] | SessionUncheckedCreateWithoutScenarioInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutScenarioInput | SessionCreateOrConnectWithoutScenarioInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutScenarioInput | SessionUpsertWithWhereUniqueWithoutScenarioInput[]
    createMany?: SessionCreateManyScenarioInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutScenarioInput | SessionUpdateWithWhereUniqueWithoutScenarioInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutScenarioInput | SessionUpdateManyWithWhereWithoutScenarioInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type ScenarioCreateNestedOneWithoutSessionsInput = {
    create?: XOR<ScenarioCreateWithoutSessionsInput, ScenarioUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: ScenarioCreateOrConnectWithoutSessionsInput
    connect?: ScenarioWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutSessionInput = {
    create?: XOR<MessageCreateWithoutSessionInput, MessageUncheckedCreateWithoutSessionInput> | MessageCreateWithoutSessionInput[] | MessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSessionInput | MessageCreateOrConnectWithoutSessionInput[]
    createMany?: MessageCreateManySessionInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type FeedbackCreateNestedOneWithoutSessionInput = {
    create?: XOR<FeedbackCreateWithoutSessionInput, FeedbackUncheckedCreateWithoutSessionInput>
    connectOrCreate?: FeedbackCreateOrConnectWithoutSessionInput
    connect?: FeedbackWhereUniqueInput
  }

  export type FollowUpEmailCreateNestedOneWithoutSessionInput = {
    create?: XOR<FollowUpEmailCreateWithoutSessionInput, FollowUpEmailUncheckedCreateWithoutSessionInput>
    connectOrCreate?: FollowUpEmailCreateOrConnectWithoutSessionInput
    connect?: FollowUpEmailWhereUniqueInput
  }

  export type MessageUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<MessageCreateWithoutSessionInput, MessageUncheckedCreateWithoutSessionInput> | MessageCreateWithoutSessionInput[] | MessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSessionInput | MessageCreateOrConnectWithoutSessionInput[]
    createMany?: MessageCreateManySessionInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type FeedbackUncheckedCreateNestedOneWithoutSessionInput = {
    create?: XOR<FeedbackCreateWithoutSessionInput, FeedbackUncheckedCreateWithoutSessionInput>
    connectOrCreate?: FeedbackCreateOrConnectWithoutSessionInput
    connect?: FeedbackWhereUniqueInput
  }

  export type FollowUpEmailUncheckedCreateNestedOneWithoutSessionInput = {
    create?: XOR<FollowUpEmailCreateWithoutSessionInput, FollowUpEmailUncheckedCreateWithoutSessionInput>
    connectOrCreate?: FollowUpEmailCreateOrConnectWithoutSessionInput
    connect?: FollowUpEmailWhereUniqueInput
  }

  export type EnumSessionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SessionStatus
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type ScenarioUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<ScenarioCreateWithoutSessionsInput, ScenarioUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: ScenarioCreateOrConnectWithoutSessionsInput
    upsert?: ScenarioUpsertWithoutSessionsInput
    connect?: ScenarioWhereUniqueInput
    update?: XOR<XOR<ScenarioUpdateToOneWithWhereWithoutSessionsInput, ScenarioUpdateWithoutSessionsInput>, ScenarioUncheckedUpdateWithoutSessionsInput>
  }

  export type MessageUpdateManyWithoutSessionNestedInput = {
    create?: XOR<MessageCreateWithoutSessionInput, MessageUncheckedCreateWithoutSessionInput> | MessageCreateWithoutSessionInput[] | MessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSessionInput | MessageCreateOrConnectWithoutSessionInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSessionInput | MessageUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: MessageCreateManySessionInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSessionInput | MessageUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSessionInput | MessageUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type FeedbackUpdateOneWithoutSessionNestedInput = {
    create?: XOR<FeedbackCreateWithoutSessionInput, FeedbackUncheckedCreateWithoutSessionInput>
    connectOrCreate?: FeedbackCreateOrConnectWithoutSessionInput
    upsert?: FeedbackUpsertWithoutSessionInput
    disconnect?: FeedbackWhereInput | boolean
    delete?: FeedbackWhereInput | boolean
    connect?: FeedbackWhereUniqueInput
    update?: XOR<XOR<FeedbackUpdateToOneWithWhereWithoutSessionInput, FeedbackUpdateWithoutSessionInput>, FeedbackUncheckedUpdateWithoutSessionInput>
  }

  export type FollowUpEmailUpdateOneWithoutSessionNestedInput = {
    create?: XOR<FollowUpEmailCreateWithoutSessionInput, FollowUpEmailUncheckedCreateWithoutSessionInput>
    connectOrCreate?: FollowUpEmailCreateOrConnectWithoutSessionInput
    upsert?: FollowUpEmailUpsertWithoutSessionInput
    disconnect?: FollowUpEmailWhereInput | boolean
    delete?: FollowUpEmailWhereInput | boolean
    connect?: FollowUpEmailWhereUniqueInput
    update?: XOR<XOR<FollowUpEmailUpdateToOneWithWhereWithoutSessionInput, FollowUpEmailUpdateWithoutSessionInput>, FollowUpEmailUncheckedUpdateWithoutSessionInput>
  }

  export type MessageUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<MessageCreateWithoutSessionInput, MessageUncheckedCreateWithoutSessionInput> | MessageCreateWithoutSessionInput[] | MessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSessionInput | MessageCreateOrConnectWithoutSessionInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSessionInput | MessageUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: MessageCreateManySessionInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSessionInput | MessageUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSessionInput | MessageUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type FeedbackUncheckedUpdateOneWithoutSessionNestedInput = {
    create?: XOR<FeedbackCreateWithoutSessionInput, FeedbackUncheckedCreateWithoutSessionInput>
    connectOrCreate?: FeedbackCreateOrConnectWithoutSessionInput
    upsert?: FeedbackUpsertWithoutSessionInput
    disconnect?: FeedbackWhereInput | boolean
    delete?: FeedbackWhereInput | boolean
    connect?: FeedbackWhereUniqueInput
    update?: XOR<XOR<FeedbackUpdateToOneWithWhereWithoutSessionInput, FeedbackUpdateWithoutSessionInput>, FeedbackUncheckedUpdateWithoutSessionInput>
  }

  export type FollowUpEmailUncheckedUpdateOneWithoutSessionNestedInput = {
    create?: XOR<FollowUpEmailCreateWithoutSessionInput, FollowUpEmailUncheckedCreateWithoutSessionInput>
    connectOrCreate?: FollowUpEmailCreateOrConnectWithoutSessionInput
    upsert?: FollowUpEmailUpsertWithoutSessionInput
    disconnect?: FollowUpEmailWhereInput | boolean
    delete?: FollowUpEmailWhereInput | boolean
    connect?: FollowUpEmailWhereUniqueInput
    update?: XOR<XOR<FollowUpEmailUpdateToOneWithWhereWithoutSessionInput, FollowUpEmailUpdateWithoutSessionInput>, FollowUpEmailUncheckedUpdateWithoutSessionInput>
  }

  export type SessionCreateNestedOneWithoutMessagesInput = {
    create?: XOR<SessionCreateWithoutMessagesInput, SessionUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: SessionCreateOrConnectWithoutMessagesInput
    connect?: SessionWhereUniqueInput
  }

  export type EnumMessageRoleFieldUpdateOperationsInput = {
    set?: $Enums.MessageRole
  }

  export type SessionUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<SessionCreateWithoutMessagesInput, SessionUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: SessionCreateOrConnectWithoutMessagesInput
    upsert?: SessionUpsertWithoutMessagesInput
    connect?: SessionWhereUniqueInput
    update?: XOR<XOR<SessionUpdateToOneWithWhereWithoutMessagesInput, SessionUpdateWithoutMessagesInput>, SessionUncheckedUpdateWithoutMessagesInput>
  }

  export type SessionCreateNestedOneWithoutFeedbackInput = {
    create?: XOR<SessionCreateWithoutFeedbackInput, SessionUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: SessionCreateOrConnectWithoutFeedbackInput
    connect?: SessionWhereUniqueInput
  }

  export type SessionUpdateOneRequiredWithoutFeedbackNestedInput = {
    create?: XOR<SessionCreateWithoutFeedbackInput, SessionUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: SessionCreateOrConnectWithoutFeedbackInput
    upsert?: SessionUpsertWithoutFeedbackInput
    connect?: SessionWhereUniqueInput
    update?: XOR<XOR<SessionUpdateToOneWithWhereWithoutFeedbackInput, SessionUpdateWithoutFeedbackInput>, SessionUncheckedUpdateWithoutFeedbackInput>
  }

  export type SessionCreateNestedOneWithoutEmailInput = {
    create?: XOR<SessionCreateWithoutEmailInput, SessionUncheckedCreateWithoutEmailInput>
    connectOrCreate?: SessionCreateOrConnectWithoutEmailInput
    connect?: SessionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEmailsInput = {
    create?: XOR<UserCreateWithoutEmailsInput, UserUncheckedCreateWithoutEmailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailsInput
    connect?: UserWhereUniqueInput
  }

  export type SessionUpdateOneRequiredWithoutEmailNestedInput = {
    create?: XOR<SessionCreateWithoutEmailInput, SessionUncheckedCreateWithoutEmailInput>
    connectOrCreate?: SessionCreateOrConnectWithoutEmailInput
    upsert?: SessionUpsertWithoutEmailInput
    connect?: SessionWhereUniqueInput
    update?: XOR<XOR<SessionUpdateToOneWithWhereWithoutEmailInput, SessionUpdateWithoutEmailInput>, SessionUncheckedUpdateWithoutEmailInput>
  }

  export type UserUpdateOneRequiredWithoutEmailsNestedInput = {
    create?: XOR<UserCreateWithoutEmailsInput, UserUncheckedCreateWithoutEmailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailsInput
    upsert?: UserUpsertWithoutEmailsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmailsInput, UserUpdateWithoutEmailsInput>, UserUncheckedUpdateWithoutEmailsInput>
  }

  export type UserCreateNestedOneWithoutPersonaTemplatesInput = {
    create?: XOR<UserCreateWithoutPersonaTemplatesInput, UserUncheckedCreateWithoutPersonaTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPersonaTemplatesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutPersonaTemplatesNestedInput = {
    create?: XOR<UserCreateWithoutPersonaTemplatesInput, UserUncheckedCreateWithoutPersonaTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPersonaTemplatesInput
    upsert?: UserUpsertWithoutPersonaTemplatesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPersonaTemplatesInput, UserUpdateWithoutPersonaTemplatesInput>, UserUncheckedUpdateWithoutPersonaTemplatesInput>
  }

  export type UserCreateNestedOneWithoutOperationLogsInput = {
    create?: XOR<UserCreateWithoutOperationLogsInput, UserUncheckedCreateWithoutOperationLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOperationLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutOperationLogsNestedInput = {
    create?: XOR<UserCreateWithoutOperationLogsInput, UserUncheckedCreateWithoutOperationLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOperationLogsInput
    upsert?: UserUpsertWithoutOperationLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOperationLogsInput, UserUpdateWithoutOperationLogsInput>, UserUncheckedUpdateWithoutOperationLogsInput>
  }

  export type UserCreateNestedOneWithoutMediaInput = {
    create?: XOR<UserCreateWithoutMediaInput, UserUncheckedCreateWithoutMediaInput>
    connectOrCreate?: UserCreateOrConnectWithoutMediaInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumStorageTypeFieldUpdateOperationsInput = {
    set?: $Enums.StorageType
  }

  export type UserUpdateOneRequiredWithoutMediaNestedInput = {
    create?: XOR<UserCreateWithoutMediaInput, UserUncheckedCreateWithoutMediaInput>
    connectOrCreate?: UserCreateOrConnectWithoutMediaInput
    upsert?: UserUpsertWithoutMediaInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMediaInput, UserUpdateWithoutMediaInput>, UserUncheckedUpdateWithoutMediaInput>
  }

  export type PluginInstallationCreateNestedManyWithoutPluginInput = {
    create?: XOR<PluginInstallationCreateWithoutPluginInput, PluginInstallationUncheckedCreateWithoutPluginInput> | PluginInstallationCreateWithoutPluginInput[] | PluginInstallationUncheckedCreateWithoutPluginInput[]
    connectOrCreate?: PluginInstallationCreateOrConnectWithoutPluginInput | PluginInstallationCreateOrConnectWithoutPluginInput[]
    createMany?: PluginInstallationCreateManyPluginInputEnvelope
    connect?: PluginInstallationWhereUniqueInput | PluginInstallationWhereUniqueInput[]
  }

  export type PluginInstallationUncheckedCreateNestedManyWithoutPluginInput = {
    create?: XOR<PluginInstallationCreateWithoutPluginInput, PluginInstallationUncheckedCreateWithoutPluginInput> | PluginInstallationCreateWithoutPluginInput[] | PluginInstallationUncheckedCreateWithoutPluginInput[]
    connectOrCreate?: PluginInstallationCreateOrConnectWithoutPluginInput | PluginInstallationCreateOrConnectWithoutPluginInput[]
    createMany?: PluginInstallationCreateManyPluginInputEnvelope
    connect?: PluginInstallationWhereUniqueInput | PluginInstallationWhereUniqueInput[]
  }

  export type EnumPluginCategoryFieldUpdateOperationsInput = {
    set?: $Enums.PluginCategory
  }

  export type PluginInstallationUpdateManyWithoutPluginNestedInput = {
    create?: XOR<PluginInstallationCreateWithoutPluginInput, PluginInstallationUncheckedCreateWithoutPluginInput> | PluginInstallationCreateWithoutPluginInput[] | PluginInstallationUncheckedCreateWithoutPluginInput[]
    connectOrCreate?: PluginInstallationCreateOrConnectWithoutPluginInput | PluginInstallationCreateOrConnectWithoutPluginInput[]
    upsert?: PluginInstallationUpsertWithWhereUniqueWithoutPluginInput | PluginInstallationUpsertWithWhereUniqueWithoutPluginInput[]
    createMany?: PluginInstallationCreateManyPluginInputEnvelope
    set?: PluginInstallationWhereUniqueInput | PluginInstallationWhereUniqueInput[]
    disconnect?: PluginInstallationWhereUniqueInput | PluginInstallationWhereUniqueInput[]
    delete?: PluginInstallationWhereUniqueInput | PluginInstallationWhereUniqueInput[]
    connect?: PluginInstallationWhereUniqueInput | PluginInstallationWhereUniqueInput[]
    update?: PluginInstallationUpdateWithWhereUniqueWithoutPluginInput | PluginInstallationUpdateWithWhereUniqueWithoutPluginInput[]
    updateMany?: PluginInstallationUpdateManyWithWhereWithoutPluginInput | PluginInstallationUpdateManyWithWhereWithoutPluginInput[]
    deleteMany?: PluginInstallationScalarWhereInput | PluginInstallationScalarWhereInput[]
  }

  export type PluginInstallationUncheckedUpdateManyWithoutPluginNestedInput = {
    create?: XOR<PluginInstallationCreateWithoutPluginInput, PluginInstallationUncheckedCreateWithoutPluginInput> | PluginInstallationCreateWithoutPluginInput[] | PluginInstallationUncheckedCreateWithoutPluginInput[]
    connectOrCreate?: PluginInstallationCreateOrConnectWithoutPluginInput | PluginInstallationCreateOrConnectWithoutPluginInput[]
    upsert?: PluginInstallationUpsertWithWhereUniqueWithoutPluginInput | PluginInstallationUpsertWithWhereUniqueWithoutPluginInput[]
    createMany?: PluginInstallationCreateManyPluginInputEnvelope
    set?: PluginInstallationWhereUniqueInput | PluginInstallationWhereUniqueInput[]
    disconnect?: PluginInstallationWhereUniqueInput | PluginInstallationWhereUniqueInput[]
    delete?: PluginInstallationWhereUniqueInput | PluginInstallationWhereUniqueInput[]
    connect?: PluginInstallationWhereUniqueInput | PluginInstallationWhereUniqueInput[]
    update?: PluginInstallationUpdateWithWhereUniqueWithoutPluginInput | PluginInstallationUpdateWithWhereUniqueWithoutPluginInput[]
    updateMany?: PluginInstallationUpdateManyWithWhereWithoutPluginInput | PluginInstallationUpdateManyWithWhereWithoutPluginInput[]
    deleteMany?: PluginInstallationScalarWhereInput | PluginInstallationScalarWhereInput[]
  }

  export type PluginCreateNestedOneWithoutInstallationsInput = {
    create?: XOR<PluginCreateWithoutInstallationsInput, PluginUncheckedCreateWithoutInstallationsInput>
    connectOrCreate?: PluginCreateOrConnectWithoutInstallationsInput
    connect?: PluginWhereUniqueInput
  }

  export type PluginUpdateOneRequiredWithoutInstallationsNestedInput = {
    create?: XOR<PluginCreateWithoutInstallationsInput, PluginUncheckedCreateWithoutInstallationsInput>
    connectOrCreate?: PluginCreateOrConnectWithoutInstallationsInput
    upsert?: PluginUpsertWithoutInstallationsInput
    connect?: PluginWhereUniqueInput
    update?: XOR<XOR<PluginUpdateToOneWithWhereWithoutInstallationsInput, PluginUpdateWithoutInstallationsInput>, PluginUncheckedUpdateWithoutInstallationsInput>
  }

  export type ArticleCategoryCreateNestedOneWithoutChildrenInput = {
    create?: XOR<ArticleCategoryCreateWithoutChildrenInput, ArticleCategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: ArticleCategoryCreateOrConnectWithoutChildrenInput
    connect?: ArticleCategoryWhereUniqueInput
  }

  export type ArticleCategoryCreateNestedManyWithoutParentInput = {
    create?: XOR<ArticleCategoryCreateWithoutParentInput, ArticleCategoryUncheckedCreateWithoutParentInput> | ArticleCategoryCreateWithoutParentInput[] | ArticleCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ArticleCategoryCreateOrConnectWithoutParentInput | ArticleCategoryCreateOrConnectWithoutParentInput[]
    createMany?: ArticleCategoryCreateManyParentInputEnvelope
    connect?: ArticleCategoryWhereUniqueInput | ArticleCategoryWhereUniqueInput[]
  }

  export type ArticleCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ArticleCreateWithoutCategoryInput, ArticleUncheckedCreateWithoutCategoryInput> | ArticleCreateWithoutCategoryInput[] | ArticleUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ArticleCreateOrConnectWithoutCategoryInput | ArticleCreateOrConnectWithoutCategoryInput[]
    createMany?: ArticleCreateManyCategoryInputEnvelope
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
  }

  export type ArticleCategoryUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<ArticleCategoryCreateWithoutParentInput, ArticleCategoryUncheckedCreateWithoutParentInput> | ArticleCategoryCreateWithoutParentInput[] | ArticleCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ArticleCategoryCreateOrConnectWithoutParentInput | ArticleCategoryCreateOrConnectWithoutParentInput[]
    createMany?: ArticleCategoryCreateManyParentInputEnvelope
    connect?: ArticleCategoryWhereUniqueInput | ArticleCategoryWhereUniqueInput[]
  }

  export type ArticleUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ArticleCreateWithoutCategoryInput, ArticleUncheckedCreateWithoutCategoryInput> | ArticleCreateWithoutCategoryInput[] | ArticleUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ArticleCreateOrConnectWithoutCategoryInput | ArticleCreateOrConnectWithoutCategoryInput[]
    createMany?: ArticleCreateManyCategoryInputEnvelope
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
  }

  export type ArticleCategoryUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<ArticleCategoryCreateWithoutChildrenInput, ArticleCategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: ArticleCategoryCreateOrConnectWithoutChildrenInput
    upsert?: ArticleCategoryUpsertWithoutChildrenInput
    disconnect?: ArticleCategoryWhereInput | boolean
    delete?: ArticleCategoryWhereInput | boolean
    connect?: ArticleCategoryWhereUniqueInput
    update?: XOR<XOR<ArticleCategoryUpdateToOneWithWhereWithoutChildrenInput, ArticleCategoryUpdateWithoutChildrenInput>, ArticleCategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type ArticleCategoryUpdateManyWithoutParentNestedInput = {
    create?: XOR<ArticleCategoryCreateWithoutParentInput, ArticleCategoryUncheckedCreateWithoutParentInput> | ArticleCategoryCreateWithoutParentInput[] | ArticleCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ArticleCategoryCreateOrConnectWithoutParentInput | ArticleCategoryCreateOrConnectWithoutParentInput[]
    upsert?: ArticleCategoryUpsertWithWhereUniqueWithoutParentInput | ArticleCategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: ArticleCategoryCreateManyParentInputEnvelope
    set?: ArticleCategoryWhereUniqueInput | ArticleCategoryWhereUniqueInput[]
    disconnect?: ArticleCategoryWhereUniqueInput | ArticleCategoryWhereUniqueInput[]
    delete?: ArticleCategoryWhereUniqueInput | ArticleCategoryWhereUniqueInput[]
    connect?: ArticleCategoryWhereUniqueInput | ArticleCategoryWhereUniqueInput[]
    update?: ArticleCategoryUpdateWithWhereUniqueWithoutParentInput | ArticleCategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: ArticleCategoryUpdateManyWithWhereWithoutParentInput | ArticleCategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: ArticleCategoryScalarWhereInput | ArticleCategoryScalarWhereInput[]
  }

  export type ArticleUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ArticleCreateWithoutCategoryInput, ArticleUncheckedCreateWithoutCategoryInput> | ArticleCreateWithoutCategoryInput[] | ArticleUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ArticleCreateOrConnectWithoutCategoryInput | ArticleCreateOrConnectWithoutCategoryInput[]
    upsert?: ArticleUpsertWithWhereUniqueWithoutCategoryInput | ArticleUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ArticleCreateManyCategoryInputEnvelope
    set?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    disconnect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    delete?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    update?: ArticleUpdateWithWhereUniqueWithoutCategoryInput | ArticleUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ArticleUpdateManyWithWhereWithoutCategoryInput | ArticleUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ArticleScalarWhereInput | ArticleScalarWhereInput[]
  }

  export type ArticleCategoryUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<ArticleCategoryCreateWithoutParentInput, ArticleCategoryUncheckedCreateWithoutParentInput> | ArticleCategoryCreateWithoutParentInput[] | ArticleCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ArticleCategoryCreateOrConnectWithoutParentInput | ArticleCategoryCreateOrConnectWithoutParentInput[]
    upsert?: ArticleCategoryUpsertWithWhereUniqueWithoutParentInput | ArticleCategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: ArticleCategoryCreateManyParentInputEnvelope
    set?: ArticleCategoryWhereUniqueInput | ArticleCategoryWhereUniqueInput[]
    disconnect?: ArticleCategoryWhereUniqueInput | ArticleCategoryWhereUniqueInput[]
    delete?: ArticleCategoryWhereUniqueInput | ArticleCategoryWhereUniqueInput[]
    connect?: ArticleCategoryWhereUniqueInput | ArticleCategoryWhereUniqueInput[]
    update?: ArticleCategoryUpdateWithWhereUniqueWithoutParentInput | ArticleCategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: ArticleCategoryUpdateManyWithWhereWithoutParentInput | ArticleCategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: ArticleCategoryScalarWhereInput | ArticleCategoryScalarWhereInput[]
  }

  export type ArticleUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ArticleCreateWithoutCategoryInput, ArticleUncheckedCreateWithoutCategoryInput> | ArticleCreateWithoutCategoryInput[] | ArticleUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ArticleCreateOrConnectWithoutCategoryInput | ArticleCreateOrConnectWithoutCategoryInput[]
    upsert?: ArticleUpsertWithWhereUniqueWithoutCategoryInput | ArticleUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ArticleCreateManyCategoryInputEnvelope
    set?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    disconnect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    delete?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    update?: ArticleUpdateWithWhereUniqueWithoutCategoryInput | ArticleUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ArticleUpdateManyWithWhereWithoutCategoryInput | ArticleUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ArticleScalarWhereInput | ArticleScalarWhereInput[]
  }

  export type ArticleCategoryCreateNestedOneWithoutArticlesInput = {
    create?: XOR<ArticleCategoryCreateWithoutArticlesInput, ArticleCategoryUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: ArticleCategoryCreateOrConnectWithoutArticlesInput
    connect?: ArticleCategoryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutArticlesInput = {
    create?: XOR<UserCreateWithoutArticlesInput, UserUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: UserCreateOrConnectWithoutArticlesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumArticleStatusFieldUpdateOperationsInput = {
    set?: $Enums.ArticleStatus
  }

  export type ArticleCategoryUpdateOneWithoutArticlesNestedInput = {
    create?: XOR<ArticleCategoryCreateWithoutArticlesInput, ArticleCategoryUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: ArticleCategoryCreateOrConnectWithoutArticlesInput
    upsert?: ArticleCategoryUpsertWithoutArticlesInput
    disconnect?: ArticleCategoryWhereInput | boolean
    delete?: ArticleCategoryWhereInput | boolean
    connect?: ArticleCategoryWhereUniqueInput
    update?: XOR<XOR<ArticleCategoryUpdateToOneWithWhereWithoutArticlesInput, ArticleCategoryUpdateWithoutArticlesInput>, ArticleCategoryUncheckedUpdateWithoutArticlesInput>
  }

  export type UserUpdateOneRequiredWithoutArticlesNestedInput = {
    create?: XOR<UserCreateWithoutArticlesInput, UserUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: UserCreateOrConnectWithoutArticlesInput
    upsert?: UserUpsertWithoutArticlesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutArticlesInput, UserUpdateWithoutArticlesInput>, UserUncheckedUpdateWithoutArticlesInput>
  }

  export type UserNotificationCreateNestedManyWithoutNotificationInput = {
    create?: XOR<UserNotificationCreateWithoutNotificationInput, UserNotificationUncheckedCreateWithoutNotificationInput> | UserNotificationCreateWithoutNotificationInput[] | UserNotificationUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: UserNotificationCreateOrConnectWithoutNotificationInput | UserNotificationCreateOrConnectWithoutNotificationInput[]
    createMany?: UserNotificationCreateManyNotificationInputEnvelope
    connect?: UserNotificationWhereUniqueInput | UserNotificationWhereUniqueInput[]
  }

  export type UserNotificationUncheckedCreateNestedManyWithoutNotificationInput = {
    create?: XOR<UserNotificationCreateWithoutNotificationInput, UserNotificationUncheckedCreateWithoutNotificationInput> | UserNotificationCreateWithoutNotificationInput[] | UserNotificationUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: UserNotificationCreateOrConnectWithoutNotificationInput | UserNotificationCreateOrConnectWithoutNotificationInput[]
    createMany?: UserNotificationCreateManyNotificationInputEnvelope
    connect?: UserNotificationWhereUniqueInput | UserNotificationWhereUniqueInput[]
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type EnumNotificationTargetFieldUpdateOperationsInput = {
    set?: $Enums.NotificationTarget
  }

  export type UserNotificationUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<UserNotificationCreateWithoutNotificationInput, UserNotificationUncheckedCreateWithoutNotificationInput> | UserNotificationCreateWithoutNotificationInput[] | UserNotificationUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: UserNotificationCreateOrConnectWithoutNotificationInput | UserNotificationCreateOrConnectWithoutNotificationInput[]
    upsert?: UserNotificationUpsertWithWhereUniqueWithoutNotificationInput | UserNotificationUpsertWithWhereUniqueWithoutNotificationInput[]
    createMany?: UserNotificationCreateManyNotificationInputEnvelope
    set?: UserNotificationWhereUniqueInput | UserNotificationWhereUniqueInput[]
    disconnect?: UserNotificationWhereUniqueInput | UserNotificationWhereUniqueInput[]
    delete?: UserNotificationWhereUniqueInput | UserNotificationWhereUniqueInput[]
    connect?: UserNotificationWhereUniqueInput | UserNotificationWhereUniqueInput[]
    update?: UserNotificationUpdateWithWhereUniqueWithoutNotificationInput | UserNotificationUpdateWithWhereUniqueWithoutNotificationInput[]
    updateMany?: UserNotificationUpdateManyWithWhereWithoutNotificationInput | UserNotificationUpdateManyWithWhereWithoutNotificationInput[]
    deleteMany?: UserNotificationScalarWhereInput | UserNotificationScalarWhereInput[]
  }

  export type UserNotificationUncheckedUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<UserNotificationCreateWithoutNotificationInput, UserNotificationUncheckedCreateWithoutNotificationInput> | UserNotificationCreateWithoutNotificationInput[] | UserNotificationUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: UserNotificationCreateOrConnectWithoutNotificationInput | UserNotificationCreateOrConnectWithoutNotificationInput[]
    upsert?: UserNotificationUpsertWithWhereUniqueWithoutNotificationInput | UserNotificationUpsertWithWhereUniqueWithoutNotificationInput[]
    createMany?: UserNotificationCreateManyNotificationInputEnvelope
    set?: UserNotificationWhereUniqueInput | UserNotificationWhereUniqueInput[]
    disconnect?: UserNotificationWhereUniqueInput | UserNotificationWhereUniqueInput[]
    delete?: UserNotificationWhereUniqueInput | UserNotificationWhereUniqueInput[]
    connect?: UserNotificationWhereUniqueInput | UserNotificationWhereUniqueInput[]
    update?: UserNotificationUpdateWithWhereUniqueWithoutNotificationInput | UserNotificationUpdateWithWhereUniqueWithoutNotificationInput[]
    updateMany?: UserNotificationUpdateManyWithWhereWithoutNotificationInput | UserNotificationUpdateManyWithWhereWithoutNotificationInput[]
    deleteMany?: UserNotificationScalarWhereInput | UserNotificationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type NotificationCreateNestedOneWithoutUserNotificationsInput = {
    create?: XOR<NotificationCreateWithoutUserNotificationsInput, NotificationUncheckedCreateWithoutUserNotificationsInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutUserNotificationsInput
    connect?: NotificationWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type NotificationUpdateOneRequiredWithoutUserNotificationsNestedInput = {
    create?: XOR<NotificationCreateWithoutUserNotificationsInput, NotificationUncheckedCreateWithoutUserNotificationsInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutUserNotificationsInput
    upsert?: NotificationUpsertWithoutUserNotificationsInput
    connect?: NotificationWhereUniqueInput
    update?: XOR<XOR<NotificationUpdateToOneWithWhereWithoutUserNotificationsInput, NotificationUpdateWithoutUserNotificationsInput>, NotificationUncheckedUpdateWithoutUserNotificationsInput>
  }

  export type EnumPaymentProviderFieldUpdateOperationsInput = {
    set?: $Enums.PaymentProvider
  }

  export type UserCreateNestedOneWithoutOrdersInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type EnumOrderTypeFieldUpdateOperationsInput = {
    set?: $Enums.OrderType
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus
  }

  export type NullableEnumPaymentProviderFieldUpdateOperationsInput = {
    set?: $Enums.PaymentProvider | null
  }

  export type UserUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    upsert?: UserUpsertWithoutOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrdersInput, UserUpdateWithoutOrdersInput>, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type UserCreateNestedManyWithoutMembershipInput = {
    create?: XOR<UserCreateWithoutMembershipInput, UserUncheckedCreateWithoutMembershipInput> | UserCreateWithoutMembershipInput[] | UserUncheckedCreateWithoutMembershipInput[]
    connectOrCreate?: UserCreateOrConnectWithoutMembershipInput | UserCreateOrConnectWithoutMembershipInput[]
    createMany?: UserCreateManyMembershipInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutMembershipInput = {
    create?: XOR<UserCreateWithoutMembershipInput, UserUncheckedCreateWithoutMembershipInput> | UserCreateWithoutMembershipInput[] | UserUncheckedCreateWithoutMembershipInput[]
    connectOrCreate?: UserCreateOrConnectWithoutMembershipInput | UserCreateOrConnectWithoutMembershipInput[]
    createMany?: UserCreateManyMembershipInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateManyWithoutMembershipNestedInput = {
    create?: XOR<UserCreateWithoutMembershipInput, UserUncheckedCreateWithoutMembershipInput> | UserCreateWithoutMembershipInput[] | UserUncheckedCreateWithoutMembershipInput[]
    connectOrCreate?: UserCreateOrConnectWithoutMembershipInput | UserCreateOrConnectWithoutMembershipInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutMembershipInput | UserUpsertWithWhereUniqueWithoutMembershipInput[]
    createMany?: UserCreateManyMembershipInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutMembershipInput | UserUpdateWithWhereUniqueWithoutMembershipInput[]
    updateMany?: UserUpdateManyWithWhereWithoutMembershipInput | UserUpdateManyWithWhereWithoutMembershipInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutMembershipNestedInput = {
    create?: XOR<UserCreateWithoutMembershipInput, UserUncheckedCreateWithoutMembershipInput> | UserCreateWithoutMembershipInput[] | UserUncheckedCreateWithoutMembershipInput[]
    connectOrCreate?: UserCreateOrConnectWithoutMembershipInput | UserCreateOrConnectWithoutMembershipInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutMembershipInput | UserUpsertWithWhereUniqueWithoutMembershipInput[]
    createMany?: UserCreateManyMembershipInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutMembershipInput | UserUpdateWithWhereUniqueWithoutMembershipInput[]
    updateMany?: UserUpdateManyWithWhereWithoutMembershipInput | UserUpdateManyWithWhereWithoutMembershipInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPointRecordsInput = {
    create?: XOR<UserCreateWithoutPointRecordsInput, UserUncheckedCreateWithoutPointRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPointRecordsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumPointTypeFieldUpdateOperationsInput = {
    set?: $Enums.PointType
  }

  export type UserUpdateOneRequiredWithoutPointRecordsNestedInput = {
    create?: XOR<UserCreateWithoutPointRecordsInput, UserUncheckedCreateWithoutPointRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPointRecordsInput
    upsert?: UserUpsertWithoutPointRecordsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPointRecordsInput, UserUpdateWithoutPointRecordsInput>, UserUncheckedUpdateWithoutPointRecordsInput>
  }

  export type UserRoleAssignmentCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleAssignmentCreateWithoutRoleInput, UserRoleAssignmentUncheckedCreateWithoutRoleInput> | UserRoleAssignmentCreateWithoutRoleInput[] | UserRoleAssignmentUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleAssignmentCreateOrConnectWithoutRoleInput | UserRoleAssignmentCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleAssignmentCreateManyRoleInputEnvelope
    connect?: UserRoleAssignmentWhereUniqueInput | UserRoleAssignmentWhereUniqueInput[]
  }

  export type UserRoleAssignmentUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleAssignmentCreateWithoutRoleInput, UserRoleAssignmentUncheckedCreateWithoutRoleInput> | UserRoleAssignmentCreateWithoutRoleInput[] | UserRoleAssignmentUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleAssignmentCreateOrConnectWithoutRoleInput | UserRoleAssignmentCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleAssignmentCreateManyRoleInputEnvelope
    connect?: UserRoleAssignmentWhereUniqueInput | UserRoleAssignmentWhereUniqueInput[]
  }

  export type UserRoleAssignmentUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleAssignmentCreateWithoutRoleInput, UserRoleAssignmentUncheckedCreateWithoutRoleInput> | UserRoleAssignmentCreateWithoutRoleInput[] | UserRoleAssignmentUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleAssignmentCreateOrConnectWithoutRoleInput | UserRoleAssignmentCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleAssignmentUpsertWithWhereUniqueWithoutRoleInput | UserRoleAssignmentUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleAssignmentCreateManyRoleInputEnvelope
    set?: UserRoleAssignmentWhereUniqueInput | UserRoleAssignmentWhereUniqueInput[]
    disconnect?: UserRoleAssignmentWhereUniqueInput | UserRoleAssignmentWhereUniqueInput[]
    delete?: UserRoleAssignmentWhereUniqueInput | UserRoleAssignmentWhereUniqueInput[]
    connect?: UserRoleAssignmentWhereUniqueInput | UserRoleAssignmentWhereUniqueInput[]
    update?: UserRoleAssignmentUpdateWithWhereUniqueWithoutRoleInput | UserRoleAssignmentUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleAssignmentUpdateManyWithWhereWithoutRoleInput | UserRoleAssignmentUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleAssignmentScalarWhereInput | UserRoleAssignmentScalarWhereInput[]
  }

  export type UserRoleAssignmentUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleAssignmentCreateWithoutRoleInput, UserRoleAssignmentUncheckedCreateWithoutRoleInput> | UserRoleAssignmentCreateWithoutRoleInput[] | UserRoleAssignmentUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleAssignmentCreateOrConnectWithoutRoleInput | UserRoleAssignmentCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleAssignmentUpsertWithWhereUniqueWithoutRoleInput | UserRoleAssignmentUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleAssignmentCreateManyRoleInputEnvelope
    set?: UserRoleAssignmentWhereUniqueInput | UserRoleAssignmentWhereUniqueInput[]
    disconnect?: UserRoleAssignmentWhereUniqueInput | UserRoleAssignmentWhereUniqueInput[]
    delete?: UserRoleAssignmentWhereUniqueInput | UserRoleAssignmentWhereUniqueInput[]
    connect?: UserRoleAssignmentWhereUniqueInput | UserRoleAssignmentWhereUniqueInput[]
    update?: UserRoleAssignmentUpdateWithWhereUniqueWithoutRoleInput | UserRoleAssignmentUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleAssignmentUpdateManyWithWhereWithoutRoleInput | UserRoleAssignmentUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleAssignmentScalarWhereInput | UserRoleAssignmentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRoleAssignmentsInput = {
    create?: XOR<UserCreateWithoutRoleAssignmentsInput, UserUncheckedCreateWithoutRoleAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRoleAssignmentsInput
    connect?: UserWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutUserAssignmentsInput = {
    create?: XOR<RoleCreateWithoutUserAssignmentsInput, RoleUncheckedCreateWithoutUserAssignmentsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserAssignmentsInput
    connect?: RoleWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRoleAssignmentsNestedInput = {
    create?: XOR<UserCreateWithoutRoleAssignmentsInput, UserUncheckedCreateWithoutRoleAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRoleAssignmentsInput
    upsert?: UserUpsertWithoutRoleAssignmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRoleAssignmentsInput, UserUpdateWithoutRoleAssignmentsInput>, UserUncheckedUpdateWithoutRoleAssignmentsInput>
  }

  export type RoleUpdateOneRequiredWithoutUserAssignmentsNestedInput = {
    create?: XOR<RoleCreateWithoutUserAssignmentsInput, RoleUncheckedCreateWithoutUserAssignmentsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserAssignmentsInput
    upsert?: RoleUpsertWithoutUserAssignmentsInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUserAssignmentsInput, RoleUpdateWithoutUserAssignmentsInput>, RoleUncheckedUpdateWithoutUserAssignmentsInput>
  }

  export type TranslationCreateNestedManyWithoutLanguageInput = {
    create?: XOR<TranslationCreateWithoutLanguageInput, TranslationUncheckedCreateWithoutLanguageInput> | TranslationCreateWithoutLanguageInput[] | TranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: TranslationCreateOrConnectWithoutLanguageInput | TranslationCreateOrConnectWithoutLanguageInput[]
    createMany?: TranslationCreateManyLanguageInputEnvelope
    connect?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
  }

  export type TranslationUncheckedCreateNestedManyWithoutLanguageInput = {
    create?: XOR<TranslationCreateWithoutLanguageInput, TranslationUncheckedCreateWithoutLanguageInput> | TranslationCreateWithoutLanguageInput[] | TranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: TranslationCreateOrConnectWithoutLanguageInput | TranslationCreateOrConnectWithoutLanguageInput[]
    createMany?: TranslationCreateManyLanguageInputEnvelope
    connect?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
  }

  export type TranslationUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<TranslationCreateWithoutLanguageInput, TranslationUncheckedCreateWithoutLanguageInput> | TranslationCreateWithoutLanguageInput[] | TranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: TranslationCreateOrConnectWithoutLanguageInput | TranslationCreateOrConnectWithoutLanguageInput[]
    upsert?: TranslationUpsertWithWhereUniqueWithoutLanguageInput | TranslationUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: TranslationCreateManyLanguageInputEnvelope
    set?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    disconnect?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    delete?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    connect?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    update?: TranslationUpdateWithWhereUniqueWithoutLanguageInput | TranslationUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: TranslationUpdateManyWithWhereWithoutLanguageInput | TranslationUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: TranslationScalarWhereInput | TranslationScalarWhereInput[]
  }

  export type TranslationUncheckedUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<TranslationCreateWithoutLanguageInput, TranslationUncheckedCreateWithoutLanguageInput> | TranslationCreateWithoutLanguageInput[] | TranslationUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: TranslationCreateOrConnectWithoutLanguageInput | TranslationCreateOrConnectWithoutLanguageInput[]
    upsert?: TranslationUpsertWithWhereUniqueWithoutLanguageInput | TranslationUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: TranslationCreateManyLanguageInputEnvelope
    set?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    disconnect?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    delete?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    connect?: TranslationWhereUniqueInput | TranslationWhereUniqueInput[]
    update?: TranslationUpdateWithWhereUniqueWithoutLanguageInput | TranslationUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: TranslationUpdateManyWithWhereWithoutLanguageInput | TranslationUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: TranslationScalarWhereInput | TranslationScalarWhereInput[]
  }

  export type LanguageCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<LanguageCreateWithoutTranslationsInput, LanguageUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutTranslationsInput
    connect?: LanguageWhereUniqueInput
  }

  export type LanguageUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<LanguageCreateWithoutTranslationsInput, LanguageUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutTranslationsInput
    upsert?: LanguageUpsertWithoutTranslationsInput
    connect?: LanguageWhereUniqueInput
    update?: XOR<XOR<LanguageUpdateToOneWithWhereWithoutTranslationsInput, LanguageUpdateWithoutTranslationsInput>, LanguageUncheckedUpdateWithoutTranslationsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumOAuthProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.OAuthProvider | EnumOAuthProviderFieldRefInput<$PrismaModel>
    in?: $Enums.OAuthProvider[]
    notIn?: $Enums.OAuthProvider[]
    not?: NestedEnumOAuthProviderFilter<$PrismaModel> | $Enums.OAuthProvider
  }

  export type NestedEnumOAuthProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OAuthProvider | EnumOAuthProviderFieldRefInput<$PrismaModel>
    in?: $Enums.OAuthProvider[]
    notIn?: $Enums.OAuthProvider[]
    not?: NestedEnumOAuthProviderWithAggregatesFilter<$PrismaModel> | $Enums.OAuthProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOAuthProviderFilter<$PrismaModel>
    _max?: NestedEnumOAuthProviderFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumDifficultyFilter<$PrismaModel = never> = {
    equals?: $Enums.Difficulty | EnumDifficultyFieldRefInput<$PrismaModel>
    in?: $Enums.Difficulty[]
    notIn?: $Enums.Difficulty[]
    not?: NestedEnumDifficultyFilter<$PrismaModel> | $Enums.Difficulty
  }

  export type NestedEnumDifficultyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Difficulty | EnumDifficultyFieldRefInput<$PrismaModel>
    in?: $Enums.Difficulty[]
    notIn?: $Enums.Difficulty[]
    not?: NestedEnumDifficultyWithAggregatesFilter<$PrismaModel> | $Enums.Difficulty
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDifficultyFilter<$PrismaModel>
    _max?: NestedEnumDifficultyFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[]
    notIn?: $Enums.SessionStatus[]
    not?: NestedEnumSessionStatusFilter<$PrismaModel> | $Enums.SessionStatus
  }

  export type NestedEnumSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[]
    notIn?: $Enums.SessionStatus[]
    not?: NestedEnumSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumSessionStatusFilter<$PrismaModel>
  }

  export type NestedEnumMessageRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageRole | EnumMessageRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MessageRole[]
    notIn?: $Enums.MessageRole[]
    not?: NestedEnumMessageRoleFilter<$PrismaModel> | $Enums.MessageRole
  }

  export type NestedEnumMessageRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageRole | EnumMessageRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MessageRole[]
    notIn?: $Enums.MessageRole[]
    not?: NestedEnumMessageRoleWithAggregatesFilter<$PrismaModel> | $Enums.MessageRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageRoleFilter<$PrismaModel>
    _max?: NestedEnumMessageRoleFilter<$PrismaModel>
  }

  export type NestedEnumStorageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StorageType | EnumStorageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StorageType[]
    notIn?: $Enums.StorageType[]
    not?: NestedEnumStorageTypeFilter<$PrismaModel> | $Enums.StorageType
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumStorageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StorageType | EnumStorageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StorageType[]
    notIn?: $Enums.StorageType[]
    not?: NestedEnumStorageTypeWithAggregatesFilter<$PrismaModel> | $Enums.StorageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStorageTypeFilter<$PrismaModel>
    _max?: NestedEnumStorageTypeFilter<$PrismaModel>
  }

  export type NestedEnumPluginCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.PluginCategory | EnumPluginCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PluginCategory[]
    notIn?: $Enums.PluginCategory[]
    not?: NestedEnumPluginCategoryFilter<$PrismaModel> | $Enums.PluginCategory
  }

  export type NestedEnumPluginCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PluginCategory | EnumPluginCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PluginCategory[]
    notIn?: $Enums.PluginCategory[]
    not?: NestedEnumPluginCategoryWithAggregatesFilter<$PrismaModel> | $Enums.PluginCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPluginCategoryFilter<$PrismaModel>
    _max?: NestedEnumPluginCategoryFilter<$PrismaModel>
  }

  export type NestedEnumArticleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ArticleStatus | EnumArticleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ArticleStatus[]
    notIn?: $Enums.ArticleStatus[]
    not?: NestedEnumArticleStatusFilter<$PrismaModel> | $Enums.ArticleStatus
  }

  export type NestedEnumArticleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ArticleStatus | EnumArticleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ArticleStatus[]
    notIn?: $Enums.ArticleStatus[]
    not?: NestedEnumArticleStatusWithAggregatesFilter<$PrismaModel> | $Enums.ArticleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumArticleStatusFilter<$PrismaModel>
    _max?: NestedEnumArticleStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[]
    notIn?: $Enums.NotificationType[]
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTargetFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationTarget | EnumNotificationTargetFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationTarget[]
    notIn?: $Enums.NotificationTarget[]
    not?: NestedEnumNotificationTargetFilter<$PrismaModel> | $Enums.NotificationTarget
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[]
    notIn?: $Enums.NotificationType[]
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTargetWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationTarget | EnumNotificationTargetFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationTarget[]
    notIn?: $Enums.NotificationTarget[]
    not?: NestedEnumNotificationTargetWithAggregatesFilter<$PrismaModel> | $Enums.NotificationTarget
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTargetFilter<$PrismaModel>
    _max?: NestedEnumNotificationTargetFilter<$PrismaModel>
  }

  export type NestedEnumPaymentProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentProvider | EnumPaymentProviderFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentProvider[]
    notIn?: $Enums.PaymentProvider[]
    not?: NestedEnumPaymentProviderFilter<$PrismaModel> | $Enums.PaymentProvider
  }

  export type NestedEnumPaymentProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentProvider | EnumPaymentProviderFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentProvider[]
    notIn?: $Enums.PaymentProvider[]
    not?: NestedEnumPaymentProviderWithAggregatesFilter<$PrismaModel> | $Enums.PaymentProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentProviderFilter<$PrismaModel>
    _max?: NestedEnumPaymentProviderFilter<$PrismaModel>
  }

  export type NestedEnumOrderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderType | EnumOrderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderType[]
    notIn?: $Enums.OrderType[]
    not?: NestedEnumOrderTypeFilter<$PrismaModel> | $Enums.OrderType
  }

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[]
    notIn?: $Enums.OrderStatus[]
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type NestedEnumPaymentProviderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentProvider | EnumPaymentProviderFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentProvider[] | null
    notIn?: $Enums.PaymentProvider[] | null
    not?: NestedEnumPaymentProviderNullableFilter<$PrismaModel> | $Enums.PaymentProvider | null
  }

  export type NestedEnumOrderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderType | EnumOrderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderType[]
    notIn?: $Enums.OrderType[]
    not?: NestedEnumOrderTypeWithAggregatesFilter<$PrismaModel> | $Enums.OrderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderTypeFilter<$PrismaModel>
    _max?: NestedEnumOrderTypeFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[]
    notIn?: $Enums.OrderStatus[]
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentProviderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentProvider | EnumPaymentProviderFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentProvider[] | null
    notIn?: $Enums.PaymentProvider[] | null
    not?: NestedEnumPaymentProviderNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentProvider | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentProviderNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentProviderNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumPointTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PointType | EnumPointTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PointType[]
    notIn?: $Enums.PointType[]
    not?: NestedEnumPointTypeFilter<$PrismaModel> | $Enums.PointType
  }

  export type NestedEnumPointTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PointType | EnumPointTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PointType[]
    notIn?: $Enums.PointType[]
    not?: NestedEnumPointTypeWithAggregatesFilter<$PrismaModel> | $Enums.PointType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPointTypeFilter<$PrismaModel>
    _max?: NestedEnumPointTypeFilter<$PrismaModel>
  }

  export type MembershipPlanCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price: number
    originalPrice?: number | null
    currency?: string
    duration: number
    features: JsonNullValueInput | InputJsonValue
    limits?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isFeatured?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipPlanUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    price: number
    originalPrice?: number | null
    currency?: string
    duration: number
    features: JsonNullValueInput | InputJsonValue
    limits?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isFeatured?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipPlanCreateOrConnectWithoutUsersInput = {
    where: MembershipPlanWhereUniqueInput
    create: XOR<MembershipPlanCreateWithoutUsersInput, MembershipPlanUncheckedCreateWithoutUsersInput>
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    status?: $Enums.SessionStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
    scenario: ScenarioCreateNestedOneWithoutSessionsInput
    messages?: MessageCreateNestedManyWithoutSessionInput
    feedback?: FeedbackCreateNestedOneWithoutSessionInput
    email?: FollowUpEmailCreateNestedOneWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    scenarioId: string
    status?: $Enums.SessionStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutSessionInput
    feedback?: FeedbackUncheckedCreateNestedOneWithoutSessionInput
    email?: FollowUpEmailUncheckedCreateNestedOneWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ScenarioCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description: string
    category: string
    difficulty?: $Enums.Difficulty
    estimatedDuration?: number
    isActive?: boolean
    practiceCount?: number
    averageScore?: number
    buyerPersona: JsonNullValueInput | InputJsonValue
    objections: JsonNullValueInput | InputJsonValue
    idealResponses: JsonNullValueInput | InputJsonValue
    maxTurns?: number
    scoringWeights?: NullableJsonNullValueInput | InputJsonValue
    openingPrompt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutScenarioInput
  }

  export type ScenarioUncheckedCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description: string
    category: string
    difficulty?: $Enums.Difficulty
    estimatedDuration?: number
    isActive?: boolean
    practiceCount?: number
    averageScore?: number
    buyerPersona: JsonNullValueInput | InputJsonValue
    objections: JsonNullValueInput | InputJsonValue
    idealResponses: JsonNullValueInput | InputJsonValue
    maxTurns?: number
    scoringWeights?: NullableJsonNullValueInput | InputJsonValue
    openingPrompt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutScenarioInput
  }

  export type ScenarioCreateOrConnectWithoutCreatedByInput = {
    where: ScenarioWhereUniqueInput
    create: XOR<ScenarioCreateWithoutCreatedByInput, ScenarioUncheckedCreateWithoutCreatedByInput>
  }

  export type ScenarioCreateManyCreatedByInputEnvelope = {
    data: ScenarioCreateManyCreatedByInput | ScenarioCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type FollowUpEmailCreateWithoutUserInput = {
    id?: string
    toAddress?: string | null
    subject: string
    body: string
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    session: SessionCreateNestedOneWithoutEmailInput
  }

  export type FollowUpEmailUncheckedCreateWithoutUserInput = {
    id?: string
    sessionId: string
    toAddress?: string | null
    subject: string
    body: string
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FollowUpEmailCreateOrConnectWithoutUserInput = {
    where: FollowUpEmailWhereUniqueInput
    create: XOR<FollowUpEmailCreateWithoutUserInput, FollowUpEmailUncheckedCreateWithoutUserInput>
  }

  export type FollowUpEmailCreateManyUserInputEnvelope = {
    data: FollowUpEmailCreateManyUserInput | FollowUpEmailCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BuyerPersonaTemplateCreateWithoutCreatedByInput = {
    id?: string
    name: string
    role: string
    company: string
    background: string
    concerns: JsonNullValueInput | InputJsonValue
    personality: string
    category: string
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuyerPersonaTemplateUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    role: string
    company: string
    background: string
    concerns: JsonNullValueInput | InputJsonValue
    personality: string
    category: string
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuyerPersonaTemplateCreateOrConnectWithoutCreatedByInput = {
    where: BuyerPersonaTemplateWhereUniqueInput
    create: XOR<BuyerPersonaTemplateCreateWithoutCreatedByInput, BuyerPersonaTemplateUncheckedCreateWithoutCreatedByInput>
  }

  export type BuyerPersonaTemplateCreateManyCreatedByInputEnvelope = {
    data: BuyerPersonaTemplateCreateManyCreatedByInput | BuyerPersonaTemplateCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type OperationLogCreateWithoutUserInput = {
    id?: string
    operationType: string
    targetType: string
    targetId?: string | null
    description: string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type OperationLogUncheckedCreateWithoutUserInput = {
    id?: string
    operationType: string
    targetType: string
    targetId?: string | null
    description: string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type OperationLogCreateOrConnectWithoutUserInput = {
    where: OperationLogWhereUniqueInput
    create: XOR<OperationLogCreateWithoutUserInput, OperationLogUncheckedCreateWithoutUserInput>
  }

  export type OperationLogCreateManyUserInputEnvelope = {
    data: OperationLogCreateManyUserInput | OperationLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OAuthAccountCreateWithoutUserInput = {
    id?: string
    provider: $Enums.OAuthProvider
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpireAt?: Date | string | null
    profile?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OAuthAccountUncheckedCreateWithoutUserInput = {
    id?: string
    provider: $Enums.OAuthProvider
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpireAt?: Date | string | null
    profile?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OAuthAccountCreateOrConnectWithoutUserInput = {
    where: OAuthAccountWhereUniqueInput
    create: XOR<OAuthAccountCreateWithoutUserInput, OAuthAccountUncheckedCreateWithoutUserInput>
  }

  export type OAuthAccountCreateManyUserInputEnvelope = {
    data: OAuthAccountCreateManyUserInput | OAuthAccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutUserInput = {
    id?: string
    orderNo: string
    orderType: $Enums.OrderType
    status?: $Enums.OrderStatus
    amount: number
    currency?: string
    paymentMethod?: $Enums.PaymentProvider | null
    transactionId?: string | null
    productId?: string | null
    productName: string
    productDesc?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    paidAt?: Date | string | null
    refundedAt?: Date | string | null
    expiredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUncheckedCreateWithoutUserInput = {
    id?: string
    orderNo: string
    orderType: $Enums.OrderType
    status?: $Enums.OrderStatus
    amount: number
    currency?: string
    paymentMethod?: $Enums.PaymentProvider | null
    transactionId?: string | null
    productId?: string | null
    productName: string
    productDesc?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    paidAt?: Date | string | null
    refundedAt?: Date | string | null
    expiredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateOrConnectWithoutUserInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderCreateManyUserInputEnvelope = {
    data: OrderCreateManyUserInput | OrderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PointRecordCreateWithoutUserInput = {
    id?: string
    points: number
    balance: number
    type: $Enums.PointType
    description: string
    relatedId?: string | null
    createdAt?: Date | string
  }

  export type PointRecordUncheckedCreateWithoutUserInput = {
    id?: string
    points: number
    balance: number
    type: $Enums.PointType
    description: string
    relatedId?: string | null
    createdAt?: Date | string
  }

  export type PointRecordCreateOrConnectWithoutUserInput = {
    where: PointRecordWhereUniqueInput
    create: XOR<PointRecordCreateWithoutUserInput, PointRecordUncheckedCreateWithoutUserInput>
  }

  export type PointRecordCreateManyUserInputEnvelope = {
    data: PointRecordCreateManyUserInput | PointRecordCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserNotificationCreateWithoutUserInput = {
    id?: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    notification: NotificationCreateNestedOneWithoutUserNotificationsInput
  }

  export type UserNotificationUncheckedCreateWithoutUserInput = {
    id?: string
    notificationId: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserNotificationCreateOrConnectWithoutUserInput = {
    where: UserNotificationWhereUniqueInput
    create: XOR<UserNotificationCreateWithoutUserInput, UserNotificationUncheckedCreateWithoutUserInput>
  }

  export type UserNotificationCreateManyUserInputEnvelope = {
    data: UserNotificationCreateManyUserInput | UserNotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ArticleCreateWithoutAuthorInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    coverImage?: string | null
    status?: $Enums.ArticleStatus
    viewCount?: number
    tags: JsonNullValueInput | InputJsonValue
    seoTitle?: string | null
    seoDescription?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: ArticleCategoryCreateNestedOneWithoutArticlesInput
  }

  export type ArticleUncheckedCreateWithoutAuthorInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    coverImage?: string | null
    categoryId?: string | null
    status?: $Enums.ArticleStatus
    viewCount?: number
    tags: JsonNullValueInput | InputJsonValue
    seoTitle?: string | null
    seoDescription?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ArticleCreateOrConnectWithoutAuthorInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutAuthorInput, ArticleUncheckedCreateWithoutAuthorInput>
  }

  export type ArticleCreateManyAuthorInputEnvelope = {
    data: ArticleCreateManyAuthorInput | ArticleCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type MediaCreateWithoutUploadedByInput = {
    id?: string
    name: string
    originalName: string
    path: string
    url: string
    mimeType: string
    size: number
    width?: number | null
    height?: number | null
    storageType?: $Enums.StorageType
    bucket?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaUncheckedCreateWithoutUploadedByInput = {
    id?: string
    name: string
    originalName: string
    path: string
    url: string
    mimeType: string
    size: number
    width?: number | null
    height?: number | null
    storageType?: $Enums.StorageType
    bucket?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaCreateOrConnectWithoutUploadedByInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutUploadedByInput, MediaUncheckedCreateWithoutUploadedByInput>
  }

  export type MediaCreateManyUploadedByInputEnvelope = {
    data: MediaCreateManyUploadedByInput | MediaCreateManyUploadedByInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleAssignmentCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutUserAssignmentsInput
  }

  export type UserRoleAssignmentUncheckedCreateWithoutUserInput = {
    id?: string
    roleId: string
    createdAt?: Date | string
  }

  export type UserRoleAssignmentCreateOrConnectWithoutUserInput = {
    where: UserRoleAssignmentWhereUniqueInput
    create: XOR<UserRoleAssignmentCreateWithoutUserInput, UserRoleAssignmentUncheckedCreateWithoutUserInput>
  }

  export type UserRoleAssignmentCreateManyUserInputEnvelope = {
    data: UserRoleAssignmentCreateManyUserInput | UserRoleAssignmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MembershipPlanUpsertWithoutUsersInput = {
    update: XOR<MembershipPlanUpdateWithoutUsersInput, MembershipPlanUncheckedUpdateWithoutUsersInput>
    create: XOR<MembershipPlanCreateWithoutUsersInput, MembershipPlanUncheckedCreateWithoutUsersInput>
    where?: MembershipPlanWhereInput
  }

  export type MembershipPlanUpdateToOneWithWhereWithoutUsersInput = {
    where?: MembershipPlanWhereInput
    data: XOR<MembershipPlanUpdateWithoutUsersInput, MembershipPlanUncheckedUpdateWithoutUsersInput>
  }

  export type MembershipPlanUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    originalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    limits?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipPlanUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    originalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    limits?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    scenarioId?: StringFilter<"Session"> | string
    status?: EnumSessionStatusFilter<"Session"> | $Enums.SessionStatus
    startedAt?: DateTimeFilter<"Session"> | Date | string
    completedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
  }

  export type ScenarioUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ScenarioWhereUniqueInput
    update: XOR<ScenarioUpdateWithoutCreatedByInput, ScenarioUncheckedUpdateWithoutCreatedByInput>
    create: XOR<ScenarioCreateWithoutCreatedByInput, ScenarioUncheckedCreateWithoutCreatedByInput>
  }

  export type ScenarioUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ScenarioWhereUniqueInput
    data: XOR<ScenarioUpdateWithoutCreatedByInput, ScenarioUncheckedUpdateWithoutCreatedByInput>
  }

  export type ScenarioUpdateManyWithWhereWithoutCreatedByInput = {
    where: ScenarioScalarWhereInput
    data: XOR<ScenarioUpdateManyMutationInput, ScenarioUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type ScenarioScalarWhereInput = {
    AND?: ScenarioScalarWhereInput | ScenarioScalarWhereInput[]
    OR?: ScenarioScalarWhereInput[]
    NOT?: ScenarioScalarWhereInput | ScenarioScalarWhereInput[]
    id?: StringFilter<"Scenario"> | string
    title?: StringFilter<"Scenario"> | string
    description?: StringFilter<"Scenario"> | string
    category?: StringFilter<"Scenario"> | string
    difficulty?: EnumDifficultyFilter<"Scenario"> | $Enums.Difficulty
    estimatedDuration?: IntFilter<"Scenario"> | number
    isActive?: BoolFilter<"Scenario"> | boolean
    practiceCount?: IntFilter<"Scenario"> | number
    averageScore?: FloatFilter<"Scenario"> | number
    buyerPersona?: JsonFilter<"Scenario">
    objections?: JsonFilter<"Scenario">
    idealResponses?: JsonFilter<"Scenario">
    maxTurns?: IntFilter<"Scenario"> | number
    scoringWeights?: JsonNullableFilter<"Scenario">
    openingPrompt?: StringNullableFilter<"Scenario"> | string | null
    createdById?: StringFilter<"Scenario"> | string
    createdAt?: DateTimeFilter<"Scenario"> | Date | string
    updatedAt?: DateTimeFilter<"Scenario"> | Date | string
  }

  export type FollowUpEmailUpsertWithWhereUniqueWithoutUserInput = {
    where: FollowUpEmailWhereUniqueInput
    update: XOR<FollowUpEmailUpdateWithoutUserInput, FollowUpEmailUncheckedUpdateWithoutUserInput>
    create: XOR<FollowUpEmailCreateWithoutUserInput, FollowUpEmailUncheckedCreateWithoutUserInput>
  }

  export type FollowUpEmailUpdateWithWhereUniqueWithoutUserInput = {
    where: FollowUpEmailWhereUniqueInput
    data: XOR<FollowUpEmailUpdateWithoutUserInput, FollowUpEmailUncheckedUpdateWithoutUserInput>
  }

  export type FollowUpEmailUpdateManyWithWhereWithoutUserInput = {
    where: FollowUpEmailScalarWhereInput
    data: XOR<FollowUpEmailUpdateManyMutationInput, FollowUpEmailUncheckedUpdateManyWithoutUserInput>
  }

  export type FollowUpEmailScalarWhereInput = {
    AND?: FollowUpEmailScalarWhereInput | FollowUpEmailScalarWhereInput[]
    OR?: FollowUpEmailScalarWhereInput[]
    NOT?: FollowUpEmailScalarWhereInput | FollowUpEmailScalarWhereInput[]
    id?: StringFilter<"FollowUpEmail"> | string
    sessionId?: StringFilter<"FollowUpEmail"> | string
    userId?: StringFilter<"FollowUpEmail"> | string
    toAddress?: StringNullableFilter<"FollowUpEmail"> | string | null
    subject?: StringFilter<"FollowUpEmail"> | string
    body?: StringFilter<"FollowUpEmail"> | string
    isEdited?: BoolFilter<"FollowUpEmail"> | boolean
    createdAt?: DateTimeFilter<"FollowUpEmail"> | Date | string
    updatedAt?: DateTimeFilter<"FollowUpEmail"> | Date | string
  }

  export type BuyerPersonaTemplateUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: BuyerPersonaTemplateWhereUniqueInput
    update: XOR<BuyerPersonaTemplateUpdateWithoutCreatedByInput, BuyerPersonaTemplateUncheckedUpdateWithoutCreatedByInput>
    create: XOR<BuyerPersonaTemplateCreateWithoutCreatedByInput, BuyerPersonaTemplateUncheckedCreateWithoutCreatedByInput>
  }

  export type BuyerPersonaTemplateUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: BuyerPersonaTemplateWhereUniqueInput
    data: XOR<BuyerPersonaTemplateUpdateWithoutCreatedByInput, BuyerPersonaTemplateUncheckedUpdateWithoutCreatedByInput>
  }

  export type BuyerPersonaTemplateUpdateManyWithWhereWithoutCreatedByInput = {
    where: BuyerPersonaTemplateScalarWhereInput
    data: XOR<BuyerPersonaTemplateUpdateManyMutationInput, BuyerPersonaTemplateUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type BuyerPersonaTemplateScalarWhereInput = {
    AND?: BuyerPersonaTemplateScalarWhereInput | BuyerPersonaTemplateScalarWhereInput[]
    OR?: BuyerPersonaTemplateScalarWhereInput[]
    NOT?: BuyerPersonaTemplateScalarWhereInput | BuyerPersonaTemplateScalarWhereInput[]
    id?: StringFilter<"BuyerPersonaTemplate"> | string
    name?: StringFilter<"BuyerPersonaTemplate"> | string
    role?: StringFilter<"BuyerPersonaTemplate"> | string
    company?: StringFilter<"BuyerPersonaTemplate"> | string
    background?: StringFilter<"BuyerPersonaTemplate"> | string
    concerns?: JsonFilter<"BuyerPersonaTemplate">
    personality?: StringFilter<"BuyerPersonaTemplate"> | string
    category?: StringFilter<"BuyerPersonaTemplate"> | string
    isDefault?: BoolFilter<"BuyerPersonaTemplate"> | boolean
    isActive?: BoolFilter<"BuyerPersonaTemplate"> | boolean
    createdById?: StringNullableFilter<"BuyerPersonaTemplate"> | string | null
    createdAt?: DateTimeFilter<"BuyerPersonaTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"BuyerPersonaTemplate"> | Date | string
  }

  export type OperationLogUpsertWithWhereUniqueWithoutUserInput = {
    where: OperationLogWhereUniqueInput
    update: XOR<OperationLogUpdateWithoutUserInput, OperationLogUncheckedUpdateWithoutUserInput>
    create: XOR<OperationLogCreateWithoutUserInput, OperationLogUncheckedCreateWithoutUserInput>
  }

  export type OperationLogUpdateWithWhereUniqueWithoutUserInput = {
    where: OperationLogWhereUniqueInput
    data: XOR<OperationLogUpdateWithoutUserInput, OperationLogUncheckedUpdateWithoutUserInput>
  }

  export type OperationLogUpdateManyWithWhereWithoutUserInput = {
    where: OperationLogScalarWhereInput
    data: XOR<OperationLogUpdateManyMutationInput, OperationLogUncheckedUpdateManyWithoutUserInput>
  }

  export type OperationLogScalarWhereInput = {
    AND?: OperationLogScalarWhereInput | OperationLogScalarWhereInput[]
    OR?: OperationLogScalarWhereInput[]
    NOT?: OperationLogScalarWhereInput | OperationLogScalarWhereInput[]
    id?: StringFilter<"OperationLog"> | string
    userId?: StringFilter<"OperationLog"> | string
    operationType?: StringFilter<"OperationLog"> | string
    targetType?: StringFilter<"OperationLog"> | string
    targetId?: StringNullableFilter<"OperationLog"> | string | null
    description?: StringFilter<"OperationLog"> | string
    details?: JsonNullableFilter<"OperationLog">
    ipAddress?: StringNullableFilter<"OperationLog"> | string | null
    userAgent?: StringNullableFilter<"OperationLog"> | string | null
    createdAt?: DateTimeFilter<"OperationLog"> | Date | string
  }

  export type OAuthAccountUpsertWithWhereUniqueWithoutUserInput = {
    where: OAuthAccountWhereUniqueInput
    update: XOR<OAuthAccountUpdateWithoutUserInput, OAuthAccountUncheckedUpdateWithoutUserInput>
    create: XOR<OAuthAccountCreateWithoutUserInput, OAuthAccountUncheckedCreateWithoutUserInput>
  }

  export type OAuthAccountUpdateWithWhereUniqueWithoutUserInput = {
    where: OAuthAccountWhereUniqueInput
    data: XOR<OAuthAccountUpdateWithoutUserInput, OAuthAccountUncheckedUpdateWithoutUserInput>
  }

  export type OAuthAccountUpdateManyWithWhereWithoutUserInput = {
    where: OAuthAccountScalarWhereInput
    data: XOR<OAuthAccountUpdateManyMutationInput, OAuthAccountUncheckedUpdateManyWithoutUserInput>
  }

  export type OAuthAccountScalarWhereInput = {
    AND?: OAuthAccountScalarWhereInput | OAuthAccountScalarWhereInput[]
    OR?: OAuthAccountScalarWhereInput[]
    NOT?: OAuthAccountScalarWhereInput | OAuthAccountScalarWhereInput[]
    id?: StringFilter<"OAuthAccount"> | string
    userId?: StringFilter<"OAuthAccount"> | string
    provider?: EnumOAuthProviderFilter<"OAuthAccount"> | $Enums.OAuthProvider
    providerId?: StringFilter<"OAuthAccount"> | string
    accessToken?: StringNullableFilter<"OAuthAccount"> | string | null
    refreshToken?: StringNullableFilter<"OAuthAccount"> | string | null
    tokenExpireAt?: DateTimeNullableFilter<"OAuthAccount"> | Date | string | null
    profile?: JsonNullableFilter<"OAuthAccount">
    createdAt?: DateTimeFilter<"OAuthAccount"> | Date | string
    updatedAt?: DateTimeFilter<"OAuthAccount"> | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
  }

  export type OrderUpdateManyWithWhereWithoutUserInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutUserInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    orderNo?: StringFilter<"Order"> | string
    userId?: StringFilter<"Order"> | string
    orderType?: EnumOrderTypeFilter<"Order"> | $Enums.OrderType
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    amount?: FloatFilter<"Order"> | number
    currency?: StringFilter<"Order"> | string
    paymentMethod?: EnumPaymentProviderNullableFilter<"Order"> | $Enums.PaymentProvider | null
    transactionId?: StringNullableFilter<"Order"> | string | null
    productId?: StringNullableFilter<"Order"> | string | null
    productName?: StringFilter<"Order"> | string
    productDesc?: StringNullableFilter<"Order"> | string | null
    metadata?: JsonNullableFilter<"Order">
    paidAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    refundedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    expiredAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
  }

  export type PointRecordUpsertWithWhereUniqueWithoutUserInput = {
    where: PointRecordWhereUniqueInput
    update: XOR<PointRecordUpdateWithoutUserInput, PointRecordUncheckedUpdateWithoutUserInput>
    create: XOR<PointRecordCreateWithoutUserInput, PointRecordUncheckedCreateWithoutUserInput>
  }

  export type PointRecordUpdateWithWhereUniqueWithoutUserInput = {
    where: PointRecordWhereUniqueInput
    data: XOR<PointRecordUpdateWithoutUserInput, PointRecordUncheckedUpdateWithoutUserInput>
  }

  export type PointRecordUpdateManyWithWhereWithoutUserInput = {
    where: PointRecordScalarWhereInput
    data: XOR<PointRecordUpdateManyMutationInput, PointRecordUncheckedUpdateManyWithoutUserInput>
  }

  export type PointRecordScalarWhereInput = {
    AND?: PointRecordScalarWhereInput | PointRecordScalarWhereInput[]
    OR?: PointRecordScalarWhereInput[]
    NOT?: PointRecordScalarWhereInput | PointRecordScalarWhereInput[]
    id?: StringFilter<"PointRecord"> | string
    userId?: StringFilter<"PointRecord"> | string
    points?: IntFilter<"PointRecord"> | number
    balance?: IntFilter<"PointRecord"> | number
    type?: EnumPointTypeFilter<"PointRecord"> | $Enums.PointType
    description?: StringFilter<"PointRecord"> | string
    relatedId?: StringNullableFilter<"PointRecord"> | string | null
    createdAt?: DateTimeFilter<"PointRecord"> | Date | string
  }

  export type UserNotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: UserNotificationWhereUniqueInput
    update: XOR<UserNotificationUpdateWithoutUserInput, UserNotificationUncheckedUpdateWithoutUserInput>
    create: XOR<UserNotificationCreateWithoutUserInput, UserNotificationUncheckedCreateWithoutUserInput>
  }

  export type UserNotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: UserNotificationWhereUniqueInput
    data: XOR<UserNotificationUpdateWithoutUserInput, UserNotificationUncheckedUpdateWithoutUserInput>
  }

  export type UserNotificationUpdateManyWithWhereWithoutUserInput = {
    where: UserNotificationScalarWhereInput
    data: XOR<UserNotificationUpdateManyMutationInput, UserNotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type UserNotificationScalarWhereInput = {
    AND?: UserNotificationScalarWhereInput | UserNotificationScalarWhereInput[]
    OR?: UserNotificationScalarWhereInput[]
    NOT?: UserNotificationScalarWhereInput | UserNotificationScalarWhereInput[]
    id?: StringFilter<"UserNotification"> | string
    userId?: StringFilter<"UserNotification"> | string
    notificationId?: StringFilter<"UserNotification"> | string
    isRead?: BoolFilter<"UserNotification"> | boolean
    readAt?: DateTimeNullableFilter<"UserNotification"> | Date | string | null
    createdAt?: DateTimeFilter<"UserNotification"> | Date | string
  }

  export type ArticleUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ArticleWhereUniqueInput
    update: XOR<ArticleUpdateWithoutAuthorInput, ArticleUncheckedUpdateWithoutAuthorInput>
    create: XOR<ArticleCreateWithoutAuthorInput, ArticleUncheckedCreateWithoutAuthorInput>
  }

  export type ArticleUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ArticleWhereUniqueInput
    data: XOR<ArticleUpdateWithoutAuthorInput, ArticleUncheckedUpdateWithoutAuthorInput>
  }

  export type ArticleUpdateManyWithWhereWithoutAuthorInput = {
    where: ArticleScalarWhereInput
    data: XOR<ArticleUpdateManyMutationInput, ArticleUncheckedUpdateManyWithoutAuthorInput>
  }

  export type ArticleScalarWhereInput = {
    AND?: ArticleScalarWhereInput | ArticleScalarWhereInput[]
    OR?: ArticleScalarWhereInput[]
    NOT?: ArticleScalarWhereInput | ArticleScalarWhereInput[]
    id?: StringFilter<"Article"> | string
    title?: StringFilter<"Article"> | string
    slug?: StringFilter<"Article"> | string
    content?: StringFilter<"Article"> | string
    excerpt?: StringNullableFilter<"Article"> | string | null
    coverImage?: StringNullableFilter<"Article"> | string | null
    categoryId?: StringNullableFilter<"Article"> | string | null
    authorId?: StringFilter<"Article"> | string
    status?: EnumArticleStatusFilter<"Article"> | $Enums.ArticleStatus
    viewCount?: IntFilter<"Article"> | number
    tags?: JsonFilter<"Article">
    seoTitle?: StringNullableFilter<"Article"> | string | null
    seoDescription?: StringNullableFilter<"Article"> | string | null
    publishedAt?: DateTimeNullableFilter<"Article"> | Date | string | null
    createdAt?: DateTimeFilter<"Article"> | Date | string
    updatedAt?: DateTimeFilter<"Article"> | Date | string
  }

  export type MediaUpsertWithWhereUniqueWithoutUploadedByInput = {
    where: MediaWhereUniqueInput
    update: XOR<MediaUpdateWithoutUploadedByInput, MediaUncheckedUpdateWithoutUploadedByInput>
    create: XOR<MediaCreateWithoutUploadedByInput, MediaUncheckedCreateWithoutUploadedByInput>
  }

  export type MediaUpdateWithWhereUniqueWithoutUploadedByInput = {
    where: MediaWhereUniqueInput
    data: XOR<MediaUpdateWithoutUploadedByInput, MediaUncheckedUpdateWithoutUploadedByInput>
  }

  export type MediaUpdateManyWithWhereWithoutUploadedByInput = {
    where: MediaScalarWhereInput
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyWithoutUploadedByInput>
  }

  export type MediaScalarWhereInput = {
    AND?: MediaScalarWhereInput | MediaScalarWhereInput[]
    OR?: MediaScalarWhereInput[]
    NOT?: MediaScalarWhereInput | MediaScalarWhereInput[]
    id?: StringFilter<"Media"> | string
    name?: StringFilter<"Media"> | string
    originalName?: StringFilter<"Media"> | string
    path?: StringFilter<"Media"> | string
    url?: StringFilter<"Media"> | string
    mimeType?: StringFilter<"Media"> | string
    size?: IntFilter<"Media"> | number
    width?: IntNullableFilter<"Media"> | number | null
    height?: IntNullableFilter<"Media"> | number | null
    storageType?: EnumStorageTypeFilter<"Media"> | $Enums.StorageType
    bucket?: StringNullableFilter<"Media"> | string | null
    uploadedById?: StringFilter<"Media"> | string
    createdAt?: DateTimeFilter<"Media"> | Date | string
    updatedAt?: DateTimeFilter<"Media"> | Date | string
  }

  export type UserRoleAssignmentUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRoleAssignmentWhereUniqueInput
    update: XOR<UserRoleAssignmentUpdateWithoutUserInput, UserRoleAssignmentUncheckedUpdateWithoutUserInput>
    create: XOR<UserRoleAssignmentCreateWithoutUserInput, UserRoleAssignmentUncheckedCreateWithoutUserInput>
  }

  export type UserRoleAssignmentUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRoleAssignmentWhereUniqueInput
    data: XOR<UserRoleAssignmentUpdateWithoutUserInput, UserRoleAssignmentUncheckedUpdateWithoutUserInput>
  }

  export type UserRoleAssignmentUpdateManyWithWhereWithoutUserInput = {
    where: UserRoleAssignmentScalarWhereInput
    data: XOR<UserRoleAssignmentUpdateManyMutationInput, UserRoleAssignmentUncheckedUpdateManyWithoutUserInput>
  }

  export type UserRoleAssignmentScalarWhereInput = {
    AND?: UserRoleAssignmentScalarWhereInput | UserRoleAssignmentScalarWhereInput[]
    OR?: UserRoleAssignmentScalarWhereInput[]
    NOT?: UserRoleAssignmentScalarWhereInput | UserRoleAssignmentScalarWhereInput[]
    id?: StringFilter<"UserRoleAssignment"> | string
    userId?: StringFilter<"UserRoleAssignment"> | string
    roleId?: StringFilter<"UserRoleAssignment"> | string
    createdAt?: DateTimeFilter<"UserRoleAssignment"> | Date | string
  }

  export type UserCreateWithoutOauthAccountsInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    avatar?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    department?: string | null
    isActive?: boolean
    language?: string
    membershipExpireAt?: Date | string | null
    points?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    membership?: MembershipPlanCreateNestedOneWithoutUsersInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    scenarios?: ScenarioCreateNestedManyWithoutCreatedByInput
    emails?: FollowUpEmailCreateNestedManyWithoutUserInput
    personaTemplates?: BuyerPersonaTemplateCreateNestedManyWithoutCreatedByInput
    operationLogs?: OperationLogCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    pointRecords?: PointRecordCreateNestedManyWithoutUserInput
    notifications?: UserNotificationCreateNestedManyWithoutUserInput
    articles?: ArticleCreateNestedManyWithoutAuthorInput
    media?: MediaCreateNestedManyWithoutUploadedByInput
    roleAssignments?: UserRoleAssignmentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOauthAccountsInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    avatar?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    department?: string | null
    isActive?: boolean
    language?: string
    membershipId?: string | null
    membershipExpireAt?: Date | string | null
    points?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutCreatedByInput
    emails?: FollowUpEmailUncheckedCreateNestedManyWithoutUserInput
    personaTemplates?: BuyerPersonaTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    operationLogs?: OperationLogUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    pointRecords?: PointRecordUncheckedCreateNestedManyWithoutUserInput
    notifications?: UserNotificationUncheckedCreateNestedManyWithoutUserInput
    articles?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    media?: MediaUncheckedCreateNestedManyWithoutUploadedByInput
    roleAssignments?: UserRoleAssignmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOauthAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOauthAccountsInput, UserUncheckedCreateWithoutOauthAccountsInput>
  }

  export type UserUpsertWithoutOauthAccountsInput = {
    update: XOR<UserUpdateWithoutOauthAccountsInput, UserUncheckedUpdateWithoutOauthAccountsInput>
    create: XOR<UserCreateWithoutOauthAccountsInput, UserUncheckedCreateWithoutOauthAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOauthAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOauthAccountsInput, UserUncheckedUpdateWithoutOauthAccountsInput>
  }

  export type UserUpdateWithoutOauthAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    membershipExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    membership?: MembershipPlanUpdateOneWithoutUsersNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUpdateManyWithoutCreatedByNestedInput
    emails?: FollowUpEmailUpdateManyWithoutUserNestedInput
    personaTemplates?: BuyerPersonaTemplateUpdateManyWithoutCreatedByNestedInput
    operationLogs?: OperationLogUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    pointRecords?: PointRecordUpdateManyWithoutUserNestedInput
    notifications?: UserNotificationUpdateManyWithoutUserNestedInput
    articles?: ArticleUpdateManyWithoutAuthorNestedInput
    media?: MediaUpdateManyWithoutUploadedByNestedInput
    roleAssignments?: UserRoleAssignmentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOauthAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    membershipId?: NullableStringFieldUpdateOperationsInput | string | null
    membershipExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutCreatedByNestedInput
    emails?: FollowUpEmailUncheckedUpdateManyWithoutUserNestedInput
    personaTemplates?: BuyerPersonaTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    operationLogs?: OperationLogUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    pointRecords?: PointRecordUncheckedUpdateManyWithoutUserNestedInput
    notifications?: UserNotificationUncheckedUpdateManyWithoutUserNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    media?: MediaUncheckedUpdateManyWithoutUploadedByNestedInput
    roleAssignments?: UserRoleAssignmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutScenariosInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    avatar?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    department?: string | null
    isActive?: boolean
    language?: string
    membershipExpireAt?: Date | string | null
    points?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    membership?: MembershipPlanCreateNestedOneWithoutUsersInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    emails?: FollowUpEmailCreateNestedManyWithoutUserInput
    personaTemplates?: BuyerPersonaTemplateCreateNestedManyWithoutCreatedByInput
    operationLogs?: OperationLogCreateNestedManyWithoutUserInput
    oauthAccounts?: OAuthAccountCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    pointRecords?: PointRecordCreateNestedManyWithoutUserInput
    notifications?: UserNotificationCreateNestedManyWithoutUserInput
    articles?: ArticleCreateNestedManyWithoutAuthorInput
    media?: MediaCreateNestedManyWithoutUploadedByInput
    roleAssignments?: UserRoleAssignmentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutScenariosInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    avatar?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    department?: string | null
    isActive?: boolean
    language?: string
    membershipId?: string | null
    membershipExpireAt?: Date | string | null
    points?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    emails?: FollowUpEmailUncheckedCreateNestedManyWithoutUserInput
    personaTemplates?: BuyerPersonaTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    operationLogs?: OperationLogUncheckedCreateNestedManyWithoutUserInput
    oauthAccounts?: OAuthAccountUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    pointRecords?: PointRecordUncheckedCreateNestedManyWithoutUserInput
    notifications?: UserNotificationUncheckedCreateNestedManyWithoutUserInput
    articles?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    media?: MediaUncheckedCreateNestedManyWithoutUploadedByInput
    roleAssignments?: UserRoleAssignmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutScenariosInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutScenariosInput, UserUncheckedCreateWithoutScenariosInput>
  }

  export type SessionCreateWithoutScenarioInput = {
    id?: string
    status?: $Enums.SessionStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutSessionsInput
    messages?: MessageCreateNestedManyWithoutSessionInput
    feedback?: FeedbackCreateNestedOneWithoutSessionInput
    email?: FollowUpEmailCreateNestedOneWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutScenarioInput = {
    id?: string
    userId: string
    status?: $Enums.SessionStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutSessionInput
    feedback?: FeedbackUncheckedCreateNestedOneWithoutSessionInput
    email?: FollowUpEmailUncheckedCreateNestedOneWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutScenarioInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutScenarioInput, SessionUncheckedCreateWithoutScenarioInput>
  }

  export type SessionCreateManyScenarioInputEnvelope = {
    data: SessionCreateManyScenarioInput | SessionCreateManyScenarioInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutScenariosInput = {
    update: XOR<UserUpdateWithoutScenariosInput, UserUncheckedUpdateWithoutScenariosInput>
    create: XOR<UserCreateWithoutScenariosInput, UserUncheckedCreateWithoutScenariosInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutScenariosInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutScenariosInput, UserUncheckedUpdateWithoutScenariosInput>
  }

  export type UserUpdateWithoutScenariosInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    membershipExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    membership?: MembershipPlanUpdateOneWithoutUsersNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    emails?: FollowUpEmailUpdateManyWithoutUserNestedInput
    personaTemplates?: BuyerPersonaTemplateUpdateManyWithoutCreatedByNestedInput
    operationLogs?: OperationLogUpdateManyWithoutUserNestedInput
    oauthAccounts?: OAuthAccountUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    pointRecords?: PointRecordUpdateManyWithoutUserNestedInput
    notifications?: UserNotificationUpdateManyWithoutUserNestedInput
    articles?: ArticleUpdateManyWithoutAuthorNestedInput
    media?: MediaUpdateManyWithoutUploadedByNestedInput
    roleAssignments?: UserRoleAssignmentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutScenariosInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    membershipId?: NullableStringFieldUpdateOperationsInput | string | null
    membershipExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    emails?: FollowUpEmailUncheckedUpdateManyWithoutUserNestedInput
    personaTemplates?: BuyerPersonaTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    operationLogs?: OperationLogUncheckedUpdateManyWithoutUserNestedInput
    oauthAccounts?: OAuthAccountUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    pointRecords?: PointRecordUncheckedUpdateManyWithoutUserNestedInput
    notifications?: UserNotificationUncheckedUpdateManyWithoutUserNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    media?: MediaUncheckedUpdateManyWithoutUploadedByNestedInput
    roleAssignments?: UserRoleAssignmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SessionUpsertWithWhereUniqueWithoutScenarioInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutScenarioInput, SessionUncheckedUpdateWithoutScenarioInput>
    create: XOR<SessionCreateWithoutScenarioInput, SessionUncheckedCreateWithoutScenarioInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutScenarioInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutScenarioInput, SessionUncheckedUpdateWithoutScenarioInput>
  }

  export type SessionUpdateManyWithWhereWithoutScenarioInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutScenarioInput>
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    avatar?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    department?: string | null
    isActive?: boolean
    language?: string
    membershipExpireAt?: Date | string | null
    points?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    membership?: MembershipPlanCreateNestedOneWithoutUsersInput
    scenarios?: ScenarioCreateNestedManyWithoutCreatedByInput
    emails?: FollowUpEmailCreateNestedManyWithoutUserInput
    personaTemplates?: BuyerPersonaTemplateCreateNestedManyWithoutCreatedByInput
    operationLogs?: OperationLogCreateNestedManyWithoutUserInput
    oauthAccounts?: OAuthAccountCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    pointRecords?: PointRecordCreateNestedManyWithoutUserInput
    notifications?: UserNotificationCreateNestedManyWithoutUserInput
    articles?: ArticleCreateNestedManyWithoutAuthorInput
    media?: MediaCreateNestedManyWithoutUploadedByInput
    roleAssignments?: UserRoleAssignmentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    avatar?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    department?: string | null
    isActive?: boolean
    language?: string
    membershipId?: string | null
    membershipExpireAt?: Date | string | null
    points?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutCreatedByInput
    emails?: FollowUpEmailUncheckedCreateNestedManyWithoutUserInput
    personaTemplates?: BuyerPersonaTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    operationLogs?: OperationLogUncheckedCreateNestedManyWithoutUserInput
    oauthAccounts?: OAuthAccountUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    pointRecords?: PointRecordUncheckedCreateNestedManyWithoutUserInput
    notifications?: UserNotificationUncheckedCreateNestedManyWithoutUserInput
    articles?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    media?: MediaUncheckedCreateNestedManyWithoutUploadedByInput
    roleAssignments?: UserRoleAssignmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type ScenarioCreateWithoutSessionsInput = {
    id?: string
    title: string
    description: string
    category: string
    difficulty?: $Enums.Difficulty
    estimatedDuration?: number
    isActive?: boolean
    practiceCount?: number
    averageScore?: number
    buyerPersona: JsonNullValueInput | InputJsonValue
    objections: JsonNullValueInput | InputJsonValue
    idealResponses: JsonNullValueInput | InputJsonValue
    maxTurns?: number
    scoringWeights?: NullableJsonNullValueInput | InputJsonValue
    openingPrompt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutScenariosInput
  }

  export type ScenarioUncheckedCreateWithoutSessionsInput = {
    id?: string
    title: string
    description: string
    category: string
    difficulty?: $Enums.Difficulty
    estimatedDuration?: number
    isActive?: boolean
    practiceCount?: number
    averageScore?: number
    buyerPersona: JsonNullValueInput | InputJsonValue
    objections: JsonNullValueInput | InputJsonValue
    idealResponses: JsonNullValueInput | InputJsonValue
    maxTurns?: number
    scoringWeights?: NullableJsonNullValueInput | InputJsonValue
    openingPrompt?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScenarioCreateOrConnectWithoutSessionsInput = {
    where: ScenarioWhereUniqueInput
    create: XOR<ScenarioCreateWithoutSessionsInput, ScenarioUncheckedCreateWithoutSessionsInput>
  }

  export type MessageCreateWithoutSessionInput = {
    id?: string
    role: $Enums.MessageRole
    content: string
    timestamp?: Date | string
  }

  export type MessageUncheckedCreateWithoutSessionInput = {
    id?: string
    role: $Enums.MessageRole
    content: string
    timestamp?: Date | string
  }

  export type MessageCreateOrConnectWithoutSessionInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSessionInput, MessageUncheckedCreateWithoutSessionInput>
  }

  export type MessageCreateManySessionInputEnvelope = {
    data: MessageCreateManySessionInput | MessageCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type FeedbackCreateWithoutSessionInput = {
    id?: string
    overallScore: number
    dimensions: JsonNullValueInput | InputJsonValue
    summary: string
    recommendations: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type FeedbackUncheckedCreateWithoutSessionInput = {
    id?: string
    overallScore: number
    dimensions: JsonNullValueInput | InputJsonValue
    summary: string
    recommendations: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type FeedbackCreateOrConnectWithoutSessionInput = {
    where: FeedbackWhereUniqueInput
    create: XOR<FeedbackCreateWithoutSessionInput, FeedbackUncheckedCreateWithoutSessionInput>
  }

  export type FollowUpEmailCreateWithoutSessionInput = {
    id?: string
    toAddress?: string | null
    subject: string
    body: string
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEmailsInput
  }

  export type FollowUpEmailUncheckedCreateWithoutSessionInput = {
    id?: string
    userId: string
    toAddress?: string | null
    subject: string
    body: string
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FollowUpEmailCreateOrConnectWithoutSessionInput = {
    where: FollowUpEmailWhereUniqueInput
    create: XOR<FollowUpEmailCreateWithoutSessionInput, FollowUpEmailUncheckedCreateWithoutSessionInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    membershipExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    membership?: MembershipPlanUpdateOneWithoutUsersNestedInput
    scenarios?: ScenarioUpdateManyWithoutCreatedByNestedInput
    emails?: FollowUpEmailUpdateManyWithoutUserNestedInput
    personaTemplates?: BuyerPersonaTemplateUpdateManyWithoutCreatedByNestedInput
    operationLogs?: OperationLogUpdateManyWithoutUserNestedInput
    oauthAccounts?: OAuthAccountUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    pointRecords?: PointRecordUpdateManyWithoutUserNestedInput
    notifications?: UserNotificationUpdateManyWithoutUserNestedInput
    articles?: ArticleUpdateManyWithoutAuthorNestedInput
    media?: MediaUpdateManyWithoutUploadedByNestedInput
    roleAssignments?: UserRoleAssignmentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    membershipId?: NullableStringFieldUpdateOperationsInput | string | null
    membershipExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scenarios?: ScenarioUncheckedUpdateManyWithoutCreatedByNestedInput
    emails?: FollowUpEmailUncheckedUpdateManyWithoutUserNestedInput
    personaTemplates?: BuyerPersonaTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    operationLogs?: OperationLogUncheckedUpdateManyWithoutUserNestedInput
    oauthAccounts?: OAuthAccountUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    pointRecords?: PointRecordUncheckedUpdateManyWithoutUserNestedInput
    notifications?: UserNotificationUncheckedUpdateManyWithoutUserNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    media?: MediaUncheckedUpdateManyWithoutUploadedByNestedInput
    roleAssignments?: UserRoleAssignmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ScenarioUpsertWithoutSessionsInput = {
    update: XOR<ScenarioUpdateWithoutSessionsInput, ScenarioUncheckedUpdateWithoutSessionsInput>
    create: XOR<ScenarioCreateWithoutSessionsInput, ScenarioUncheckedCreateWithoutSessionsInput>
    where?: ScenarioWhereInput
  }

  export type ScenarioUpdateToOneWithWhereWithoutSessionsInput = {
    where?: ScenarioWhereInput
    data: XOR<ScenarioUpdateWithoutSessionsInput, ScenarioUncheckedUpdateWithoutSessionsInput>
  }

  export type ScenarioUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    practiceCount?: IntFieldUpdateOperationsInput | number
    averageScore?: FloatFieldUpdateOperationsInput | number
    buyerPersona?: JsonNullValueInput | InputJsonValue
    objections?: JsonNullValueInput | InputJsonValue
    idealResponses?: JsonNullValueInput | InputJsonValue
    maxTurns?: IntFieldUpdateOperationsInput | number
    scoringWeights?: NullableJsonNullValueInput | InputJsonValue
    openingPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutScenariosNestedInput
  }

  export type ScenarioUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    practiceCount?: IntFieldUpdateOperationsInput | number
    averageScore?: FloatFieldUpdateOperationsInput | number
    buyerPersona?: JsonNullValueInput | InputJsonValue
    objections?: JsonNullValueInput | InputJsonValue
    idealResponses?: JsonNullValueInput | InputJsonValue
    maxTurns?: IntFieldUpdateOperationsInput | number
    scoringWeights?: NullableJsonNullValueInput | InputJsonValue
    openingPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutSessionInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSessionInput, MessageUncheckedUpdateWithoutSessionInput>
    create: XOR<MessageCreateWithoutSessionInput, MessageUncheckedCreateWithoutSessionInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSessionInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSessionInput, MessageUncheckedUpdateWithoutSessionInput>
  }

  export type MessageUpdateManyWithWhereWithoutSessionInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSessionInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    sessionId?: StringFilter<"Message"> | string
    role?: EnumMessageRoleFilter<"Message"> | $Enums.MessageRole
    content?: StringFilter<"Message"> | string
    timestamp?: DateTimeFilter<"Message"> | Date | string
  }

  export type FeedbackUpsertWithoutSessionInput = {
    update: XOR<FeedbackUpdateWithoutSessionInput, FeedbackUncheckedUpdateWithoutSessionInput>
    create: XOR<FeedbackCreateWithoutSessionInput, FeedbackUncheckedCreateWithoutSessionInput>
    where?: FeedbackWhereInput
  }

  export type FeedbackUpdateToOneWithWhereWithoutSessionInput = {
    where?: FeedbackWhereInput
    data: XOR<FeedbackUpdateWithoutSessionInput, FeedbackUncheckedUpdateWithoutSessionInput>
  }

  export type FeedbackUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    dimensions?: JsonNullValueInput | InputJsonValue
    summary?: StringFieldUpdateOperationsInput | string
    recommendations?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    dimensions?: JsonNullValueInput | InputJsonValue
    summary?: StringFieldUpdateOperationsInput | string
    recommendations?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUpEmailUpsertWithoutSessionInput = {
    update: XOR<FollowUpEmailUpdateWithoutSessionInput, FollowUpEmailUncheckedUpdateWithoutSessionInput>
    create: XOR<FollowUpEmailCreateWithoutSessionInput, FollowUpEmailUncheckedCreateWithoutSessionInput>
    where?: FollowUpEmailWhereInput
  }

  export type FollowUpEmailUpdateToOneWithWhereWithoutSessionInput = {
    where?: FollowUpEmailWhereInput
    data: XOR<FollowUpEmailUpdateWithoutSessionInput, FollowUpEmailUncheckedUpdateWithoutSessionInput>
  }

  export type FollowUpEmailUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    toAddress?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmailsNestedInput
  }

  export type FollowUpEmailUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    toAddress?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateWithoutMessagesInput = {
    id?: string
    status?: $Enums.SessionStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutSessionsInput
    scenario: ScenarioCreateNestedOneWithoutSessionsInput
    feedback?: FeedbackCreateNestedOneWithoutSessionInput
    email?: FollowUpEmailCreateNestedOneWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutMessagesInput = {
    id?: string
    userId: string
    scenarioId: string
    status?: $Enums.SessionStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
    feedback?: FeedbackUncheckedCreateNestedOneWithoutSessionInput
    email?: FollowUpEmailUncheckedCreateNestedOneWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutMessagesInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutMessagesInput, SessionUncheckedCreateWithoutMessagesInput>
  }

  export type SessionUpsertWithoutMessagesInput = {
    update: XOR<SessionUpdateWithoutMessagesInput, SessionUncheckedUpdateWithoutMessagesInput>
    create: XOR<SessionCreateWithoutMessagesInput, SessionUncheckedCreateWithoutMessagesInput>
    where?: SessionWhereInput
  }

  export type SessionUpdateToOneWithWhereWithoutMessagesInput = {
    where?: SessionWhereInput
    data: XOR<SessionUpdateWithoutMessagesInput, SessionUncheckedUpdateWithoutMessagesInput>
  }

  export type SessionUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
    scenario?: ScenarioUpdateOneRequiredWithoutSessionsNestedInput
    feedback?: FeedbackUpdateOneWithoutSessionNestedInput
    email?: FollowUpEmailUpdateOneWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    scenarioId?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feedback?: FeedbackUncheckedUpdateOneWithoutSessionNestedInput
    email?: FollowUpEmailUncheckedUpdateOneWithoutSessionNestedInput
  }

  export type SessionCreateWithoutFeedbackInput = {
    id?: string
    status?: $Enums.SessionStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutSessionsInput
    scenario: ScenarioCreateNestedOneWithoutSessionsInput
    messages?: MessageCreateNestedManyWithoutSessionInput
    email?: FollowUpEmailCreateNestedOneWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutFeedbackInput = {
    id?: string
    userId: string
    scenarioId: string
    status?: $Enums.SessionStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutSessionInput
    email?: FollowUpEmailUncheckedCreateNestedOneWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutFeedbackInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutFeedbackInput, SessionUncheckedCreateWithoutFeedbackInput>
  }

  export type SessionUpsertWithoutFeedbackInput = {
    update: XOR<SessionUpdateWithoutFeedbackInput, SessionUncheckedUpdateWithoutFeedbackInput>
    create: XOR<SessionCreateWithoutFeedbackInput, SessionUncheckedCreateWithoutFeedbackInput>
    where?: SessionWhereInput
  }

  export type SessionUpdateToOneWithWhereWithoutFeedbackInput = {
    where?: SessionWhereInput
    data: XOR<SessionUpdateWithoutFeedbackInput, SessionUncheckedUpdateWithoutFeedbackInput>
  }

  export type SessionUpdateWithoutFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
    scenario?: ScenarioUpdateOneRequiredWithoutSessionsNestedInput
    messages?: MessageUpdateManyWithoutSessionNestedInput
    email?: FollowUpEmailUpdateOneWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    scenarioId?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutSessionNestedInput
    email?: FollowUpEmailUncheckedUpdateOneWithoutSessionNestedInput
  }

  export type SessionCreateWithoutEmailInput = {
    id?: string
    status?: $Enums.SessionStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutSessionsInput
    scenario: ScenarioCreateNestedOneWithoutSessionsInput
    messages?: MessageCreateNestedManyWithoutSessionInput
    feedback?: FeedbackCreateNestedOneWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutEmailInput = {
    id?: string
    userId: string
    scenarioId: string
    status?: $Enums.SessionStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutSessionInput
    feedback?: FeedbackUncheckedCreateNestedOneWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutEmailInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutEmailInput, SessionUncheckedCreateWithoutEmailInput>
  }

  export type UserCreateWithoutEmailsInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    avatar?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    department?: string | null
    isActive?: boolean
    language?: string
    membershipExpireAt?: Date | string | null
    points?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    membership?: MembershipPlanCreateNestedOneWithoutUsersInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    scenarios?: ScenarioCreateNestedManyWithoutCreatedByInput
    personaTemplates?: BuyerPersonaTemplateCreateNestedManyWithoutCreatedByInput
    operationLogs?: OperationLogCreateNestedManyWithoutUserInput
    oauthAccounts?: OAuthAccountCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    pointRecords?: PointRecordCreateNestedManyWithoutUserInput
    notifications?: UserNotificationCreateNestedManyWithoutUserInput
    articles?: ArticleCreateNestedManyWithoutAuthorInput
    media?: MediaCreateNestedManyWithoutUploadedByInput
    roleAssignments?: UserRoleAssignmentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEmailsInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    avatar?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    department?: string | null
    isActive?: boolean
    language?: string
    membershipId?: string | null
    membershipExpireAt?: Date | string | null
    points?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutCreatedByInput
    personaTemplates?: BuyerPersonaTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    operationLogs?: OperationLogUncheckedCreateNestedManyWithoutUserInput
    oauthAccounts?: OAuthAccountUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    pointRecords?: PointRecordUncheckedCreateNestedManyWithoutUserInput
    notifications?: UserNotificationUncheckedCreateNestedManyWithoutUserInput
    articles?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    media?: MediaUncheckedCreateNestedManyWithoutUploadedByInput
    roleAssignments?: UserRoleAssignmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEmailsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmailsInput, UserUncheckedCreateWithoutEmailsInput>
  }

  export type SessionUpsertWithoutEmailInput = {
    update: XOR<SessionUpdateWithoutEmailInput, SessionUncheckedUpdateWithoutEmailInput>
    create: XOR<SessionCreateWithoutEmailInput, SessionUncheckedCreateWithoutEmailInput>
    where?: SessionWhereInput
  }

  export type SessionUpdateToOneWithWhereWithoutEmailInput = {
    where?: SessionWhereInput
    data: XOR<SessionUpdateWithoutEmailInput, SessionUncheckedUpdateWithoutEmailInput>
  }

  export type SessionUpdateWithoutEmailInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
    scenario?: ScenarioUpdateOneRequiredWithoutSessionsNestedInput
    messages?: MessageUpdateManyWithoutSessionNestedInput
    feedback?: FeedbackUpdateOneWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutEmailInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    scenarioId?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutSessionNestedInput
    feedback?: FeedbackUncheckedUpdateOneWithoutSessionNestedInput
  }

  export type UserUpsertWithoutEmailsInput = {
    update: XOR<UserUpdateWithoutEmailsInput, UserUncheckedUpdateWithoutEmailsInput>
    create: XOR<UserCreateWithoutEmailsInput, UserUncheckedCreateWithoutEmailsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmailsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmailsInput, UserUncheckedUpdateWithoutEmailsInput>
  }

  export type UserUpdateWithoutEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    membershipExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    membership?: MembershipPlanUpdateOneWithoutUsersNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: BuyerPersonaTemplateUpdateManyWithoutCreatedByNestedInput
    operationLogs?: OperationLogUpdateManyWithoutUserNestedInput
    oauthAccounts?: OAuthAccountUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    pointRecords?: PointRecordUpdateManyWithoutUserNestedInput
    notifications?: UserNotificationUpdateManyWithoutUserNestedInput
    articles?: ArticleUpdateManyWithoutAuthorNestedInput
    media?: MediaUpdateManyWithoutUploadedByNestedInput
    roleAssignments?: UserRoleAssignmentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    membershipId?: NullableStringFieldUpdateOperationsInput | string | null
    membershipExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: BuyerPersonaTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    operationLogs?: OperationLogUncheckedUpdateManyWithoutUserNestedInput
    oauthAccounts?: OAuthAccountUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    pointRecords?: PointRecordUncheckedUpdateManyWithoutUserNestedInput
    notifications?: UserNotificationUncheckedUpdateManyWithoutUserNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    media?: MediaUncheckedUpdateManyWithoutUploadedByNestedInput
    roleAssignments?: UserRoleAssignmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPersonaTemplatesInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    avatar?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    department?: string | null
    isActive?: boolean
    language?: string
    membershipExpireAt?: Date | string | null
    points?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    membership?: MembershipPlanCreateNestedOneWithoutUsersInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    scenarios?: ScenarioCreateNestedManyWithoutCreatedByInput
    emails?: FollowUpEmailCreateNestedManyWithoutUserInput
    operationLogs?: OperationLogCreateNestedManyWithoutUserInput
    oauthAccounts?: OAuthAccountCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    pointRecords?: PointRecordCreateNestedManyWithoutUserInput
    notifications?: UserNotificationCreateNestedManyWithoutUserInput
    articles?: ArticleCreateNestedManyWithoutAuthorInput
    media?: MediaCreateNestedManyWithoutUploadedByInput
    roleAssignments?: UserRoleAssignmentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPersonaTemplatesInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    avatar?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    department?: string | null
    isActive?: boolean
    language?: string
    membershipId?: string | null
    membershipExpireAt?: Date | string | null
    points?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutCreatedByInput
    emails?: FollowUpEmailUncheckedCreateNestedManyWithoutUserInput
    operationLogs?: OperationLogUncheckedCreateNestedManyWithoutUserInput
    oauthAccounts?: OAuthAccountUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    pointRecords?: PointRecordUncheckedCreateNestedManyWithoutUserInput
    notifications?: UserNotificationUncheckedCreateNestedManyWithoutUserInput
    articles?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    media?: MediaUncheckedCreateNestedManyWithoutUploadedByInput
    roleAssignments?: UserRoleAssignmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPersonaTemplatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPersonaTemplatesInput, UserUncheckedCreateWithoutPersonaTemplatesInput>
  }

  export type UserUpsertWithoutPersonaTemplatesInput = {
    update: XOR<UserUpdateWithoutPersonaTemplatesInput, UserUncheckedUpdateWithoutPersonaTemplatesInput>
    create: XOR<UserCreateWithoutPersonaTemplatesInput, UserUncheckedCreateWithoutPersonaTemplatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPersonaTemplatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPersonaTemplatesInput, UserUncheckedUpdateWithoutPersonaTemplatesInput>
  }

  export type UserUpdateWithoutPersonaTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    membershipExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    membership?: MembershipPlanUpdateOneWithoutUsersNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUpdateManyWithoutCreatedByNestedInput
    emails?: FollowUpEmailUpdateManyWithoutUserNestedInput
    operationLogs?: OperationLogUpdateManyWithoutUserNestedInput
    oauthAccounts?: OAuthAccountUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    pointRecords?: PointRecordUpdateManyWithoutUserNestedInput
    notifications?: UserNotificationUpdateManyWithoutUserNestedInput
    articles?: ArticleUpdateManyWithoutAuthorNestedInput
    media?: MediaUpdateManyWithoutUploadedByNestedInput
    roleAssignments?: UserRoleAssignmentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPersonaTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    membershipId?: NullableStringFieldUpdateOperationsInput | string | null
    membershipExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutCreatedByNestedInput
    emails?: FollowUpEmailUncheckedUpdateManyWithoutUserNestedInput
    operationLogs?: OperationLogUncheckedUpdateManyWithoutUserNestedInput
    oauthAccounts?: OAuthAccountUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    pointRecords?: PointRecordUncheckedUpdateManyWithoutUserNestedInput
    notifications?: UserNotificationUncheckedUpdateManyWithoutUserNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    media?: MediaUncheckedUpdateManyWithoutUploadedByNestedInput
    roleAssignments?: UserRoleAssignmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutOperationLogsInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    avatar?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    department?: string | null
    isActive?: boolean
    language?: string
    membershipExpireAt?: Date | string | null
    points?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    membership?: MembershipPlanCreateNestedOneWithoutUsersInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    scenarios?: ScenarioCreateNestedManyWithoutCreatedByInput
    emails?: FollowUpEmailCreateNestedManyWithoutUserInput
    personaTemplates?: BuyerPersonaTemplateCreateNestedManyWithoutCreatedByInput
    oauthAccounts?: OAuthAccountCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    pointRecords?: PointRecordCreateNestedManyWithoutUserInput
    notifications?: UserNotificationCreateNestedManyWithoutUserInput
    articles?: ArticleCreateNestedManyWithoutAuthorInput
    media?: MediaCreateNestedManyWithoutUploadedByInput
    roleAssignments?: UserRoleAssignmentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOperationLogsInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    avatar?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    department?: string | null
    isActive?: boolean
    language?: string
    membershipId?: string | null
    membershipExpireAt?: Date | string | null
    points?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutCreatedByInput
    emails?: FollowUpEmailUncheckedCreateNestedManyWithoutUserInput
    personaTemplates?: BuyerPersonaTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    oauthAccounts?: OAuthAccountUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    pointRecords?: PointRecordUncheckedCreateNestedManyWithoutUserInput
    notifications?: UserNotificationUncheckedCreateNestedManyWithoutUserInput
    articles?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    media?: MediaUncheckedCreateNestedManyWithoutUploadedByInput
    roleAssignments?: UserRoleAssignmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOperationLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOperationLogsInput, UserUncheckedCreateWithoutOperationLogsInput>
  }

  export type UserUpsertWithoutOperationLogsInput = {
    update: XOR<UserUpdateWithoutOperationLogsInput, UserUncheckedUpdateWithoutOperationLogsInput>
    create: XOR<UserCreateWithoutOperationLogsInput, UserUncheckedCreateWithoutOperationLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOperationLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOperationLogsInput, UserUncheckedUpdateWithoutOperationLogsInput>
  }

  export type UserUpdateWithoutOperationLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    membershipExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    membership?: MembershipPlanUpdateOneWithoutUsersNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUpdateManyWithoutCreatedByNestedInput
    emails?: FollowUpEmailUpdateManyWithoutUserNestedInput
    personaTemplates?: BuyerPersonaTemplateUpdateManyWithoutCreatedByNestedInput
    oauthAccounts?: OAuthAccountUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    pointRecords?: PointRecordUpdateManyWithoutUserNestedInput
    notifications?: UserNotificationUpdateManyWithoutUserNestedInput
    articles?: ArticleUpdateManyWithoutAuthorNestedInput
    media?: MediaUpdateManyWithoutUploadedByNestedInput
    roleAssignments?: UserRoleAssignmentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOperationLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    membershipId?: NullableStringFieldUpdateOperationsInput | string | null
    membershipExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutCreatedByNestedInput
    emails?: FollowUpEmailUncheckedUpdateManyWithoutUserNestedInput
    personaTemplates?: BuyerPersonaTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    oauthAccounts?: OAuthAccountUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    pointRecords?: PointRecordUncheckedUpdateManyWithoutUserNestedInput
    notifications?: UserNotificationUncheckedUpdateManyWithoutUserNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    media?: MediaUncheckedUpdateManyWithoutUploadedByNestedInput
    roleAssignments?: UserRoleAssignmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutMediaInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    avatar?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    department?: string | null
    isActive?: boolean
    language?: string
    membershipExpireAt?: Date | string | null
    points?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    membership?: MembershipPlanCreateNestedOneWithoutUsersInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    scenarios?: ScenarioCreateNestedManyWithoutCreatedByInput
    emails?: FollowUpEmailCreateNestedManyWithoutUserInput
    personaTemplates?: BuyerPersonaTemplateCreateNestedManyWithoutCreatedByInput
    operationLogs?: OperationLogCreateNestedManyWithoutUserInput
    oauthAccounts?: OAuthAccountCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    pointRecords?: PointRecordCreateNestedManyWithoutUserInput
    notifications?: UserNotificationCreateNestedManyWithoutUserInput
    articles?: ArticleCreateNestedManyWithoutAuthorInput
    roleAssignments?: UserRoleAssignmentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMediaInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    avatar?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    department?: string | null
    isActive?: boolean
    language?: string
    membershipId?: string | null
    membershipExpireAt?: Date | string | null
    points?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutCreatedByInput
    emails?: FollowUpEmailUncheckedCreateNestedManyWithoutUserInput
    personaTemplates?: BuyerPersonaTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    operationLogs?: OperationLogUncheckedCreateNestedManyWithoutUserInput
    oauthAccounts?: OAuthAccountUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    pointRecords?: PointRecordUncheckedCreateNestedManyWithoutUserInput
    notifications?: UserNotificationUncheckedCreateNestedManyWithoutUserInput
    articles?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    roleAssignments?: UserRoleAssignmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMediaInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMediaInput, UserUncheckedCreateWithoutMediaInput>
  }

  export type UserUpsertWithoutMediaInput = {
    update: XOR<UserUpdateWithoutMediaInput, UserUncheckedUpdateWithoutMediaInput>
    create: XOR<UserCreateWithoutMediaInput, UserUncheckedCreateWithoutMediaInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMediaInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMediaInput, UserUncheckedUpdateWithoutMediaInput>
  }

  export type UserUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    membershipExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    membership?: MembershipPlanUpdateOneWithoutUsersNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUpdateManyWithoutCreatedByNestedInput
    emails?: FollowUpEmailUpdateManyWithoutUserNestedInput
    personaTemplates?: BuyerPersonaTemplateUpdateManyWithoutCreatedByNestedInput
    operationLogs?: OperationLogUpdateManyWithoutUserNestedInput
    oauthAccounts?: OAuthAccountUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    pointRecords?: PointRecordUpdateManyWithoutUserNestedInput
    notifications?: UserNotificationUpdateManyWithoutUserNestedInput
    articles?: ArticleUpdateManyWithoutAuthorNestedInput
    roleAssignments?: UserRoleAssignmentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    membershipId?: NullableStringFieldUpdateOperationsInput | string | null
    membershipExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutCreatedByNestedInput
    emails?: FollowUpEmailUncheckedUpdateManyWithoutUserNestedInput
    personaTemplates?: BuyerPersonaTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    operationLogs?: OperationLogUncheckedUpdateManyWithoutUserNestedInput
    oauthAccounts?: OAuthAccountUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    pointRecords?: PointRecordUncheckedUpdateManyWithoutUserNestedInput
    notifications?: UserNotificationUncheckedUpdateManyWithoutUserNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    roleAssignments?: UserRoleAssignmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PluginInstallationCreateWithoutPluginInput = {
    id?: string
    isEnabled?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    installedAt?: Date | string
    updatedAt?: Date | string
  }

  export type PluginInstallationUncheckedCreateWithoutPluginInput = {
    id?: string
    isEnabled?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    installedAt?: Date | string
    updatedAt?: Date | string
  }

  export type PluginInstallationCreateOrConnectWithoutPluginInput = {
    where: PluginInstallationWhereUniqueInput
    create: XOR<PluginInstallationCreateWithoutPluginInput, PluginInstallationUncheckedCreateWithoutPluginInput>
  }

  export type PluginInstallationCreateManyPluginInputEnvelope = {
    data: PluginInstallationCreateManyPluginInput | PluginInstallationCreateManyPluginInput[]
    skipDuplicates?: boolean
  }

  export type PluginInstallationUpsertWithWhereUniqueWithoutPluginInput = {
    where: PluginInstallationWhereUniqueInput
    update: XOR<PluginInstallationUpdateWithoutPluginInput, PluginInstallationUncheckedUpdateWithoutPluginInput>
    create: XOR<PluginInstallationCreateWithoutPluginInput, PluginInstallationUncheckedCreateWithoutPluginInput>
  }

  export type PluginInstallationUpdateWithWhereUniqueWithoutPluginInput = {
    where: PluginInstallationWhereUniqueInput
    data: XOR<PluginInstallationUpdateWithoutPluginInput, PluginInstallationUncheckedUpdateWithoutPluginInput>
  }

  export type PluginInstallationUpdateManyWithWhereWithoutPluginInput = {
    where: PluginInstallationScalarWhereInput
    data: XOR<PluginInstallationUpdateManyMutationInput, PluginInstallationUncheckedUpdateManyWithoutPluginInput>
  }

  export type PluginInstallationScalarWhereInput = {
    AND?: PluginInstallationScalarWhereInput | PluginInstallationScalarWhereInput[]
    OR?: PluginInstallationScalarWhereInput[]
    NOT?: PluginInstallationScalarWhereInput | PluginInstallationScalarWhereInput[]
    id?: StringFilter<"PluginInstallation"> | string
    pluginId?: StringFilter<"PluginInstallation"> | string
    isEnabled?: BoolFilter<"PluginInstallation"> | boolean
    config?: JsonNullableFilter<"PluginInstallation">
    installedAt?: DateTimeFilter<"PluginInstallation"> | Date | string
    updatedAt?: DateTimeFilter<"PluginInstallation"> | Date | string
  }

  export type PluginCreateWithoutInstallationsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    icon?: string | null
    version?: string
    author?: string | null
    category: $Enums.PluginCategory
    price?: number
    downloadCount?: number
    rating?: number
    isActive?: boolean
    isFeatured?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    permissions: JsonNullValueInput | InputJsonValue
    dependencies: JsonNullValueInput | InputJsonValue
    changelog?: NullableJsonNullValueInput | InputJsonValue
    screenshots: JsonNullValueInput | InputJsonValue
    documentation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PluginUncheckedCreateWithoutInstallationsInput = {
    id?: string
    slug: string
    name: string
    description?: string | null
    icon?: string | null
    version?: string
    author?: string | null
    category: $Enums.PluginCategory
    price?: number
    downloadCount?: number
    rating?: number
    isActive?: boolean
    isFeatured?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    permissions: JsonNullValueInput | InputJsonValue
    dependencies: JsonNullValueInput | InputJsonValue
    changelog?: NullableJsonNullValueInput | InputJsonValue
    screenshots: JsonNullValueInput | InputJsonValue
    documentation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PluginCreateOrConnectWithoutInstallationsInput = {
    where: PluginWhereUniqueInput
    create: XOR<PluginCreateWithoutInstallationsInput, PluginUncheckedCreateWithoutInstallationsInput>
  }

  export type PluginUpsertWithoutInstallationsInput = {
    update: XOR<PluginUpdateWithoutInstallationsInput, PluginUncheckedUpdateWithoutInstallationsInput>
    create: XOR<PluginCreateWithoutInstallationsInput, PluginUncheckedCreateWithoutInstallationsInput>
    where?: PluginWhereInput
  }

  export type PluginUpdateToOneWithWhereWithoutInstallationsInput = {
    where?: PluginWhereInput
    data: XOR<PluginUpdateWithoutInstallationsInput, PluginUncheckedUpdateWithoutInstallationsInput>
  }

  export type PluginUpdateWithoutInstallationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumPluginCategoryFieldUpdateOperationsInput | $Enums.PluginCategory
    price?: FloatFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    permissions?: JsonNullValueInput | InputJsonValue
    dependencies?: JsonNullValueInput | InputJsonValue
    changelog?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: JsonNullValueInput | InputJsonValue
    documentation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PluginUncheckedUpdateWithoutInstallationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumPluginCategoryFieldUpdateOperationsInput | $Enums.PluginCategory
    price?: FloatFieldUpdateOperationsInput | number
    downloadCount?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    permissions?: JsonNullValueInput | InputJsonValue
    dependencies?: JsonNullValueInput | InputJsonValue
    changelog?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: JsonNullValueInput | InputJsonValue
    documentation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleCategoryCreateWithoutChildrenInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: ArticleCategoryCreateNestedOneWithoutChildrenInput
    articles?: ArticleCreateNestedManyWithoutCategoryInput
  }

  export type ArticleCategoryUncheckedCreateWithoutChildrenInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    parentId?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    articles?: ArticleUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ArticleCategoryCreateOrConnectWithoutChildrenInput = {
    where: ArticleCategoryWhereUniqueInput
    create: XOR<ArticleCategoryCreateWithoutChildrenInput, ArticleCategoryUncheckedCreateWithoutChildrenInput>
  }

  export type ArticleCategoryCreateWithoutParentInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ArticleCategoryCreateNestedManyWithoutParentInput
    articles?: ArticleCreateNestedManyWithoutCategoryInput
  }

  export type ArticleCategoryUncheckedCreateWithoutParentInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ArticleCategoryUncheckedCreateNestedManyWithoutParentInput
    articles?: ArticleUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ArticleCategoryCreateOrConnectWithoutParentInput = {
    where: ArticleCategoryWhereUniqueInput
    create: XOR<ArticleCategoryCreateWithoutParentInput, ArticleCategoryUncheckedCreateWithoutParentInput>
  }

  export type ArticleCategoryCreateManyParentInputEnvelope = {
    data: ArticleCategoryCreateManyParentInput | ArticleCategoryCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type ArticleCreateWithoutCategoryInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    coverImage?: string | null
    status?: $Enums.ArticleStatus
    viewCount?: number
    tags: JsonNullValueInput | InputJsonValue
    seoTitle?: string | null
    seoDescription?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutArticlesInput
  }

  export type ArticleUncheckedCreateWithoutCategoryInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    coverImage?: string | null
    authorId: string
    status?: $Enums.ArticleStatus
    viewCount?: number
    tags: JsonNullValueInput | InputJsonValue
    seoTitle?: string | null
    seoDescription?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ArticleCreateOrConnectWithoutCategoryInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutCategoryInput, ArticleUncheckedCreateWithoutCategoryInput>
  }

  export type ArticleCreateManyCategoryInputEnvelope = {
    data: ArticleCreateManyCategoryInput | ArticleCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ArticleCategoryUpsertWithoutChildrenInput = {
    update: XOR<ArticleCategoryUpdateWithoutChildrenInput, ArticleCategoryUncheckedUpdateWithoutChildrenInput>
    create: XOR<ArticleCategoryCreateWithoutChildrenInput, ArticleCategoryUncheckedCreateWithoutChildrenInput>
    where?: ArticleCategoryWhereInput
  }

  export type ArticleCategoryUpdateToOneWithWhereWithoutChildrenInput = {
    where?: ArticleCategoryWhereInput
    data: XOR<ArticleCategoryUpdateWithoutChildrenInput, ArticleCategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type ArticleCategoryUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: ArticleCategoryUpdateOneWithoutChildrenNestedInput
    articles?: ArticleUpdateManyWithoutCategoryNestedInput
  }

  export type ArticleCategoryUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articles?: ArticleUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ArticleCategoryUpsertWithWhereUniqueWithoutParentInput = {
    where: ArticleCategoryWhereUniqueInput
    update: XOR<ArticleCategoryUpdateWithoutParentInput, ArticleCategoryUncheckedUpdateWithoutParentInput>
    create: XOR<ArticleCategoryCreateWithoutParentInput, ArticleCategoryUncheckedCreateWithoutParentInput>
  }

  export type ArticleCategoryUpdateWithWhereUniqueWithoutParentInput = {
    where: ArticleCategoryWhereUniqueInput
    data: XOR<ArticleCategoryUpdateWithoutParentInput, ArticleCategoryUncheckedUpdateWithoutParentInput>
  }

  export type ArticleCategoryUpdateManyWithWhereWithoutParentInput = {
    where: ArticleCategoryScalarWhereInput
    data: XOR<ArticleCategoryUpdateManyMutationInput, ArticleCategoryUncheckedUpdateManyWithoutParentInput>
  }

  export type ArticleCategoryScalarWhereInput = {
    AND?: ArticleCategoryScalarWhereInput | ArticleCategoryScalarWhereInput[]
    OR?: ArticleCategoryScalarWhereInput[]
    NOT?: ArticleCategoryScalarWhereInput | ArticleCategoryScalarWhereInput[]
    id?: StringFilter<"ArticleCategory"> | string
    name?: StringFilter<"ArticleCategory"> | string
    slug?: StringFilter<"ArticleCategory"> | string
    description?: StringNullableFilter<"ArticleCategory"> | string | null
    parentId?: StringNullableFilter<"ArticleCategory"> | string | null
    sortOrder?: IntFilter<"ArticleCategory"> | number
    isActive?: BoolFilter<"ArticleCategory"> | boolean
    createdAt?: DateTimeFilter<"ArticleCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ArticleCategory"> | Date | string
  }

  export type ArticleUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ArticleWhereUniqueInput
    update: XOR<ArticleUpdateWithoutCategoryInput, ArticleUncheckedUpdateWithoutCategoryInput>
    create: XOR<ArticleCreateWithoutCategoryInput, ArticleUncheckedCreateWithoutCategoryInput>
  }

  export type ArticleUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ArticleWhereUniqueInput
    data: XOR<ArticleUpdateWithoutCategoryInput, ArticleUncheckedUpdateWithoutCategoryInput>
  }

  export type ArticleUpdateManyWithWhereWithoutCategoryInput = {
    where: ArticleScalarWhereInput
    data: XOR<ArticleUpdateManyMutationInput, ArticleUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ArticleCategoryCreateWithoutArticlesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: ArticleCategoryCreateNestedOneWithoutChildrenInput
    children?: ArticleCategoryCreateNestedManyWithoutParentInput
  }

  export type ArticleCategoryUncheckedCreateWithoutArticlesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    parentId?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ArticleCategoryUncheckedCreateNestedManyWithoutParentInput
  }

  export type ArticleCategoryCreateOrConnectWithoutArticlesInput = {
    where: ArticleCategoryWhereUniqueInput
    create: XOR<ArticleCategoryCreateWithoutArticlesInput, ArticleCategoryUncheckedCreateWithoutArticlesInput>
  }

  export type UserCreateWithoutArticlesInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    avatar?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    department?: string | null
    isActive?: boolean
    language?: string
    membershipExpireAt?: Date | string | null
    points?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    membership?: MembershipPlanCreateNestedOneWithoutUsersInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    scenarios?: ScenarioCreateNestedManyWithoutCreatedByInput
    emails?: FollowUpEmailCreateNestedManyWithoutUserInput
    personaTemplates?: BuyerPersonaTemplateCreateNestedManyWithoutCreatedByInput
    operationLogs?: OperationLogCreateNestedManyWithoutUserInput
    oauthAccounts?: OAuthAccountCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    pointRecords?: PointRecordCreateNestedManyWithoutUserInput
    notifications?: UserNotificationCreateNestedManyWithoutUserInput
    media?: MediaCreateNestedManyWithoutUploadedByInput
    roleAssignments?: UserRoleAssignmentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutArticlesInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    avatar?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    department?: string | null
    isActive?: boolean
    language?: string
    membershipId?: string | null
    membershipExpireAt?: Date | string | null
    points?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutCreatedByInput
    emails?: FollowUpEmailUncheckedCreateNestedManyWithoutUserInput
    personaTemplates?: BuyerPersonaTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    operationLogs?: OperationLogUncheckedCreateNestedManyWithoutUserInput
    oauthAccounts?: OAuthAccountUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    pointRecords?: PointRecordUncheckedCreateNestedManyWithoutUserInput
    notifications?: UserNotificationUncheckedCreateNestedManyWithoutUserInput
    media?: MediaUncheckedCreateNestedManyWithoutUploadedByInput
    roleAssignments?: UserRoleAssignmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutArticlesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutArticlesInput, UserUncheckedCreateWithoutArticlesInput>
  }

  export type ArticleCategoryUpsertWithoutArticlesInput = {
    update: XOR<ArticleCategoryUpdateWithoutArticlesInput, ArticleCategoryUncheckedUpdateWithoutArticlesInput>
    create: XOR<ArticleCategoryCreateWithoutArticlesInput, ArticleCategoryUncheckedCreateWithoutArticlesInput>
    where?: ArticleCategoryWhereInput
  }

  export type ArticleCategoryUpdateToOneWithWhereWithoutArticlesInput = {
    where?: ArticleCategoryWhereInput
    data: XOR<ArticleCategoryUpdateWithoutArticlesInput, ArticleCategoryUncheckedUpdateWithoutArticlesInput>
  }

  export type ArticleCategoryUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: ArticleCategoryUpdateOneWithoutChildrenNestedInput
    children?: ArticleCategoryUpdateManyWithoutParentNestedInput
  }

  export type ArticleCategoryUncheckedUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ArticleCategoryUncheckedUpdateManyWithoutParentNestedInput
  }

  export type UserUpsertWithoutArticlesInput = {
    update: XOR<UserUpdateWithoutArticlesInput, UserUncheckedUpdateWithoutArticlesInput>
    create: XOR<UserCreateWithoutArticlesInput, UserUncheckedCreateWithoutArticlesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutArticlesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutArticlesInput, UserUncheckedUpdateWithoutArticlesInput>
  }

  export type UserUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    membershipExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    membership?: MembershipPlanUpdateOneWithoutUsersNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUpdateManyWithoutCreatedByNestedInput
    emails?: FollowUpEmailUpdateManyWithoutUserNestedInput
    personaTemplates?: BuyerPersonaTemplateUpdateManyWithoutCreatedByNestedInput
    operationLogs?: OperationLogUpdateManyWithoutUserNestedInput
    oauthAccounts?: OAuthAccountUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    pointRecords?: PointRecordUpdateManyWithoutUserNestedInput
    notifications?: UserNotificationUpdateManyWithoutUserNestedInput
    media?: MediaUpdateManyWithoutUploadedByNestedInput
    roleAssignments?: UserRoleAssignmentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    membershipId?: NullableStringFieldUpdateOperationsInput | string | null
    membershipExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutCreatedByNestedInput
    emails?: FollowUpEmailUncheckedUpdateManyWithoutUserNestedInput
    personaTemplates?: BuyerPersonaTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    operationLogs?: OperationLogUncheckedUpdateManyWithoutUserNestedInput
    oauthAccounts?: OAuthAccountUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    pointRecords?: PointRecordUncheckedUpdateManyWithoutUserNestedInput
    notifications?: UserNotificationUncheckedUpdateManyWithoutUserNestedInput
    media?: MediaUncheckedUpdateManyWithoutUploadedByNestedInput
    roleAssignments?: UserRoleAssignmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserNotificationCreateWithoutNotificationInput = {
    id?: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type UserNotificationUncheckedCreateWithoutNotificationInput = {
    id?: string
    userId: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserNotificationCreateOrConnectWithoutNotificationInput = {
    where: UserNotificationWhereUniqueInput
    create: XOR<UserNotificationCreateWithoutNotificationInput, UserNotificationUncheckedCreateWithoutNotificationInput>
  }

  export type UserNotificationCreateManyNotificationInputEnvelope = {
    data: UserNotificationCreateManyNotificationInput | UserNotificationCreateManyNotificationInput[]
    skipDuplicates?: boolean
  }

  export type UserNotificationUpsertWithWhereUniqueWithoutNotificationInput = {
    where: UserNotificationWhereUniqueInput
    update: XOR<UserNotificationUpdateWithoutNotificationInput, UserNotificationUncheckedUpdateWithoutNotificationInput>
    create: XOR<UserNotificationCreateWithoutNotificationInput, UserNotificationUncheckedCreateWithoutNotificationInput>
  }

  export type UserNotificationUpdateWithWhereUniqueWithoutNotificationInput = {
    where: UserNotificationWhereUniqueInput
    data: XOR<UserNotificationUpdateWithoutNotificationInput, UserNotificationUncheckedUpdateWithoutNotificationInput>
  }

  export type UserNotificationUpdateManyWithWhereWithoutNotificationInput = {
    where: UserNotificationScalarWhereInput
    data: XOR<UserNotificationUpdateManyMutationInput, UserNotificationUncheckedUpdateManyWithoutNotificationInput>
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    avatar?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    department?: string | null
    isActive?: boolean
    language?: string
    membershipExpireAt?: Date | string | null
    points?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    membership?: MembershipPlanCreateNestedOneWithoutUsersInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    scenarios?: ScenarioCreateNestedManyWithoutCreatedByInput
    emails?: FollowUpEmailCreateNestedManyWithoutUserInput
    personaTemplates?: BuyerPersonaTemplateCreateNestedManyWithoutCreatedByInput
    operationLogs?: OperationLogCreateNestedManyWithoutUserInput
    oauthAccounts?: OAuthAccountCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    pointRecords?: PointRecordCreateNestedManyWithoutUserInput
    articles?: ArticleCreateNestedManyWithoutAuthorInput
    media?: MediaCreateNestedManyWithoutUploadedByInput
    roleAssignments?: UserRoleAssignmentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    avatar?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    department?: string | null
    isActive?: boolean
    language?: string
    membershipId?: string | null
    membershipExpireAt?: Date | string | null
    points?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutCreatedByInput
    emails?: FollowUpEmailUncheckedCreateNestedManyWithoutUserInput
    personaTemplates?: BuyerPersonaTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    operationLogs?: OperationLogUncheckedCreateNestedManyWithoutUserInput
    oauthAccounts?: OAuthAccountUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    pointRecords?: PointRecordUncheckedCreateNestedManyWithoutUserInput
    articles?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    media?: MediaUncheckedCreateNestedManyWithoutUploadedByInput
    roleAssignments?: UserRoleAssignmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type NotificationCreateWithoutUserNotificationsInput = {
    id?: string
    title: string
    content: string
    type: $Enums.NotificationType
    targetType: $Enums.NotificationTarget
    targetIds: JsonNullValueInput | InputJsonValue
    isRead?: boolean
    sendAt?: Date | string | null
    sentAt?: Date | string | null
    createdById?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserNotificationsInput = {
    id?: string
    title: string
    content: string
    type: $Enums.NotificationType
    targetType: $Enums.NotificationTarget
    targetIds: JsonNullValueInput | InputJsonValue
    isRead?: boolean
    sendAt?: Date | string | null
    sentAt?: Date | string | null
    createdById?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserNotificationsInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserNotificationsInput, NotificationUncheckedCreateWithoutUserNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    membershipExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    membership?: MembershipPlanUpdateOneWithoutUsersNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUpdateManyWithoutCreatedByNestedInput
    emails?: FollowUpEmailUpdateManyWithoutUserNestedInput
    personaTemplates?: BuyerPersonaTemplateUpdateManyWithoutCreatedByNestedInput
    operationLogs?: OperationLogUpdateManyWithoutUserNestedInput
    oauthAccounts?: OAuthAccountUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    pointRecords?: PointRecordUpdateManyWithoutUserNestedInput
    articles?: ArticleUpdateManyWithoutAuthorNestedInput
    media?: MediaUpdateManyWithoutUploadedByNestedInput
    roleAssignments?: UserRoleAssignmentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    membershipId?: NullableStringFieldUpdateOperationsInput | string | null
    membershipExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutCreatedByNestedInput
    emails?: FollowUpEmailUncheckedUpdateManyWithoutUserNestedInput
    personaTemplates?: BuyerPersonaTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    operationLogs?: OperationLogUncheckedUpdateManyWithoutUserNestedInput
    oauthAccounts?: OAuthAccountUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    pointRecords?: PointRecordUncheckedUpdateManyWithoutUserNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    media?: MediaUncheckedUpdateManyWithoutUploadedByNestedInput
    roleAssignments?: UserRoleAssignmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type NotificationUpsertWithoutUserNotificationsInput = {
    update: XOR<NotificationUpdateWithoutUserNotificationsInput, NotificationUncheckedUpdateWithoutUserNotificationsInput>
    create: XOR<NotificationCreateWithoutUserNotificationsInput, NotificationUncheckedCreateWithoutUserNotificationsInput>
    where?: NotificationWhereInput
  }

  export type NotificationUpdateToOneWithWhereWithoutUserNotificationsInput = {
    where?: NotificationWhereInput
    data: XOR<NotificationUpdateWithoutUserNotificationsInput, NotificationUncheckedUpdateWithoutUserNotificationsInput>
  }

  export type NotificationUpdateWithoutUserNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    targetType?: EnumNotificationTargetFieldUpdateOperationsInput | $Enums.NotificationTarget
    targetIds?: JsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    targetType?: EnumNotificationTargetFieldUpdateOperationsInput | $Enums.NotificationTarget
    targetIds?: JsonNullValueInput | InputJsonValue
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutOrdersInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    avatar?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    department?: string | null
    isActive?: boolean
    language?: string
    membershipExpireAt?: Date | string | null
    points?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    membership?: MembershipPlanCreateNestedOneWithoutUsersInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    scenarios?: ScenarioCreateNestedManyWithoutCreatedByInput
    emails?: FollowUpEmailCreateNestedManyWithoutUserInput
    personaTemplates?: BuyerPersonaTemplateCreateNestedManyWithoutCreatedByInput
    operationLogs?: OperationLogCreateNestedManyWithoutUserInput
    oauthAccounts?: OAuthAccountCreateNestedManyWithoutUserInput
    pointRecords?: PointRecordCreateNestedManyWithoutUserInput
    notifications?: UserNotificationCreateNestedManyWithoutUserInput
    articles?: ArticleCreateNestedManyWithoutAuthorInput
    media?: MediaCreateNestedManyWithoutUploadedByInput
    roleAssignments?: UserRoleAssignmentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrdersInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    avatar?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    department?: string | null
    isActive?: boolean
    language?: string
    membershipId?: string | null
    membershipExpireAt?: Date | string | null
    points?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutCreatedByInput
    emails?: FollowUpEmailUncheckedCreateNestedManyWithoutUserInput
    personaTemplates?: BuyerPersonaTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    operationLogs?: OperationLogUncheckedCreateNestedManyWithoutUserInput
    oauthAccounts?: OAuthAccountUncheckedCreateNestedManyWithoutUserInput
    pointRecords?: PointRecordUncheckedCreateNestedManyWithoutUserInput
    notifications?: UserNotificationUncheckedCreateNestedManyWithoutUserInput
    articles?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    media?: MediaUncheckedCreateNestedManyWithoutUploadedByInput
    roleAssignments?: UserRoleAssignmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type UserUpsertWithoutOrdersInput = {
    update: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    membershipExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    membership?: MembershipPlanUpdateOneWithoutUsersNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUpdateManyWithoutCreatedByNestedInput
    emails?: FollowUpEmailUpdateManyWithoutUserNestedInput
    personaTemplates?: BuyerPersonaTemplateUpdateManyWithoutCreatedByNestedInput
    operationLogs?: OperationLogUpdateManyWithoutUserNestedInput
    oauthAccounts?: OAuthAccountUpdateManyWithoutUserNestedInput
    pointRecords?: PointRecordUpdateManyWithoutUserNestedInput
    notifications?: UserNotificationUpdateManyWithoutUserNestedInput
    articles?: ArticleUpdateManyWithoutAuthorNestedInput
    media?: MediaUpdateManyWithoutUploadedByNestedInput
    roleAssignments?: UserRoleAssignmentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    membershipId?: NullableStringFieldUpdateOperationsInput | string | null
    membershipExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutCreatedByNestedInput
    emails?: FollowUpEmailUncheckedUpdateManyWithoutUserNestedInput
    personaTemplates?: BuyerPersonaTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    operationLogs?: OperationLogUncheckedUpdateManyWithoutUserNestedInput
    oauthAccounts?: OAuthAccountUncheckedUpdateManyWithoutUserNestedInput
    pointRecords?: PointRecordUncheckedUpdateManyWithoutUserNestedInput
    notifications?: UserNotificationUncheckedUpdateManyWithoutUserNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    media?: MediaUncheckedUpdateManyWithoutUploadedByNestedInput
    roleAssignments?: UserRoleAssignmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutMembershipInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    avatar?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    department?: string | null
    isActive?: boolean
    language?: string
    membershipExpireAt?: Date | string | null
    points?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    scenarios?: ScenarioCreateNestedManyWithoutCreatedByInput
    emails?: FollowUpEmailCreateNestedManyWithoutUserInput
    personaTemplates?: BuyerPersonaTemplateCreateNestedManyWithoutCreatedByInput
    operationLogs?: OperationLogCreateNestedManyWithoutUserInput
    oauthAccounts?: OAuthAccountCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    pointRecords?: PointRecordCreateNestedManyWithoutUserInput
    notifications?: UserNotificationCreateNestedManyWithoutUserInput
    articles?: ArticleCreateNestedManyWithoutAuthorInput
    media?: MediaCreateNestedManyWithoutUploadedByInput
    roleAssignments?: UserRoleAssignmentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMembershipInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    avatar?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    department?: string | null
    isActive?: boolean
    language?: string
    membershipExpireAt?: Date | string | null
    points?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutCreatedByInput
    emails?: FollowUpEmailUncheckedCreateNestedManyWithoutUserInput
    personaTemplates?: BuyerPersonaTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    operationLogs?: OperationLogUncheckedCreateNestedManyWithoutUserInput
    oauthAccounts?: OAuthAccountUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    pointRecords?: PointRecordUncheckedCreateNestedManyWithoutUserInput
    notifications?: UserNotificationUncheckedCreateNestedManyWithoutUserInput
    articles?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    media?: MediaUncheckedCreateNestedManyWithoutUploadedByInput
    roleAssignments?: UserRoleAssignmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMembershipInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMembershipInput, UserUncheckedCreateWithoutMembershipInput>
  }

  export type UserCreateManyMembershipInputEnvelope = {
    data: UserCreateManyMembershipInput | UserCreateManyMembershipInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutMembershipInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutMembershipInput, UserUncheckedUpdateWithoutMembershipInput>
    create: XOR<UserCreateWithoutMembershipInput, UserUncheckedCreateWithoutMembershipInput>
  }

  export type UserUpdateWithWhereUniqueWithoutMembershipInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutMembershipInput, UserUncheckedUpdateWithoutMembershipInput>
  }

  export type UserUpdateManyWithWhereWithoutMembershipInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutMembershipInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    name?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    department?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    language?: StringFilter<"User"> | string
    membershipId?: StringNullableFilter<"User"> | string | null
    membershipExpireAt?: DateTimeNullableFilter<"User"> | Date | string | null
    points?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type UserCreateWithoutPointRecordsInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    avatar?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    department?: string | null
    isActive?: boolean
    language?: string
    membershipExpireAt?: Date | string | null
    points?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    membership?: MembershipPlanCreateNestedOneWithoutUsersInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    scenarios?: ScenarioCreateNestedManyWithoutCreatedByInput
    emails?: FollowUpEmailCreateNestedManyWithoutUserInput
    personaTemplates?: BuyerPersonaTemplateCreateNestedManyWithoutCreatedByInput
    operationLogs?: OperationLogCreateNestedManyWithoutUserInput
    oauthAccounts?: OAuthAccountCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    notifications?: UserNotificationCreateNestedManyWithoutUserInput
    articles?: ArticleCreateNestedManyWithoutAuthorInput
    media?: MediaCreateNestedManyWithoutUploadedByInput
    roleAssignments?: UserRoleAssignmentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPointRecordsInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    avatar?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    department?: string | null
    isActive?: boolean
    language?: string
    membershipId?: string | null
    membershipExpireAt?: Date | string | null
    points?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutCreatedByInput
    emails?: FollowUpEmailUncheckedCreateNestedManyWithoutUserInput
    personaTemplates?: BuyerPersonaTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    operationLogs?: OperationLogUncheckedCreateNestedManyWithoutUserInput
    oauthAccounts?: OAuthAccountUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    notifications?: UserNotificationUncheckedCreateNestedManyWithoutUserInput
    articles?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    media?: MediaUncheckedCreateNestedManyWithoutUploadedByInput
    roleAssignments?: UserRoleAssignmentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPointRecordsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPointRecordsInput, UserUncheckedCreateWithoutPointRecordsInput>
  }

  export type UserUpsertWithoutPointRecordsInput = {
    update: XOR<UserUpdateWithoutPointRecordsInput, UserUncheckedUpdateWithoutPointRecordsInput>
    create: XOR<UserCreateWithoutPointRecordsInput, UserUncheckedCreateWithoutPointRecordsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPointRecordsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPointRecordsInput, UserUncheckedUpdateWithoutPointRecordsInput>
  }

  export type UserUpdateWithoutPointRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    membershipExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    membership?: MembershipPlanUpdateOneWithoutUsersNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUpdateManyWithoutCreatedByNestedInput
    emails?: FollowUpEmailUpdateManyWithoutUserNestedInput
    personaTemplates?: BuyerPersonaTemplateUpdateManyWithoutCreatedByNestedInput
    operationLogs?: OperationLogUpdateManyWithoutUserNestedInput
    oauthAccounts?: OAuthAccountUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    notifications?: UserNotificationUpdateManyWithoutUserNestedInput
    articles?: ArticleUpdateManyWithoutAuthorNestedInput
    media?: MediaUpdateManyWithoutUploadedByNestedInput
    roleAssignments?: UserRoleAssignmentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPointRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    membershipId?: NullableStringFieldUpdateOperationsInput | string | null
    membershipExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutCreatedByNestedInput
    emails?: FollowUpEmailUncheckedUpdateManyWithoutUserNestedInput
    personaTemplates?: BuyerPersonaTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    operationLogs?: OperationLogUncheckedUpdateManyWithoutUserNestedInput
    oauthAccounts?: OAuthAccountUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    notifications?: UserNotificationUncheckedUpdateManyWithoutUserNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    media?: MediaUncheckedUpdateManyWithoutUploadedByNestedInput
    roleAssignments?: UserRoleAssignmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserRoleAssignmentCreateWithoutRoleInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutRoleAssignmentsInput
  }

  export type UserRoleAssignmentUncheckedCreateWithoutRoleInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type UserRoleAssignmentCreateOrConnectWithoutRoleInput = {
    where: UserRoleAssignmentWhereUniqueInput
    create: XOR<UserRoleAssignmentCreateWithoutRoleInput, UserRoleAssignmentUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleAssignmentCreateManyRoleInputEnvelope = {
    data: UserRoleAssignmentCreateManyRoleInput | UserRoleAssignmentCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleAssignmentUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserRoleAssignmentWhereUniqueInput
    update: XOR<UserRoleAssignmentUpdateWithoutRoleInput, UserRoleAssignmentUncheckedUpdateWithoutRoleInput>
    create: XOR<UserRoleAssignmentCreateWithoutRoleInput, UserRoleAssignmentUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleAssignmentUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserRoleAssignmentWhereUniqueInput
    data: XOR<UserRoleAssignmentUpdateWithoutRoleInput, UserRoleAssignmentUncheckedUpdateWithoutRoleInput>
  }

  export type UserRoleAssignmentUpdateManyWithWhereWithoutRoleInput = {
    where: UserRoleAssignmentScalarWhereInput
    data: XOR<UserRoleAssignmentUpdateManyMutationInput, UserRoleAssignmentUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserCreateWithoutRoleAssignmentsInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    avatar?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    department?: string | null
    isActive?: boolean
    language?: string
    membershipExpireAt?: Date | string | null
    points?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    membership?: MembershipPlanCreateNestedOneWithoutUsersInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    scenarios?: ScenarioCreateNestedManyWithoutCreatedByInput
    emails?: FollowUpEmailCreateNestedManyWithoutUserInput
    personaTemplates?: BuyerPersonaTemplateCreateNestedManyWithoutCreatedByInput
    operationLogs?: OperationLogCreateNestedManyWithoutUserInput
    oauthAccounts?: OAuthAccountCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    pointRecords?: PointRecordCreateNestedManyWithoutUserInput
    notifications?: UserNotificationCreateNestedManyWithoutUserInput
    articles?: ArticleCreateNestedManyWithoutAuthorInput
    media?: MediaCreateNestedManyWithoutUploadedByInput
  }

  export type UserUncheckedCreateWithoutRoleAssignmentsInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    avatar?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    department?: string | null
    isActive?: boolean
    language?: string
    membershipId?: string | null
    membershipExpireAt?: Date | string | null
    points?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutCreatedByInput
    emails?: FollowUpEmailUncheckedCreateNestedManyWithoutUserInput
    personaTemplates?: BuyerPersonaTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    operationLogs?: OperationLogUncheckedCreateNestedManyWithoutUserInput
    oauthAccounts?: OAuthAccountUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    pointRecords?: PointRecordUncheckedCreateNestedManyWithoutUserInput
    notifications?: UserNotificationUncheckedCreateNestedManyWithoutUserInput
    articles?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
    media?: MediaUncheckedCreateNestedManyWithoutUploadedByInput
  }

  export type UserCreateOrConnectWithoutRoleAssignmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoleAssignmentsInput, UserUncheckedCreateWithoutRoleAssignmentsInput>
  }

  export type RoleCreateWithoutUserAssignmentsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    isSystem?: boolean
    permissions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUncheckedCreateWithoutUserAssignmentsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    isSystem?: boolean
    permissions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleCreateOrConnectWithoutUserAssignmentsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUserAssignmentsInput, RoleUncheckedCreateWithoutUserAssignmentsInput>
  }

  export type UserUpsertWithoutRoleAssignmentsInput = {
    update: XOR<UserUpdateWithoutRoleAssignmentsInput, UserUncheckedUpdateWithoutRoleAssignmentsInput>
    create: XOR<UserCreateWithoutRoleAssignmentsInput, UserUncheckedCreateWithoutRoleAssignmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRoleAssignmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRoleAssignmentsInput, UserUncheckedUpdateWithoutRoleAssignmentsInput>
  }

  export type UserUpdateWithoutRoleAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    membershipExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    membership?: MembershipPlanUpdateOneWithoutUsersNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUpdateManyWithoutCreatedByNestedInput
    emails?: FollowUpEmailUpdateManyWithoutUserNestedInput
    personaTemplates?: BuyerPersonaTemplateUpdateManyWithoutCreatedByNestedInput
    operationLogs?: OperationLogUpdateManyWithoutUserNestedInput
    oauthAccounts?: OAuthAccountUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    pointRecords?: PointRecordUpdateManyWithoutUserNestedInput
    notifications?: UserNotificationUpdateManyWithoutUserNestedInput
    articles?: ArticleUpdateManyWithoutAuthorNestedInput
    media?: MediaUpdateManyWithoutUploadedByNestedInput
  }

  export type UserUncheckedUpdateWithoutRoleAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    membershipId?: NullableStringFieldUpdateOperationsInput | string | null
    membershipExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutCreatedByNestedInput
    emails?: FollowUpEmailUncheckedUpdateManyWithoutUserNestedInput
    personaTemplates?: BuyerPersonaTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    operationLogs?: OperationLogUncheckedUpdateManyWithoutUserNestedInput
    oauthAccounts?: OAuthAccountUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    pointRecords?: PointRecordUncheckedUpdateManyWithoutUserNestedInput
    notifications?: UserNotificationUncheckedUpdateManyWithoutUserNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    media?: MediaUncheckedUpdateManyWithoutUploadedByNestedInput
  }

  export type RoleUpsertWithoutUserAssignmentsInput = {
    update: XOR<RoleUpdateWithoutUserAssignmentsInput, RoleUncheckedUpdateWithoutUserAssignmentsInput>
    create: XOR<RoleCreateWithoutUserAssignmentsInput, RoleUncheckedCreateWithoutUserAssignmentsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUserAssignmentsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUserAssignmentsInput, RoleUncheckedUpdateWithoutUserAssignmentsInput>
  }

  export type RoleUpdateWithoutUserAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateWithoutUserAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranslationCreateWithoutLanguageInput = {
    id?: string
    key: string
    value: string
    namespace?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TranslationUncheckedCreateWithoutLanguageInput = {
    id?: string
    key: string
    value: string
    namespace?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TranslationCreateOrConnectWithoutLanguageInput = {
    where: TranslationWhereUniqueInput
    create: XOR<TranslationCreateWithoutLanguageInput, TranslationUncheckedCreateWithoutLanguageInput>
  }

  export type TranslationCreateManyLanguageInputEnvelope = {
    data: TranslationCreateManyLanguageInput | TranslationCreateManyLanguageInput[]
    skipDuplicates?: boolean
  }

  export type TranslationUpsertWithWhereUniqueWithoutLanguageInput = {
    where: TranslationWhereUniqueInput
    update: XOR<TranslationUpdateWithoutLanguageInput, TranslationUncheckedUpdateWithoutLanguageInput>
    create: XOR<TranslationCreateWithoutLanguageInput, TranslationUncheckedCreateWithoutLanguageInput>
  }

  export type TranslationUpdateWithWhereUniqueWithoutLanguageInput = {
    where: TranslationWhereUniqueInput
    data: XOR<TranslationUpdateWithoutLanguageInput, TranslationUncheckedUpdateWithoutLanguageInput>
  }

  export type TranslationUpdateManyWithWhereWithoutLanguageInput = {
    where: TranslationScalarWhereInput
    data: XOR<TranslationUpdateManyMutationInput, TranslationUncheckedUpdateManyWithoutLanguageInput>
  }

  export type TranslationScalarWhereInput = {
    AND?: TranslationScalarWhereInput | TranslationScalarWhereInput[]
    OR?: TranslationScalarWhereInput[]
    NOT?: TranslationScalarWhereInput | TranslationScalarWhereInput[]
    id?: StringFilter<"Translation"> | string
    languageId?: StringFilter<"Translation"> | string
    key?: StringFilter<"Translation"> | string
    value?: StringFilter<"Translation"> | string
    namespace?: StringFilter<"Translation"> | string
    createdAt?: DateTimeFilter<"Translation"> | Date | string
    updatedAt?: DateTimeFilter<"Translation"> | Date | string
  }

  export type LanguageCreateWithoutTranslationsInput = {
    id?: string
    code: string
    name: string
    nativeName: string
    isEnabled?: boolean
    isDefault?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LanguageUncheckedCreateWithoutTranslationsInput = {
    id?: string
    code: string
    name: string
    nativeName: string
    isEnabled?: boolean
    isDefault?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LanguageCreateOrConnectWithoutTranslationsInput = {
    where: LanguageWhereUniqueInput
    create: XOR<LanguageCreateWithoutTranslationsInput, LanguageUncheckedCreateWithoutTranslationsInput>
  }

  export type LanguageUpsertWithoutTranslationsInput = {
    update: XOR<LanguageUpdateWithoutTranslationsInput, LanguageUncheckedUpdateWithoutTranslationsInput>
    create: XOR<LanguageCreateWithoutTranslationsInput, LanguageUncheckedCreateWithoutTranslationsInput>
    where?: LanguageWhereInput
  }

  export type LanguageUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: LanguageWhereInput
    data: XOR<LanguageUpdateWithoutTranslationsInput, LanguageUncheckedUpdateWithoutTranslationsInput>
  }

  export type LanguageUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageUncheckedUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nativeName?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    scenarioId: string
    status?: $Enums.SessionStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ScenarioCreateManyCreatedByInput = {
    id?: string
    title: string
    description: string
    category: string
    difficulty?: $Enums.Difficulty
    estimatedDuration?: number
    isActive?: boolean
    practiceCount?: number
    averageScore?: number
    buyerPersona: JsonNullValueInput | InputJsonValue
    objections: JsonNullValueInput | InputJsonValue
    idealResponses: JsonNullValueInput | InputJsonValue
    maxTurns?: number
    scoringWeights?: NullableJsonNullValueInput | InputJsonValue
    openingPrompt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FollowUpEmailCreateManyUserInput = {
    id?: string
    sessionId: string
    toAddress?: string | null
    subject: string
    body: string
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuyerPersonaTemplateCreateManyCreatedByInput = {
    id?: string
    name: string
    role: string
    company: string
    background: string
    concerns: JsonNullValueInput | InputJsonValue
    personality: string
    category: string
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OperationLogCreateManyUserInput = {
    id?: string
    operationType: string
    targetType: string
    targetId?: string | null
    description: string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type OAuthAccountCreateManyUserInput = {
    id?: string
    provider: $Enums.OAuthProvider
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpireAt?: Date | string | null
    profile?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyUserInput = {
    id?: string
    orderNo: string
    orderType: $Enums.OrderType
    status?: $Enums.OrderStatus
    amount: number
    currency?: string
    paymentMethod?: $Enums.PaymentProvider | null
    transactionId?: string | null
    productId?: string | null
    productName: string
    productDesc?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    paidAt?: Date | string | null
    refundedAt?: Date | string | null
    expiredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PointRecordCreateManyUserInput = {
    id?: string
    points: number
    balance: number
    type: $Enums.PointType
    description: string
    relatedId?: string | null
    createdAt?: Date | string
  }

  export type UserNotificationCreateManyUserInput = {
    id?: string
    notificationId: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ArticleCreateManyAuthorInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    coverImage?: string | null
    categoryId?: string | null
    status?: $Enums.ArticleStatus
    viewCount?: number
    tags: JsonNullValueInput | InputJsonValue
    seoTitle?: string | null
    seoDescription?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaCreateManyUploadedByInput = {
    id?: string
    name: string
    originalName: string
    path: string
    url: string
    mimeType: string
    size: number
    width?: number | null
    height?: number | null
    storageType?: $Enums.StorageType
    bucket?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRoleAssignmentCreateManyUserInput = {
    id?: string
    roleId: string
    createdAt?: Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scenario?: ScenarioUpdateOneRequiredWithoutSessionsNestedInput
    messages?: MessageUpdateManyWithoutSessionNestedInput
    feedback?: FeedbackUpdateOneWithoutSessionNestedInput
    email?: FollowUpEmailUpdateOneWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    scenarioId?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutSessionNestedInput
    feedback?: FeedbackUncheckedUpdateOneWithoutSessionNestedInput
    email?: FollowUpEmailUncheckedUpdateOneWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    scenarioId?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ScenarioUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    practiceCount?: IntFieldUpdateOperationsInput | number
    averageScore?: FloatFieldUpdateOperationsInput | number
    buyerPersona?: JsonNullValueInput | InputJsonValue
    objections?: JsonNullValueInput | InputJsonValue
    idealResponses?: JsonNullValueInput | InputJsonValue
    maxTurns?: IntFieldUpdateOperationsInput | number
    scoringWeights?: NullableJsonNullValueInput | InputJsonValue
    openingPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutScenarioNestedInput
  }

  export type ScenarioUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    practiceCount?: IntFieldUpdateOperationsInput | number
    averageScore?: FloatFieldUpdateOperationsInput | number
    buyerPersona?: JsonNullValueInput | InputJsonValue
    objections?: JsonNullValueInput | InputJsonValue
    idealResponses?: JsonNullValueInput | InputJsonValue
    maxTurns?: IntFieldUpdateOperationsInput | number
    scoringWeights?: NullableJsonNullValueInput | InputJsonValue
    openingPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutScenarioNestedInput
  }

  export type ScenarioUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    practiceCount?: IntFieldUpdateOperationsInput | number
    averageScore?: FloatFieldUpdateOperationsInput | number
    buyerPersona?: JsonNullValueInput | InputJsonValue
    objections?: JsonNullValueInput | InputJsonValue
    idealResponses?: JsonNullValueInput | InputJsonValue
    maxTurns?: IntFieldUpdateOperationsInput | number
    scoringWeights?: NullableJsonNullValueInput | InputJsonValue
    openingPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUpEmailUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    toAddress?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SessionUpdateOneRequiredWithoutEmailNestedInput
  }

  export type FollowUpEmailUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    toAddress?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUpEmailUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    toAddress?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuyerPersonaTemplateUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    concerns?: JsonNullValueInput | InputJsonValue
    personality?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuyerPersonaTemplateUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    concerns?: JsonNullValueInput | InputJsonValue
    personality?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuyerPersonaTemplateUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    background?: StringFieldUpdateOperationsInput | string
    concerns?: JsonNullValueInput | InputJsonValue
    personality?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperationLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperationLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperationLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthAccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumOAuthProviderFieldUpdateOperationsInput | $Enums.OAuthProvider
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthAccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumOAuthProviderFieldUpdateOperationsInput | $Enums.OAuthProvider
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthAccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumOAuthProviderFieldUpdateOperationsInput | $Enums.OAuthProvider
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    orderType?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    productName?: StringFieldUpdateOperationsInput | string
    productDesc?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    orderType?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    productName?: StringFieldUpdateOperationsInput | string
    productDesc?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    orderType?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    productName?: StringFieldUpdateOperationsInput | string
    productDesc?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointRecordUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    type?: EnumPointTypeFieldUpdateOperationsInput | $Enums.PointType
    description?: StringFieldUpdateOperationsInput | string
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointRecordUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    type?: EnumPointTypeFieldUpdateOperationsInput | $Enums.PointType
    description?: StringFieldUpdateOperationsInput | string
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointRecordUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    type?: EnumPointTypeFieldUpdateOperationsInput | $Enums.PointType
    description?: StringFieldUpdateOperationsInput | string
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notification?: NotificationUpdateOneRequiredWithoutUserNotificationsNestedInput
  }

  export type UserNotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationId?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationId?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumArticleStatusFieldUpdateOperationsInput | $Enums.ArticleStatus
    viewCount?: IntFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ArticleCategoryUpdateOneWithoutArticlesNestedInput
  }

  export type ArticleUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumArticleStatusFieldUpdateOperationsInput | $Enums.ArticleStatus
    viewCount?: IntFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumArticleStatusFieldUpdateOperationsInput | $Enums.ArticleStatus
    viewCount?: IntFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    storageType?: EnumStorageTypeFieldUpdateOperationsInput | $Enums.StorageType
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUncheckedUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    storageType?: EnumStorageTypeFieldUpdateOperationsInput | $Enums.StorageType
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUncheckedUpdateManyWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    storageType?: EnumStorageTypeFieldUpdateOperationsInput | $Enums.StorageType
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleAssignmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUserAssignmentsNestedInput
  }

  export type UserRoleAssignmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleAssignmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyScenarioInput = {
    id?: string
    userId: string
    status?: $Enums.SessionStatus
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type SessionUpdateWithoutScenarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
    messages?: MessageUpdateManyWithoutSessionNestedInput
    feedback?: FeedbackUpdateOneWithoutSessionNestedInput
    email?: FollowUpEmailUpdateOneWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutScenarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutSessionNestedInput
    feedback?: FeedbackUncheckedUpdateOneWithoutSessionNestedInput
    email?: FollowUpEmailUncheckedUpdateOneWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateManyWithoutScenarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageCreateManySessionInput = {
    id?: string
    role: $Enums.MessageRole
    content: string
    timestamp?: Date | string
  }

  export type MessageUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PluginInstallationCreateManyPluginInput = {
    id?: string
    isEnabled?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    installedAt?: Date | string
    updatedAt?: Date | string
  }

  export type PluginInstallationUpdateWithoutPluginInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    installedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PluginInstallationUncheckedUpdateWithoutPluginInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    installedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PluginInstallationUncheckedUpdateManyWithoutPluginInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    installedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleCategoryCreateManyParentInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ArticleCreateManyCategoryInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    coverImage?: string | null
    authorId: string
    status?: $Enums.ArticleStatus
    viewCount?: number
    tags: JsonNullValueInput | InputJsonValue
    seoTitle?: string | null
    seoDescription?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ArticleCategoryUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ArticleCategoryUpdateManyWithoutParentNestedInput
    articles?: ArticleUpdateManyWithoutCategoryNestedInput
  }

  export type ArticleCategoryUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ArticleCategoryUncheckedUpdateManyWithoutParentNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ArticleCategoryUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumArticleStatusFieldUpdateOperationsInput | $Enums.ArticleStatus
    viewCount?: IntFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutArticlesNestedInput
  }

  export type ArticleUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    status?: EnumArticleStatusFieldUpdateOperationsInput | $Enums.ArticleStatus
    viewCount?: IntFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    status?: EnumArticleStatusFieldUpdateOperationsInput | $Enums.ArticleStatus
    viewCount?: IntFieldUpdateOperationsInput | number
    tags?: JsonNullValueInput | InputJsonValue
    seoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    seoDescription?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNotificationCreateManyNotificationInput = {
    id?: string
    userId: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserNotificationUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type UserNotificationUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNotificationUncheckedUpdateManyWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyMembershipInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    avatar?: string | null
    phone?: string | null
    role?: $Enums.UserRole
    department?: string | null
    isActive?: boolean
    language?: string
    membershipExpireAt?: Date | string | null
    points?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutMembershipInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    membershipExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUpdateManyWithoutCreatedByNestedInput
    emails?: FollowUpEmailUpdateManyWithoutUserNestedInput
    personaTemplates?: BuyerPersonaTemplateUpdateManyWithoutCreatedByNestedInput
    operationLogs?: OperationLogUpdateManyWithoutUserNestedInput
    oauthAccounts?: OAuthAccountUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    pointRecords?: PointRecordUpdateManyWithoutUserNestedInput
    notifications?: UserNotificationUpdateManyWithoutUserNestedInput
    articles?: ArticleUpdateManyWithoutAuthorNestedInput
    media?: MediaUpdateManyWithoutUploadedByNestedInput
    roleAssignments?: UserRoleAssignmentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMembershipInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    membershipExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    scenarios?: ScenarioUncheckedUpdateManyWithoutCreatedByNestedInput
    emails?: FollowUpEmailUncheckedUpdateManyWithoutUserNestedInput
    personaTemplates?: BuyerPersonaTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    operationLogs?: OperationLogUncheckedUpdateManyWithoutUserNestedInput
    oauthAccounts?: OAuthAccountUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    pointRecords?: PointRecordUncheckedUpdateManyWithoutUserNestedInput
    notifications?: UserNotificationUncheckedUpdateManyWithoutUserNestedInput
    articles?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
    media?: MediaUncheckedUpdateManyWithoutUploadedByNestedInput
    roleAssignments?: UserRoleAssignmentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutMembershipInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    membershipExpireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleAssignmentCreateManyRoleInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type UserRoleAssignmentUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRoleAssignmentsNestedInput
  }

  export type UserRoleAssignmentUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleAssignmentUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranslationCreateManyLanguageInput = {
    id?: string
    key: string
    value: string
    namespace?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TranslationUpdateWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    namespace?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranslationUncheckedUpdateWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    namespace?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranslationUncheckedUpdateManyWithoutLanguageInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    namespace?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ScenarioCountOutputTypeDefaultArgs instead
     */
    export type ScenarioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ScenarioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionCountOutputTypeDefaultArgs instead
     */
    export type SessionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PluginCountOutputTypeDefaultArgs instead
     */
    export type PluginCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PluginCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ArticleCategoryCountOutputTypeDefaultArgs instead
     */
    export type ArticleCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ArticleCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationCountOutputTypeDefaultArgs instead
     */
    export type NotificationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MembershipPlanCountOutputTypeDefaultArgs instead
     */
    export type MembershipPlanCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MembershipPlanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleCountOutputTypeDefaultArgs instead
     */
    export type RoleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LanguageCountOutputTypeDefaultArgs instead
     */
    export type LanguageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LanguageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OAuthAccountDefaultArgs instead
     */
    export type OAuthAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OAuthAccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LoginConfigDefaultArgs instead
     */
    export type LoginConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LoginConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ScenarioDefaultArgs instead
     */
    export type ScenarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ScenarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageDefaultArgs instead
     */
    export type MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeedbackDefaultArgs instead
     */
    export type FeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeedbackDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FollowUpEmailDefaultArgs instead
     */
    export type FollowUpEmailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FollowUpEmailDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AIModelDefaultArgs instead
     */
    export type AIModelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AIModelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SystemSettingDefaultArgs instead
     */
    export type SystemSettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SystemSettingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BuyerPersonaTemplateDefaultArgs instead
     */
    export type BuyerPersonaTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BuyerPersonaTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OperationLogDefaultArgs instead
     */
    export type OperationLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OperationLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MediaDefaultArgs instead
     */
    export type MediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MediaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StorageConfigDefaultArgs instead
     */
    export type StorageConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StorageConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PluginDefaultArgs instead
     */
    export type PluginArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PluginDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PluginInstallationDefaultArgs instead
     */
    export type PluginInstallationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PluginInstallationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ArticleCategoryDefaultArgs instead
     */
    export type ArticleCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ArticleCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ArticleDefaultArgs instead
     */
    export type ArticleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ArticleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserNotificationDefaultArgs instead
     */
    export type UserNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserNotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentConfigDefaultArgs instead
     */
    export type PaymentConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderDefaultArgs instead
     */
    export type OrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MembershipPlanDefaultArgs instead
     */
    export type MembershipPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MembershipPlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PointsConfigDefaultArgs instead
     */
    export type PointsConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PointsConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PointRecordDefaultArgs instead
     */
    export type PointRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PointRecordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleDefaultArgs instead
     */
    export type RoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserRoleAssignmentDefaultArgs instead
     */
    export type UserRoleAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserRoleAssignmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PermissionDefaultArgs instead
     */
    export type PermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PermissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LanguageDefaultArgs instead
     */
    export type LanguageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LanguageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TranslationDefaultArgs instead
     */
    export type TranslationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TranslationDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}